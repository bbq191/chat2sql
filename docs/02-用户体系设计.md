# é˜¶æ®µ2ï¼šç”¨æˆ·ä½“ç³»è¯¦ç»†è®¾è®¡

## ğŸ“‹ é˜¶æ®µæ¦‚è¿°

### ç›®æ ‡ä¸ä»·å€¼
åœ¨MVPæ ¸å¿ƒåŠŸèƒ½åŸºç¡€ä¸Šï¼Œæ„å»ºå®Œæ•´çš„å¤šç”¨æˆ·ä½“ç³»ï¼Œå®ç°ç”¨æˆ·ç®¡ç†ã€è®¤è¯æˆæƒã€æƒé™æ§åˆ¶ç­‰ä¼ä¸šçº§åŠŸèƒ½ã€‚

**æ ¸å¿ƒä»·å€¼ä¸»å¼ **ï¼š
- æ”¯æŒå¤šç”¨æˆ·ç‹¬ç«‹ä½¿ç”¨ï¼Œæ•°æ®éš”ç¦»
- çµæ´»çš„è§’è‰²æƒé™ç®¡ç†ï¼Œé€‚åº”ä¸åŒç»„ç»‡æ¶æ„
- å®Œæ•´çš„ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸç®¡ç†
- å®‰å…¨å¯é çš„è®¤è¯æˆæƒæœºåˆ¶
- ä¸ºåç»­ä¼ä¸šçº§åŠŸèƒ½å¥ å®šåŸºç¡€

### æˆåŠŸæŒ‡æ ‡
- **ç”¨æˆ·ç®¡ç†å®Œæ•´æ€§**ï¼šæ”¯æŒç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€å¯†ç é‡ç½®ã€èµ„æ–™ä¿®æ”¹
- **æƒé™æ§åˆ¶ç²¾ç¡®æ€§**ï¼šç²¾ç¡®åˆ°æ¥å£çº§åˆ«çš„æƒé™æ§åˆ¶
- **æ•°æ®éš”ç¦»å®‰å…¨æ€§**ï¼šç”¨æˆ·é—´æ•°æ®å®Œå…¨éš”ç¦»ï¼Œæ— æ•°æ®æ³„éœ²
- **æ€§èƒ½å½±å“æœ€å°**ï¼šæƒé™éªŒè¯å“åº”æ—¶é—´ < 100ms
- **å¹³æ»‘è¿ç§»**ï¼šç°æœ‰åŒ¿åç”¨æˆ·æ•°æ®æ— ç¼è¿ç§»åˆ°å¤šç”¨æˆ·æ¨¡å¼

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

### ç”¨æˆ·ä½“ç³»æ¶æ„å›¾

```mermaid
graph TB
    A[å‰ç«¯åº”ç”¨] --> B[è®¤è¯ä¸­é—´ä»¶]
    B --> C[ç”¨æˆ·æœåŠ¡]
    B --> D[æƒé™æœåŠ¡]
    B --> E[èŠå¤©æœåŠ¡]
    
    C --> F[ç”¨æˆ·æ•°æ®åº“]
    D --> G[æƒé™æ•°æ®åº“]
    E --> H[ä¸šåŠ¡æ•°æ®åº“]
    
    subgraph "è®¤è¯æµç¨‹"
        I[ç™»å½•è¯·æ±‚] --> J[JWT Token]
        J --> K[TokenéªŒè¯]
        K --> L[æƒé™æ£€æŸ¥]
        L --> M[ä¸šåŠ¡é€»è¾‘]
    end
    
    subgraph "æƒé™æ¨¡å‹"
        N[ç”¨æˆ·] --> O[è§’è‰²]
        O --> P[æƒé™]
        P --> Q[èµ„æº]
    end
```

### RBACæƒé™æ¨¡å‹è®¾è®¡

```
ç”¨æˆ·(User) â†â†’ ç”¨æˆ·è§’è‰²(UserRole) â†â†’ è§’è‰²(Role)
                                      â†“
                                   è§’è‰²æƒé™(RolePermission)
                                      â†“
                                   æƒé™(Permission)
                                      â†“
                                   èµ„æº(Resource)
```

**æ ¸å¿ƒæƒé™ç±»åˆ«**ï¼š
1. **èŠå¤©æƒé™**ï¼šchat:create, chat:read, chat:delete
2. **ä¼šè¯æƒé™**ï¼šsession:create, session:read, session:delete
3. **æ•°æ®æŸ¥è¯¢æƒé™**ï¼šquery:execute, query:read, query:export
4. **ç”¨æˆ·ç®¡ç†æƒé™**ï¼šuser:create, user:read, user:update, user:delete
5. **ç³»ç»Ÿç®¡ç†æƒé™**ï¼šsystem:config, system:monitor, system:audit

## ğŸ“Š æ•°æ®åº“è¯¦ç»†è®¾è®¡

### ç”¨æˆ·ä½“ç³»æ ¸å¿ƒè¡¨ç»“æ„

```sql
-- 1. ç”¨æˆ·åŸºç¡€ä¿¡æ¯è¡¨
CREATE TABLE users (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100),
    avatar_url VARCHAR(255),
    department_id TEXT,
    status TINYINT DEFAULT 1 COMMENT '1:active, 0:inactive, -1:deleted',
    last_login_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 2. éƒ¨é—¨ç»„ç»‡æ¶æ„è¡¨
CREATE TABLE departments (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    parent_id TEXT,
    level INTEGER DEFAULT 1,
    sort_order INTEGER DEFAULT 0,
    manager_id TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES departments(id),
    FOREIGN KEY (manager_id) REFERENCES users(id)
);

-- 3. è§’è‰²å®šä¹‰è¡¨
CREATE TABLE roles (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_system BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 4. æƒé™å®šä¹‰è¡¨
CREATE TABLE permissions (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    resource VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 5. ç”¨æˆ·è§’è‰²å…³è”è¡¨
CREATE TABLE user_roles (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    user_id TEXT NOT NULL,
    role_id TEXT NOT NULL,
    assigned_by TEXT,
    assigned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (assigned_by) REFERENCES users(id),
    UNIQUE(user_id, role_id)
);

-- 6. è§’è‰²æƒé™å…³è”è¡¨
CREATE TABLE role_permissions (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    role_id TEXT NOT NULL,
    permission_id TEXT NOT NULL,
    granted_by TEXT,
    granted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE,
    FOREIGN KEY (granted_by) REFERENCES users(id),
    UNIQUE(role_id, permission_id)
);

-- 7. ç”¨æˆ·ä¼šè¯è¡¨
CREATE TABLE user_sessions (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    user_id TEXT NOT NULL,
    token_hash VARCHAR(255) NOT NULL,
    device_info TEXT,
    ip_address VARCHAR(45),
    user_agent TEXT,
    expires_at DATETIME NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_used_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 8. ç”¨æˆ·æ“ä½œå®¡è®¡æ—¥å¿—è¡¨
CREATE TABLE user_audit_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT,
    action VARCHAR(100) NOT NULL,
    resource VARCHAR(100),
    resource_id TEXT,
    old_values JSON,
    new_values JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- æ›´æ–°ç°æœ‰è¡¨ç»“æ„ï¼Œæ·»åŠ ç”¨æˆ·å…³è”
ALTER TABLE chat_sessions ADD COLUMN user_id TEXT;
ALTER TABLE chat_sessions ADD CONSTRAINT fk_chat_sessions_user_id 
    FOREIGN KEY (user_id) REFERENCES users(id);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_department_id ON users(department_id);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_departments_parent_id ON departments(parent_id);
CREATE INDEX idx_user_roles_user_id ON user_roles(user_id);
CREATE INDEX idx_user_roles_role_id ON user_roles(role_id);
CREATE INDEX idx_role_permissions_role_id ON role_permissions(role_id);
CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_token_hash ON user_sessions(token_hash);
CREATE INDEX idx_user_audit_logs_user_id ON user_audit_logs(user_id);
CREATE INDEX idx_user_audit_logs_created_at ON user_audit_logs(created_at);
CREATE INDEX idx_chat_sessions_user_id ON chat_sessions(user_id);
```

### åˆå§‹æ•°æ®æ’å…¥

```sql
-- æ’å…¥é»˜è®¤è§’è‰²
INSERT INTO roles (id, name, display_name, description, is_system) VALUES
('role_admin', 'admin', 'ç³»ç»Ÿç®¡ç†å‘˜', 'æ‹¥æœ‰ç³»ç»Ÿæ‰€æœ‰æƒé™', TRUE),
('role_manager', 'manager', 'éƒ¨é—¨ç»ç†', 'æ‹¥æœ‰éƒ¨é—¨ç®¡ç†æƒé™', TRUE),
('role_analyst', 'analyst', 'æ•°æ®åˆ†æå¸ˆ', 'æ‹¥æœ‰æ•°æ®æŸ¥è¯¢åˆ†ææƒé™', TRUE),
('role_user', 'user', 'æ™®é€šç”¨æˆ·', 'åŸºç¡€èŠå¤©æŸ¥è¯¢æƒé™', TRUE);

-- æ’å…¥é»˜è®¤æƒé™
INSERT INTO permissions (id, name, display_name, resource, action, description) VALUES
-- èŠå¤©ç›¸å…³æƒé™
('perm_chat_create', 'chat:create', 'åˆ›å»ºèŠå¤©', 'chat', 'create', 'åˆ›å»ºæ–°çš„èŠå¤©ä¼šè¯'),
('perm_chat_read', 'chat:read', 'æŸ¥çœ‹èŠå¤©', 'chat', 'read', 'æŸ¥çœ‹èŠå¤©å†å²è®°å½•'),
('perm_chat_update', 'chat:update', 'ä¿®æ”¹èŠå¤©', 'chat', 'update', 'ä¿®æ”¹èŠå¤©å†…å®¹'),
('perm_chat_delete', 'chat:delete', 'åˆ é™¤èŠå¤©', 'chat', 'delete', 'åˆ é™¤èŠå¤©è®°å½•'),

-- ä¼šè¯ç›¸å…³æƒé™
('perm_session_create', 'session:create', 'åˆ›å»ºä¼šè¯', 'session', 'create', 'åˆ›å»ºæ–°çš„èŠå¤©ä¼šè¯'),
('perm_session_read', 'session:read', 'æŸ¥çœ‹ä¼šè¯', 'session', 'read', 'æŸ¥çœ‹ä¼šè¯åˆ—è¡¨'),
('perm_session_delete', 'session:delete', 'åˆ é™¤ä¼šè¯', 'session', 'delete', 'åˆ é™¤èŠå¤©ä¼šè¯'),

-- æŸ¥è¯¢ç›¸å…³æƒé™
('perm_query_execute', 'query:execute', 'æ‰§è¡ŒæŸ¥è¯¢', 'query', 'execute', 'æ‰§è¡ŒSQLæŸ¥è¯¢'),
('perm_query_export', 'query:export', 'å¯¼å‡ºç»“æœ', 'query', 'export', 'å¯¼å‡ºæŸ¥è¯¢ç»“æœ'),

-- ç”¨æˆ·ç®¡ç†æƒé™
('perm_user_create', 'user:create', 'åˆ›å»ºç”¨æˆ·', 'user', 'create', 'åˆ›å»ºæ–°ç”¨æˆ·'),
('perm_user_read', 'user:read', 'æŸ¥çœ‹ç”¨æˆ·', 'user', 'read', 'æŸ¥çœ‹ç”¨æˆ·ä¿¡æ¯'),
('perm_user_update', 'user:update', 'ä¿®æ”¹ç”¨æˆ·', 'user', 'update', 'ä¿®æ”¹ç”¨æˆ·ä¿¡æ¯'),
('perm_user_delete', 'user:delete', 'åˆ é™¤ç”¨æˆ·', 'user', 'delete', 'åˆ é™¤ç”¨æˆ·'),

-- ç³»ç»Ÿç®¡ç†æƒé™
('perm_system_config', 'system:config', 'ç³»ç»Ÿé…ç½®', 'system', 'config', 'ä¿®æ”¹ç³»ç»Ÿé…ç½®'),
('perm_system_audit', 'system:audit', 'ç³»ç»Ÿå®¡è®¡', 'system', 'audit', 'æŸ¥çœ‹ç³»ç»Ÿå®¡è®¡æ—¥å¿—');

-- é…ç½®è§’è‰²æƒé™
INSERT INTO role_permissions (role_id, permission_id) VALUES
-- ç®¡ç†å‘˜ï¼šæ‰€æœ‰æƒé™
('role_admin', 'perm_chat_create'), ('role_admin', 'perm_chat_read'), ('role_admin', 'perm_chat_update'), ('role_admin', 'perm_chat_delete'),
('role_admin', 'perm_session_create'), ('role_admin', 'perm_session_read'), ('role_admin', 'perm_session_delete'),
('role_admin', 'perm_query_execute'), ('role_admin', 'perm_query_export'),
('role_admin', 'perm_user_create'), ('role_admin', 'perm_user_read'), ('role_admin', 'perm_user_update'), ('role_admin', 'perm_user_delete'),
('role_admin', 'perm_system_config'), ('role_admin', 'perm_system_audit'),

-- éƒ¨é—¨ç»ç†ï¼šç”¨æˆ·ç®¡ç† + å®Œæ•´ä¸šåŠ¡æƒé™
('role_manager', 'perm_chat_create'), ('role_manager', 'perm_chat_read'), ('role_manager', 'perm_chat_delete'),
('role_manager', 'perm_session_create'), ('role_manager', 'perm_session_read'), ('role_manager', 'perm_session_delete'),
('role_manager', 'perm_query_execute'), ('role_manager', 'perm_query_export'),
('role_manager', 'perm_user_read'), ('role_manager', 'perm_user_update'),

-- æ•°æ®åˆ†æå¸ˆï¼šæŸ¥è¯¢å¯¼å‡ºæƒé™
('role_analyst', 'perm_chat_create'), ('role_analyst', 'perm_chat_read'),
('role_analyst', 'perm_session_create'), ('role_analyst', 'perm_session_read'), ('role_analyst', 'perm_session_delete'),
('role_analyst', 'perm_query_execute'), ('role_analyst', 'perm_query_export'),

-- æ™®é€šç”¨æˆ·ï¼šåŸºç¡€æƒé™
('role_user', 'perm_chat_create'), ('role_user', 'perm_chat_read'),
('role_user', 'perm_session_create'), ('role_user', 'perm_session_read'), ('role_user', 'perm_session_delete'),
('role_user', 'perm_query_execute');
```

## ğŸ”§ è¯¦ç»†æŠ€æœ¯å®ç°

### 1. è®¤è¯æœåŠ¡å®ç°

```go
// internal/service/auth_service.go
package service

import (
    "context"
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "time"
    
    "golang.org/x/crypto/bcrypt"
    "github.com/golang-jwt/jwt/v5"
)

type AuthService struct {
    userRepo     repository.UserRepository
    sessionRepo  repository.SessionRepository
    jwtSecret    []byte
    tokenExpiry  time.Duration
}

type LoginRequest struct {
    Username string `json:"username" validate:"required"`
    Password string `json:"password" validate:"required"`
    DeviceInfo string `json:"device_info"`
    RememberMe bool `json:"remember_me"`
}

type LoginResponse struct {
    User         *model.User `json:"user"`
    Token        string      `json:"token"`
    RefreshToken string      `json:"refresh_token"`
    ExpiresAt    time.Time   `json:"expires_at"`
}

type RegisterRequest struct {
    Username    string `json:"username" validate:"required,min=3,max=50"`
    Email       string `json:"email" validate:"required,email"`
    Password    string `json:"password" validate:"required,min=8"`
    FullName    string `json:"full_name" validate:"required"`
    Phone       string `json:"phone,omitempty"`
    DepartmentID string `json:"department_id,omitempty"`
}

// NewAuthService åˆ›å»ºè®¤è¯æœåŠ¡å®ä¾‹
func NewAuthService(userRepo repository.UserRepository, sessionRepo repository.SessionRepository, jwtSecret string) *AuthService {
    return &AuthService{
        userRepo:    userRepo,
        sessionRepo: sessionRepo,
        jwtSecret:   []byte(jwtSecret),
        tokenExpiry: 24 * time.Hour, // é»˜è®¤24å°æ—¶è¿‡æœŸ
    }
}

// Login ç”¨æˆ·ç™»å½•
func (as *AuthService) Login(ctx context.Context, req *LoginRequest, clientIP, userAgent string) (*LoginResponse, error) {
    // 1. æŸ¥æ‰¾ç”¨æˆ·
    user, err := as.userRepo.GetByUsernameOrEmail(ctx, req.Username)
    if err != nil {
        return nil, fmt.Errorf("invalid credentials")
    }
    
    // 2. éªŒè¯ç”¨æˆ·çŠ¶æ€
    if user.Status != model.UserStatusActive {
        return nil, fmt.Errorf("user account is disabled")
    }
    
    // 3. éªŒè¯å¯†ç 
    if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil {
        // è®°å½•ç™»å½•å¤±è´¥
        as.recordLoginAttempt(ctx, user.ID, false, clientIP, userAgent)
        return nil, fmt.Errorf("invalid credentials")
    }
    
    // 4. ç”ŸæˆJWT Token
    token, err := as.generateJWTToken(user)
    if err != nil {
        return nil, fmt.Errorf("generate token failed: %w", err)
    }
    
    // 5. ç”ŸæˆRefresh Token
    refreshToken, err := as.generateRefreshToken()
    if err != nil {
        return nil, fmt.Errorf("generate refresh token failed: %w", err)
    }
    
    // 6. åˆ›å»ºç”¨æˆ·ä¼šè¯è®°å½•
    expiresAt := time.Now().Add(as.tokenExpiry)
    if req.RememberMe {
        expiresAt = time.Now().Add(30 * 24 * time.Hour) // 30å¤©
    }
    
    session := &model.UserSession{
        UserID:       user.ID,
        TokenHash:    as.hashToken(token),
        RefreshToken: refreshToken,
        DeviceInfo:   req.DeviceInfo,
        IPAddress:    clientIP,
        UserAgent:    userAgent,
        ExpiresAt:    expiresAt,
        IsActive:     true,
    }
    
    if err := as.sessionRepo.Create(ctx, session); err != nil {
        return nil, fmt.Errorf("create session failed: %w", err)
    }
    
    // 7. æ›´æ–°æœ€åç™»å½•æ—¶é—´
    user.LastLoginAt = time.Now()
    as.userRepo.UpdateLastLogin(ctx, user.ID, user.LastLoginAt)
    
    // 8. è®°å½•ç™»å½•æˆåŠŸ
    as.recordLoginAttempt(ctx, user.ID, true, clientIP, userAgent)
    
    return &LoginResponse{
        User:         user,
        Token:        token,
        RefreshToken: refreshToken,
        ExpiresAt:    expiresAt,
    }, nil
}

// Register ç”¨æˆ·æ³¨å†Œ
func (as *AuthService) Register(ctx context.Context, req *RegisterRequest) (*model.User, error) {
    // 1. æ£€æŸ¥ç”¨æˆ·åå’Œé‚®ç®±å”¯ä¸€æ€§
    if exists, _ := as.userRepo.ExistsByUsername(ctx, req.Username); exists {
        return nil, fmt.Errorf("username already exists")
    }
    
    if exists, _ := as.userRepo.ExistsByEmail(ctx, req.Email); exists {
        return nil, fmt.Errorf("email already exists")
    }
    
    // 2. å¯†ç åŠ å¯†
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, fmt.Errorf("hash password failed: %w", err)
    }
    
    // 3. åˆ›å»ºç”¨æˆ·å¯¹è±¡
    user := &model.User{
        Username:     req.Username,
        Email:        req.Email,
        PasswordHash: string(hashedPassword),
        FullName:     req.FullName,
        Phone:        req.Phone,
        DepartmentID: req.DepartmentID,
        Status:       model.UserStatusActive,
        CreatedAt:    time.Now(),
        UpdatedAt:    time.Now(),
    }
    
    // 4. ä¿å­˜ç”¨æˆ·
    if err := as.userRepo.Create(ctx, user); err != nil {
        return nil, fmt.Errorf("create user failed: %w", err)
    }
    
    // 5. åˆ†é…é»˜è®¤è§’è‰²
    if err := as.assignDefaultRole(ctx, user.ID); err != nil {
        return nil, fmt.Errorf("assign default role failed: %w", err)
    }
    
    return user, nil
}

// ValidateToken éªŒè¯JWT Token
func (as *AuthService) ValidateToken(tokenString string) (*model.User, error) {
    // 1. è§£æJWT Token
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return as.jwtSecret, nil
    })
    
    if err != nil {
        return nil, fmt.Errorf("parse token failed: %w", err)
    }
    
    // 2. éªŒè¯Tokenæœ‰æ•ˆæ€§
    if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
        userID := claims["user_id"].(string)
        
        // 3. æ£€æŸ¥ä¼šè¯æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
        session, err := as.sessionRepo.GetByTokenHash(context.Background(), as.hashToken(tokenString))
        if err != nil || !session.IsActive || time.Now().After(session.ExpiresAt) {
            return nil, fmt.Errorf("session invalid or expired")
        }
        
        // 4. è·å–ç”¨æˆ·ä¿¡æ¯
        user, err := as.userRepo.GetByID(context.Background(), userID)
        if err != nil || user.Status != model.UserStatusActive {
            return nil, fmt.Errorf("user not found or inactive")
        }
        
        // 5. æ›´æ–°ä¼šè¯æœ€åä½¿ç”¨æ—¶é—´
        as.sessionRepo.UpdateLastUsed(context.Background(), session.ID, time.Now())
        
        return user, nil
    }
    
    return nil, fmt.Errorf("invalid token claims")
}

// RefreshToken åˆ·æ–°Token
func (as *AuthService) RefreshToken(ctx context.Context, refreshToken string) (*LoginResponse, error) {
    // 1. æŸ¥æ‰¾ä¼šè¯
    session, err := as.sessionRepo.GetByRefreshToken(ctx, refreshToken)
    if err != nil {
        return nil, fmt.Errorf("invalid refresh token")
    }
    
    // 2. æ£€æŸ¥ä¼šè¯æœ‰æ•ˆæ€§
    if !session.IsActive || time.Now().After(session.ExpiresAt) {
        return nil, fmt.Errorf("refresh token expired")
    }
    
    // 3. è·å–ç”¨æˆ·ä¿¡æ¯
    user, err := as.userRepo.GetByID(ctx, session.UserID)
    if err != nil || user.Status != model.UserStatusActive {
        return nil, fmt.Errorf("user not found or inactive")
    }
    
    // 4. ç”Ÿæˆæ–°çš„Token
    token, err := as.generateJWTToken(user)
    if err != nil {
        return nil, fmt.Errorf("generate new token failed: %w", err)
    }
    
    // 5. ç”Ÿæˆæ–°çš„Refresh Token
    newRefreshToken, err := as.generateRefreshToken()
    if err != nil {
        return nil, fmt.Errorf("generate new refresh token failed: %w", err)
    }
    
    // 6. æ›´æ–°ä¼šè¯
    session.TokenHash = as.hashToken(token)
    session.RefreshToken = newRefreshToken
    session.ExpiresAt = time.Now().Add(as.tokenExpiry)
    session.LastUsedAt = time.Now()
    
    if err := as.sessionRepo.Update(ctx, session); err != nil {
        return nil, fmt.Errorf("update session failed: %w", err)
    }
    
    return &LoginResponse{
        User:         user,
        Token:        token,
        RefreshToken: newRefreshToken,
        ExpiresAt:    session.ExpiresAt,
    }, nil
}

// Logout ç”¨æˆ·ç™»å‡º
func (as *AuthService) Logout(ctx context.Context, tokenString string) error {
    tokenHash := as.hashToken(tokenString)
    return as.sessionRepo.DeactivateByTokenHash(ctx, tokenHash)
}

// è¾…åŠ©æ–¹æ³•
func (as *AuthService) generateJWTToken(user *model.User) (string, error) {
    claims := jwt.MapClaims{
        "user_id":    user.ID,
        "username":   user.Username,
        "email":      user.Email,
        "full_name":  user.FullName,
        "department": user.DepartmentID,
        "exp":        time.Now().Add(as.tokenExpiry).Unix(),
        "iat":        time.Now().Unix(),
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(as.jwtSecret)
}

func (as *AuthService) generateRefreshToken() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(bytes), nil
}

func (as *AuthService) hashToken(token string) string {
    // ä½¿ç”¨SHA-256å“ˆå¸ŒTokenç”¨äºå­˜å‚¨
    hash := sha256.Sum256([]byte(token))
    return base64.StdEncoding.EncodeToString(hash[:])
}

func (as *AuthService) assignDefaultRole(ctx context.Context, userID string) error {
    // åˆ†é…é»˜è®¤çš„æ™®é€šç”¨æˆ·è§’è‰²
    return as.userRepo.AssignRole(ctx, userID, "role_user")
}

func (as *AuthService) recordLoginAttempt(ctx context.Context, userID string, success bool, ip, userAgent string) {
    action := "login_failed"
    if success {
        action = "login_success"
    }
    
    // è®°å½•åˆ°å®¡è®¡æ—¥å¿—ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
    log.Printf("User %s %s from %s", userID, action, ip)
}
```

### 2. æƒé™æœåŠ¡å®ç°

```go
// internal/service/permission_service.go
package service

import (
    "context"
    "fmt"
    "strings"
    "sync"
    "time"
)

type PermissionService struct {
    roleRepo       repository.RoleRepository
    permissionRepo repository.PermissionRepository
    userRepo       repository.UserRepository
    cache          map[string]*UserPermissions
    cacheMutex     sync.RWMutex
    cacheTTL       time.Duration
}

type UserPermissions struct {
    UserID      string
    Roles       []string
    Permissions []string
    ExpiresAt   time.Time
}

type PermissionCheck struct {
    Resource string
    Action   string
}

// NewPermissionService åˆ›å»ºæƒé™æœåŠ¡å®ä¾‹
func NewPermissionService(
    roleRepo repository.RoleRepository,
    permissionRepo repository.PermissionRepository,
    userRepo repository.UserRepository,
) *PermissionService {
    return &PermissionService{
        roleRepo:       roleRepo,
        permissionRepo: permissionRepo,
        userRepo:       userRepo,
        cache:          make(map[string]*UserPermissions),
        cacheTTL:       15 * time.Minute, // ç¼“å­˜15åˆ†é’Ÿ
    }
}

// CheckPermission æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰ç‰¹å®šæƒé™
func (ps *PermissionService) CheckPermission(ctx context.Context, userID, resource, action string) (bool, error) {
    // 1. è·å–ç”¨æˆ·æƒé™ï¼ˆå¸¦ç¼“å­˜ï¼‰
    permissions, err := ps.getUserPermissions(ctx, userID)
    if err != nil {
        return false, fmt.Errorf("get user permissions: %w", err)
    }
    
    // 2. æ£€æŸ¥æƒé™
    permissionName := fmt.Sprintf("%s:%s", resource, action)
    
    for _, perm := range permissions.Permissions {
        if perm == permissionName {
            return true, nil
        }
    }
    
    return false, nil
}

// CheckPermissions æ‰¹é‡æ£€æŸ¥æƒé™
func (ps *PermissionService) CheckPermissions(ctx context.Context, userID string, checks []PermissionCheck) (map[string]bool, error) {
    permissions, err := ps.getUserPermissions(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("get user permissions: %w", err)
    }
    
    result := make(map[string]bool)
    permSet := make(map[string]bool)
    
    // æ„å»ºæƒé™é›†åˆ
    for _, perm := range permissions.Permissions {
        permSet[perm] = true
    }
    
    // æ‰¹é‡æ£€æŸ¥
    for _, check := range checks {
        permissionName := fmt.Sprintf("%s:%s", check.Resource, check.Action)
        result[permissionName] = permSet[permissionName]
    }
    
    return result, nil
}

// HasRole æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰ç‰¹å®šè§’è‰²
func (ps *PermissionService) HasRole(ctx context.Context, userID, roleName string) (bool, error) {
    permissions, err := ps.getUserPermissions(ctx, userID)
    if err != nil {
        return false, fmt.Errorf("get user permissions: %w", err)
    }
    
    for _, role := range permissions.Roles {
        if role == roleName {
            return true, nil
        }
    }
    
    return false, nil
}

// GetUserRoles è·å–ç”¨æˆ·æ‰€æœ‰è§’è‰²
func (ps *PermissionService) GetUserRoles(ctx context.Context, userID string) ([]string, error) {
    permissions, err := ps.getUserPermissions(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("get user permissions: %w", err)
    }
    
    return permissions.Roles, nil
}

// GetUserPermissions è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
func (ps *PermissionService) GetUserPermissions(ctx context.Context, userID string) ([]string, error) {
    permissions, err := ps.getUserPermissions(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("get user permissions: %w", err)
    }
    
    return permissions.Permissions, nil
}

// AssignRole ä¸ºç”¨æˆ·åˆ†é…è§’è‰²
func (ps *PermissionService) AssignRole(ctx context.Context, userID, roleID, assignedBy string) error {
    // 1. æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨
    role, err := ps.roleRepo.GetByID(ctx, roleID)
    if err != nil {
        return fmt.Errorf("role not found: %w", err)
    }
    
    // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æœ‰è¯¥è§’è‰²
    hasRole, err := ps.HasRole(ctx, userID, role.Name)
    if err != nil {
        return fmt.Errorf("check existing role: %w", err)
    }
    
    if hasRole {
        return fmt.Errorf("user already has role: %s", role.Name)
    }
    
    // 3. åˆ†é…è§’è‰²
    userRole := &model.UserRole{
        UserID:     userID,
        RoleID:     roleID,
        AssignedBy: assignedBy,
        AssignedAt: time.Now(),
    }
    
    if err := ps.roleRepo.AssignUserRole(ctx, userRole); err != nil {
        return fmt.Errorf("assign role: %w", err)
    }
    
    // 4. æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜
    ps.clearUserCache(userID)
    
    return nil
}

// RevokeRole æ’¤é”€ç”¨æˆ·è§’è‰²
func (ps *PermissionService) RevokeRole(ctx context.Context, userID, roleID string) error {
    if err := ps.roleRepo.RevokeUserRole(ctx, userID, roleID); err != nil {
        return fmt.Errorf("revoke role: %w", err)
    }
    
    // æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜
    ps.clearUserCache(userID)
    
    return nil
}

// CreateRole åˆ›å»ºæ–°è§’è‰²
func (ps *PermissionService) CreateRole(ctx context.Context, role *model.Role) error {
    // 1. æ£€æŸ¥è§’è‰²åç§°å”¯ä¸€æ€§
    if exists, _ := ps.roleRepo.ExistsByName(ctx, role.Name); exists {
        return fmt.Errorf("role name already exists: %s", role.Name)
    }
    
    // 2. åˆ›å»ºè§’è‰²
    role.CreatedAt = time.Now()
    role.UpdatedAt = time.Now()
    
    return ps.roleRepo.Create(ctx, role)
}

// GrantPermissionToRole ä¸ºè§’è‰²æˆäºˆæƒé™
func (ps *PermissionService) GrantPermissionToRole(ctx context.Context, roleID, permissionID, grantedBy string) error {
    rolePermission := &model.RolePermission{
        RoleID:       roleID,
        PermissionID: permissionID,
        GrantedBy:    grantedBy,
        GrantedAt:    time.Now(),
    }
    
    if err := ps.permissionRepo.GrantToRole(ctx, rolePermission); err != nil {
        return fmt.Errorf("grant permission to role: %w", err)
    }
    
    // æ¸…é™¤æ‰€æœ‰ç›¸å…³ç”¨æˆ·çš„ç¼“å­˜
    ps.clearRoleRelatedCache(roleID)
    
    return nil
}

// ç§æœ‰æ–¹æ³•ï¼šè·å–ç”¨æˆ·æƒé™ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (ps *PermissionService) getUserPermissions(ctx context.Context, userID string) (*UserPermissions, error) {
    ps.cacheMutex.RLock()
    
    // æ£€æŸ¥ç¼“å­˜
    if cached, exists := ps.cache[userID]; exists && time.Now().Before(cached.ExpiresAt) {
        ps.cacheMutex.RUnlock()
        return cached, nil
    }
    ps.cacheMutex.RUnlock()
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“æŸ¥è¯¢
    ps.cacheMutex.Lock()
    defer ps.cacheMutex.Unlock()
    
    // åŒé‡æ£€æŸ¥
    if cached, exists := ps.cache[userID]; exists && time.Now().Before(cached.ExpiresAt) {
        return cached, nil
    }
    
    // 1. è·å–ç”¨æˆ·è§’è‰²
    userRoles, err := ps.roleRepo.GetUserRoles(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("get user roles: %w", err)
    }
    
    var roleNames []string
    var roleIDs []string
    for _, role := range userRoles {
        roleNames = append(roleNames, role.Name)
        roleIDs = append(roleIDs, role.ID)
    }
    
    // 2. è·å–è§’è‰²æƒé™
    permissions, err := ps.permissionRepo.GetByRoleIDs(ctx, roleIDs)
    if err != nil {
        return nil, fmt.Errorf("get role permissions: %w", err)
    }
    
    var permissionNames []string
    for _, perm := range permissions {
        permissionNames = append(permissionNames, perm.Name)
    }
    
    // 3. ç¼“å­˜ç»“æœ
    userPermissions := &UserPermissions{
        UserID:      userID,
        Roles:       roleNames,
        Permissions: permissionNames,
        ExpiresAt:   time.Now().Add(ps.cacheTTL),
    }
    
    ps.cache[userID] = userPermissions
    
    return userPermissions, nil
}

// æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜
func (ps *PermissionService) clearUserCache(userID string) {
    ps.cacheMutex.Lock()
    defer ps.cacheMutex.Unlock()
    
    delete(ps.cache, userID)
}

// æ¸…é™¤è§’è‰²ç›¸å…³çš„æ‰€æœ‰ç”¨æˆ·ç¼“å­˜
func (ps *PermissionService) clearRoleRelatedCache(roleID string) {
    ps.cacheMutex.Lock()
    defer ps.cacheMutex.Unlock()
    
    // ç®€åŒ–å¤„ç†ï¼šæ¸…é™¤æ‰€æœ‰ç¼“å­˜
    // å®é™…åº”ç”¨ä¸­å¯ä»¥ç»´æŠ¤è§’è‰²-ç”¨æˆ·çš„æ˜ å°„å…³ç³»ä»¥ä¾¿ç²¾ç¡®æ¸…é™¤
    ps.cache = make(map[string]*UserPermissions)
}

// å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
func (ps *PermissionService) StartCacheCleanup() {
    ticker := time.NewTicker(5 * time.Minute)
    go func() {
        for range ticker.C {
            ps.cleanupExpiredCache()
        }
    }()
}

func (ps *PermissionService) cleanupExpiredCache() {
    ps.cacheMutex.Lock()
    defer ps.cacheMutex.Unlock()
    
    now := time.Now()
    for userID, permissions := range ps.cache {
        if now.After(permissions.ExpiresAt) {
            delete(ps.cache, userID)
        }
    }
}
```

### 3. è®¤è¯ä¸­é—´ä»¶å®ç°

```go
// internal/middleware/auth.go
package middleware

import (
    "net/http"
    "strings"
    
    "chat2sql/internal/service"
    "chat2sql/internal/model"
    
    "github.com/gin-gonic/gin"
)

type AuthMiddleware struct {
    authService       *service.AuthService
    permissionService *service.PermissionService
}

func NewAuthMiddleware(authService *service.AuthService, permissionService *service.PermissionService) *AuthMiddleware {
    return &AuthMiddleware{
        authService:       authService,
        permissionService: permissionService,
    }
}

// RequireAuth è¦æ±‚ç”¨æˆ·è®¤è¯
func (am *AuthMiddleware) RequireAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. ä»Headerè·å–Token
        token := am.extractTokenFromHeader(c)
        if token == "" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error":   "unauthorized",
                "message": "Authentication token required",
            })
            c.Abort()
            return
        }
        
        // 2. éªŒè¯Token
        user, err := am.authService.ValidateToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error":   "invalid_token",
                "message": "Invalid or expired token",
            })
            c.Abort()
            return
        }
        
        // 3. å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°ä¸Šä¸‹æ–‡
        c.Set("user", user)
        c.Set("user_id", user.ID)
        
        c.Next()
    }
}

// RequirePermission è¦æ±‚ç‰¹å®šæƒé™
func (am *AuthMiddleware) RequirePermission(resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. è·å–å½“å‰ç”¨æˆ·
        user, exists := c.Get("user")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error":   "unauthorized", 
                "message": "User not authenticated",
            })
            c.Abort()
            return
        }
        
        currentUser := user.(*model.User)
        
        // 2. æ£€æŸ¥æƒé™
        hasPermission, err := am.permissionService.CheckPermission(
            c.Request.Context(),
            currentUser.ID,
            resource,
            action,
        )
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                "error":   "permission_check_error",
                "message": "Failed to check permissions",
            })
            c.Abort()
            return
        }
        
        if !hasPermission {
            c.JSON(http.StatusForbidden, gin.H{
                "error":   "insufficient_permissions",
                "message": fmt.Sprintf("Missing permission: %s:%s", resource, action),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// RequireRole è¦æ±‚ç‰¹å®šè§’è‰²
func (am *AuthMiddleware) RequireRole(roleName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. è·å–å½“å‰ç”¨æˆ·
        user, exists := c.Get("user")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error":   "unauthorized",
                "message": "User not authenticated",
            })
            c.Abort()
            return
        }
        
        currentUser := user.(*model.User)
        
        // 2. æ£€æŸ¥è§’è‰²
        hasRole, err := am.permissionService.HasRole(
            c.Request.Context(),
            currentUser.ID,
            roleName,
        )
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                "error":   "role_check_error",
                "message": "Failed to check role",
            })
            c.Abort()
            return
        }
        
        if !hasRole {
            c.JSON(http.StatusForbidden, gin.H{
                "error":   "insufficient_role",
                "message": fmt.Sprintf("Missing role: %s", roleName),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// RequireAnyRole è¦æ±‚ä»»ä¸€è§’è‰²
func (am *AuthMiddleware) RequireAnyRole(roleNames ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        user, exists := c.Get("user")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error":   "unauthorized",
                "message": "User not authenticated",
            })
            c.Abort()
            return
        }
        
        currentUser := user.(*model.User)
        
        // æ£€æŸ¥æ˜¯å¦æ‹¥æœ‰ä»»ä¸€è§’è‰²
        for _, roleName := range roleNames {
            hasRole, err := am.permissionService.HasRole(
                c.Request.Context(),
                currentUser.ID,
                roleName,
            )
            
            if err == nil && hasRole {
                c.Next()
                return
            }
        }
        
        c.JSON(http.StatusForbidden, gin.H{
            "error":   "insufficient_role",
            "message": fmt.Sprintf("Missing any of required roles: %s", strings.Join(roleNames, ", ")),
        })
        c.Abort()
    }
}

// OptionalAuth å¯é€‰è®¤è¯ï¼ˆå…¼å®¹åŒ¿åç”¨æˆ·ï¼‰
func (am *AuthMiddleware) OptionalAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := am.extractTokenFromHeader(c)
        if token != "" {
            user, err := am.authService.ValidateToken(token)
            if err == nil {
                c.Set("user", user)
                c.Set("user_id", user.ID)
                c.Set("authenticated", true)
            }
        } else {
            // åŒ¿åç”¨æˆ·
            c.Set("authenticated", false)
            c.Set("user_id", "anonymous")
        }
        
        c.Next()
    }
}

// DataOwnershipFilter æ•°æ®æ‰€æœ‰æƒè¿‡æ»¤ï¼ˆç¡®ä¿ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„æ•°æ®ï¼‰
func (am *AuthMiddleware) DataOwnershipFilter() gin.HandlerFunc {
    return func(c *gin.Context) {
        // åœ¨ä¸šåŠ¡é€»è¾‘ä¸­ç¡®ä¿æ•°æ®è®¿é—®æƒé™
        // è¿™é‡Œä¸»è¦æ˜¯è®¾ç½®æ ‡è®°ï¼Œå…·ä½“è¿‡æ»¤åœ¨Serviceå±‚å®ç°
        c.Set("enforce_ownership", true)
        c.Next()
    }
}

// ä»è¯·æ±‚å¤´ä¸­æå–Token
func (am *AuthMiddleware) extractTokenFromHeader(c *gin.Context) string {
    authHeader := c.GetHeader("Authorization")
    if authHeader == "" {
        return ""
    }
    
    // æ”¯æŒä¸¤ç§æ ¼å¼ï¼š
    // 1. Authorization: Bearer <token>
    // 2. Authorization: <token>
    
    if strings.HasPrefix(authHeader, "Bearer ") {
        return strings.TrimPrefix(authHeader, "Bearer ")
    }
    
    return authHeader
}
```

### 4. HTTPå¤„ç†å™¨å®ç°

```go
// internal/handler/auth.go
package handler

import (
    "net/http"
    
    "chat2sql/internal/service"
    "chat2sql/internal/model"
    
    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService       *service.AuthService
    permissionService *service.PermissionService
}

func NewAuthHandler(authService *service.AuthService, permissionService *service.PermissionService) *AuthHandler {
    return &AuthHandler{
        authService:       authService,
        permissionService: permissionService,
    }
}

// PostLogin ç”¨æˆ·ç™»å½•
func (h *AuthHandler) PostLogin(c *gin.Context) {
    var req service.LoginRequest
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "invalid_request",
            Message: "Invalid request parameters: " + err.Error(),
        })
        return
    }
    
    clientIP := c.ClientIP()
    userAgent := c.GetHeader("User-Agent")
    
    response, err := h.authService.Login(c.Request.Context(), &req, clientIP, userAgent)
    if err != nil {
        c.JSON(http.StatusUnauthorized, model.ErrorResponse{
            Error:   "login_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, model.SuccessResponse{
        Success: true,
        Data:    response,
    })
}

// PostRegister ç”¨æˆ·æ³¨å†Œ
func (h *AuthHandler) PostRegister(c *gin.Context) {
    var req service.RegisterRequest
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "invalid_request",
            Message: "Invalid request parameters: " + err.Error(),
        })
        return
    }
    
    user, err := h.authService.Register(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "registration_failed",
            Message: err.Error(),
        })
        return
    }
    
    // ç§»é™¤æ•æ„Ÿä¿¡æ¯
    user.PasswordHash = ""
    
    c.JSON(http.StatusCreated, model.SuccessResponse{
        Success: true,
        Data:    user,
        Message: "User registered successfully",
    })
}

// PostRefreshToken åˆ·æ–°Token
func (h *AuthHandler) PostRefreshToken(c *gin.Context) {
    var req struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "invalid_request",
            Message: "Refresh token is required",
        })
        return
    }
    
    response, err := h.authService.RefreshToken(c.Request.Context(), req.RefreshToken)
    if err != nil {
        c.JSON(http.StatusUnauthorized, model.ErrorResponse{
            Error:   "refresh_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, model.SuccessResponse{
        Success: true,
        Data:    response,
    })
}

// PostLogout ç”¨æˆ·ç™»å‡º
func (h *AuthHandler) PostLogout(c *gin.Context) {
    token := c.GetHeader("Authorization")
    if strings.HasPrefix(token, "Bearer ") {
        token = strings.TrimPrefix(token, "Bearer ")
    }
    
    if token == "" {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "invalid_request",
            Message: "Token is required",
        })
        return
    }
    
    err := h.authService.Logout(c.Request.Context(), token)
    if err != nil {
        c.JSON(http.StatusInternalServerError, model.ErrorResponse{
            Error:   "logout_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, model.SuccessResponse{
        Success: true,
        Message: "Logged out successfully",
    })
}

// GetProfile è·å–ç”¨æˆ·èµ„æ–™
func (h *AuthHandler) GetProfile(c *gin.Context) {
    user, _ := c.Get("user")
    currentUser := user.(*model.User)
    
    // è·å–ç”¨æˆ·è§’è‰²å’Œæƒé™
    roles, err := h.permissionService.GetUserRoles(c.Request.Context(), currentUser.ID)
    if err != nil {
        roles = []string{}
    }
    
    permissions, err := h.permissionService.GetUserPermissions(c.Request.Context(), currentUser.ID)
    if err != nil {
        permissions = []string{}
    }
    
    // æ„å»ºå“åº”
    profile := map[string]interface{}{
        "id":            currentUser.ID,
        "username":      currentUser.Username,
        "email":         currentUser.Email,
        "full_name":     currentUser.FullName,
        "phone":         currentUser.Phone,
        "department_id": currentUser.DepartmentID,
        "avatar_url":    currentUser.AvatarURL,
        "status":        currentUser.Status,
        "last_login_at": currentUser.LastLoginAt,
        "created_at":    currentUser.CreatedAt,
        "roles":         roles,
        "permissions":   permissions,
    }
    
    c.JSON(http.StatusOK, model.SuccessResponse{
        Success: true,
        Data:    profile,
    })
}

// PutProfile æ›´æ–°ç”¨æˆ·èµ„æ–™
func (h *AuthHandler) PutProfile(c *gin.Context) {
    user, _ := c.Get("user")
    currentUser := user.(*model.User)
    
    var req struct {
        FullName  string `json:"full_name"`
        Phone     string `json:"phone"`
        AvatarURL string `json:"avatar_url"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "invalid_request",
            Message: err.Error(),
        })
        return
    }
    
    // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    currentUser.FullName = req.FullName
    currentUser.Phone = req.Phone
    currentUser.AvatarURL = req.AvatarURL
    
    // ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆè¿™é‡Œéœ€è¦å®ç°UserRepositoryçš„Updateæ–¹æ³•ï¼‰
    // err := h.userRepo.Update(c.Request.Context(), currentUser)
    
    c.JSON(http.StatusOK, model.SuccessResponse{
        Success: true,
        Message: "Profile updated successfully",
    })
}

// PostChangePassword ä¿®æ”¹å¯†ç 
func (h *AuthHandler) PostChangePassword(c *gin.Context) {
    user, _ := c.Get("user")
    currentUser := user.(*model.User)
    
    var req struct {
        OldPassword string `json:"old_password" binding:"required"`
        NewPassword string `json:"new_password" binding:"required,min=8"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "invalid_request",
            Message: err.Error(),
        })
        return
    }
    
    // éªŒè¯æ—§å¯†ç å¹¶æ›´æ–°æ–°å¯†ç ï¼ˆè¿™é‡Œéœ€è¦åœ¨AuthServiceä¸­å®ç°ChangePasswordæ–¹æ³•ï¼‰
    err := h.authService.ChangePassword(c.Request.Context(), currentUser.ID, req.OldPassword, req.NewPassword)
    if err != nil {
        c.JSON(http.StatusBadRequest, model.ErrorResponse{
            Error:   "change_password_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, model.SuccessResponse{
        Success: true,
        Message: "Password changed successfully",
    })
}
```

### 5. å‰ç«¯è®¤è¯ç»„ä»¶å®ç°

#### ç™»å½•ç»„ä»¶

```svelte
<!-- web/src/lib/components/auth/LoginForm.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { authStore } from '$lib/stores/authStore';
  import { goto } from '$app/navigation';
  import LoadingSpinner from '../LoadingSpinner.svelte';

  const dispatch = createEventDispatcher();

  let username = '';
  let password = '';
  let rememberMe = false;
  let isLoading = false;
  let error = '';

  async function handleLogin() {
    if (!username.trim() || !password.trim()) {
      error = 'ç”¨æˆ·åå’Œå¯†ç ä¸èƒ½ä¸ºç©º';
      return;
    }

    isLoading = true;
    error = '';

    try {
      const response = await fetch('/api/v1/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: username.trim(),
          password,
          remember_me: rememberMe,
          device_info: navigator.userAgent
        })
      });

      const result = await response.json();

      if (result.success) {
        // ä¿å­˜è®¤è¯ä¿¡æ¯åˆ°store
        authStore.login(result.data);
        
        // è·³è½¬åˆ°ä¸»é¡µé¢
        await goto('/');
        
        dispatch('loginSuccess');
      } else {
        error = result.message || 'ç™»å½•å¤±è´¥';
      }
    } catch (err) {
      error = 'ç½‘ç»œè¿æ¥é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
      console.error('Login error:', err);
    } finally {
      isLoading = false;
    }
  }

  function handleKeyDown(event: KeyboardEvent) {
    if (event.key === 'Enter') {
      event.preventDefault();
      handleLogin();
    }
  }
</script>

<div class="min-h-screen flex items-center justify-center bg-base-200 py-12 px-4 sm:px-6 lg:px-8">
  <div class="max-w-md w-full space-y-8">
    <!-- æ ‡é¢˜ -->
    <div class="text-center">
      <h2 class="mt-6 text-3xl font-bold">
        ç™»å½•åˆ° Chat2SQL
      </h2>
      <p class="mt-2 text-sm text-base-content/70">
        ä½¿ç”¨æ‚¨çš„è´¦æˆ·è®¿é—®æ™ºèƒ½æ•°æ®æŸ¥è¯¢ç³»ç»Ÿ
      </p>
    </div>

    <!-- ç™»å½•è¡¨å• -->
    <form class="mt-8 space-y-6" on:submit|preventDefault={handleLogin}>
      <div class="space-y-4">
        <!-- ç”¨æˆ·åè¾“å…¥ -->
        <div>
          <label for="username" class="block text-sm font-medium mb-1">
            ç”¨æˆ·åæˆ–é‚®ç®±
          </label>
          <input
            id="username"
            type="text"
            bind:value={username}
            on:keydown={handleKeyDown}
            disabled={isLoading}
            placeholder="è¯·è¾“å…¥ç”¨æˆ·åæˆ–é‚®ç®±"
            class="input input-bordered w-full"
            class:input-error={error}
          />
        </div>

        <!-- å¯†ç è¾“å…¥ -->
        <div>
          <label for="password" class="block text-sm font-medium mb-1">
            å¯†ç 
          </label>
          <input
            id="password"
            type="password"
            bind:value={password}
            on:keydown={handleKeyDown}
            disabled={isLoading}
            placeholder="è¯·è¾“å…¥å¯†ç "
            class="input input-bordered w-full"
            class:input-error={error}
          />
        </div>
      </div>

      <!-- è®°ä½æˆ‘å’Œå¿˜è®°å¯†ç  -->
      <div class="flex items-center justify-between">
        <label class="flex items-center">
          <input
            type="checkbox"
            bind:checked={rememberMe}
            disabled={isLoading}
            class="checkbox checkbox-primary checkbox-sm"
          />
          <span class="ml-2 text-sm">è®°ä½æˆ‘</span>
        </label>

        <a href="/auth/forgot-password" class="link link-primary text-sm">
          å¿˜è®°å¯†ç ï¼Ÿ
        </a>
      </div>

      <!-- é”™è¯¯æç¤º -->
      {#if error}
        <div class="alert alert-error">
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span>{error}</span>
        </div>
      {/if}

      <!-- ç™»å½•æŒ‰é’® -->
      <button
        type="submit"
        disabled={isLoading || !username.trim() || !password.trim()}
        class="btn btn-primary w-full"
      >
        {#if isLoading}
          <LoadingSpinner size="sm" />
          ç™»å½•ä¸­...
        {:else}
          ç™»å½•
        {/if}
      </button>
    </form>

    <!-- æ³¨å†Œé“¾æ¥ -->
    <div class="text-center">
      <span class="text-sm text-base-content/70">è¿˜æ²¡æœ‰è´¦æˆ·ï¼Ÿ</span>
      <a href="/auth/register" class="link link-primary text-sm">
        ç«‹å³æ³¨å†Œ
      </a>
    </div>
  </div>
</div>
```

#### è®¤è¯çŠ¶æ€ç®¡ç†

```typescript
// web/src/lib/stores/authStore.ts
import { writable, derived } from 'svelte/store';
import { browser } from '$app/environment';

export interface User {
  id: string;
  username: string;
  email: string;
  full_name: string;
  phone?: string;
  department_id?: string;
  avatar_url?: string;
  roles: string[];
  permissions: string[];
}

export interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  token: string | null;
  refreshToken: string | null;
  expiresAt: Date | null;
}

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  token: null,
  refreshToken: null,
  expiresAt: null
};

function createAuthStore() {
  const { subscribe, set, update } = writable<AuthState>(initialState);

  // ä»localStorageæ¢å¤çŠ¶æ€
  if (browser) {
    const stored = localStorage.getItem('auth_state');
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        if (parsed.expiresAt && new Date(parsed.expiresAt) > new Date()) {
          set({
            ...parsed,
            expiresAt: new Date(parsed.expiresAt)
          });
        }
      } catch (e) {
        console.error('Failed to restore auth state:', e);
      }
    }
  }

  return {
    subscribe,
    
    // ç™»å½•
    login: (loginResponse: any) => {
      const newState: AuthState = {
        isAuthenticated: true,
        user: loginResponse.user,
        token: loginResponse.token,
        refreshToken: loginResponse.refresh_token,
        expiresAt: new Date(loginResponse.expires_at)
      };
      
      set(newState);
      
      if (browser) {
        localStorage.setItem('auth_state', JSON.stringify(newState));
      }
    },
    
    // ç™»å‡º
    logout: async () => {
      const currentState = get(authStore);
      
      // è°ƒç”¨åç«¯ç™»å‡ºæ¥å£
      if (currentState.token) {
        try {
          await fetch('/api/v1/auth/logout', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${currentState.token}`,
              'Content-Type': 'application/json'
            }
          });
        } catch (e) {
          console.error('Logout API call failed:', e);
        }
      }
      
      // æ¸…é™¤çŠ¶æ€
      set(initialState);
      
      if (browser) {
        localStorage.removeItem('auth_state');
      }
    },
    
    // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    updateUser: (user: Partial<User>) => {
      update(state => {
        if (state.user) {
          const updatedState = {
            ...state,
            user: { ...state.user, ...user }
          };
          
          if (browser) {
            localStorage.setItem('auth_state', JSON.stringify(updatedState));
          }
          
          return updatedState;
        }
        return state;
      });
    },
    
    // åˆ·æ–°Token
    refreshToken: async () => {
      const currentState = get(authStore);
      
      if (!currentState.refreshToken) {
        throw new Error('No refresh token available');
      }
      
      const response = await fetch('/api/v1/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          refresh_token: currentState.refreshToken
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to refresh token');
      }
      
      const result = await response.json();
      
      if (result.success) {
        const newState: AuthState = {
          ...currentState,
          token: result.data.token,
          refreshToken: result.data.refresh_token,
          expiresAt: new Date(result.data.expires_at)
        };
        
        set(newState);
        
        if (browser) {
          localStorage.setItem('auth_state', JSON.stringify(newState));
        }
        
        return result.data.token;
      } else {
        throw new Error(result.message || 'Token refresh failed');
      }
    },
    
    // æ£€æŸ¥æƒé™
    hasPermission: (resource: string, action: string) => {
      const state = get(authStore);
      const permissionName = `${resource}:${action}`;
      return state.user?.permissions?.includes(permissionName) || false;
    },
    
    // æ£€æŸ¥è§’è‰²
    hasRole: (roleName: string) => {
      const state = get(authStore);
      return state.user?.roles?.includes(roleName) || false;
    },
    
    // æ£€æŸ¥ä»»ä¸€è§’è‰²
    hasAnyRole: (roleNames: string[]) => {
      const state = get(authStore);
      return roleNames.some(role => state.user?.roles?.includes(role)) || false;
    }
  };
}

export const authStore = createAuthStore();

// æ´¾ç”ŸçŠ¶æ€ï¼šæ˜¯å¦ä¸ºç®¡ç†å‘˜
export const isAdmin = derived(authStore, $auth => 
  $auth.user?.roles?.includes('admin') || false
);

// æ´¾ç”ŸçŠ¶æ€ï¼šæ˜¯å¦ä¸ºç®¡ç†è§’è‰²ï¼ˆç®¡ç†å‘˜æˆ–ç»ç†ï¼‰
export const isManager = derived(authStore, $auth => 
  $auth.user?.roles?.some(role => ['admin', 'manager'].includes(role)) || false
);

// è‡ªåŠ¨åˆ·æ–°Token
if (browser) {
  setInterval(async () => {
    const state = get(authStore);
    
    if (state.isAuthenticated && state.expiresAt) {
      // åœ¨è¿‡æœŸå‰5åˆ†é’Ÿåˆ·æ–°Token
      const fiveMinutesFromNow = new Date(Date.now() + 5 * 60 * 1000);
      
      if (state.expiresAt <= fiveMinutesFromNow) {
        try {
          await authStore.refreshToken();
        } catch (e) {
          console.error('Auto token refresh failed:', e);
          // åˆ·æ–°å¤±è´¥ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ
          authStore.logout();
          window.location.href = '/auth/login';
        }
      }
    }
  }, 60 * 1000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
}
```

#### è·¯ç”±å®ˆå«

```svelte
<!-- web/src/lib/components/auth/ProtectedRoute.svelte -->
<script lang="ts">
  import { authStore } from '$lib/stores/authStore';
  import { goto } from '$app/navigation';
  import { onMount } from 'svelte';
  import LoadingSpinner from '../LoadingSpinner.svelte';

  export let requiredPermission: string = '';
  export let requiredRole: string = '';
  export let requiredAnyRole: string[] = [];
  export let redirectTo: string = '/auth/login';

  let isLoading = true;
  let hasAccess = false;

  onMount(() => {
    const unsubscribe = authStore.subscribe(($auth) => {
      isLoading = false;
      
      // æ£€æŸ¥è®¤è¯çŠ¶æ€
      if (!$auth.isAuthenticated) {
        goto(redirectTo);
        return;
      }

      // æ£€æŸ¥æƒé™
      if (requiredPermission) {
        const [resource, action] = requiredPermission.split(':');
        hasAccess = authStore.hasPermission(resource, action);
      }
      
      // æ£€æŸ¥è§’è‰²
      else if (requiredRole) {
        hasAccess = authStore.hasRole(requiredRole);
      }
      
      // æ£€æŸ¥ä»»ä¸€è§’è‰²
      else if (requiredAnyRole.length > 0) {
        hasAccess = authStore.hasAnyRole(requiredAnyRole);
      }
      
      // æ— ç‰¹æ®Šè¦æ±‚ï¼Œåªè¦å·²è®¤è¯å³å¯
      else {
        hasAccess = true;
      }

      // æ— è®¿é—®æƒé™ï¼Œè·³è½¬åˆ°é”™è¯¯é¡µé¢
      if (!hasAccess) {
        goto('/403'); // 403 Forbiddené¡µé¢
      }
    });

    return unsubscribe;
  });
</script>

{#if isLoading}
  <div class="flex items-center justify-center min-h-screen">
    <LoadingSpinner size="lg" />
    <span class="ml-4 text-lg">éªŒè¯æƒé™ä¸­...</span>
  </div>
{:else if hasAccess}
  <slot />
{:else}
  <div class="flex items-center justify-center min-h-screen">
    <div class="text-center">
      <div class="text-6xl mb-4">ğŸš«</div>
      <h1 class="text-2xl font-bold mb-2">è®¿é—®è¢«æ‹’ç»</h1>
      <p class="text-base-content/70 mb-6">æ‚¨æ²¡æœ‰æƒé™è®¿é—®æ­¤é¡µé¢</p>
      <button class="btn btn-primary" on:click={() => goto('/')}>
        è¿”å›é¦–é¡µ
      </button>
    </div>
  </div>
{/if}
```

## ğŸ“ æ•°æ®è¿ç§»ç­–ç•¥

### ä»åŒ¿åç”¨æˆ·åˆ°å¤šç”¨æˆ·ç³»ç»Ÿçš„å¹³æ»‘è¿ç§»

```go
// internal/migration/user_migration.go
package migration

import (
    "context"
    "database/sql"
    "fmt"
    "time"
)

type UserMigration struct {
    db *sql.DB
}

func NewUserMigration(db *sql.DB) *UserMigration {
    return &UserMigration{db: db}
}

// MigrateAnonymousData è¿ç§»åŒ¿åç”¨æˆ·æ•°æ®
func (um *UserMigration) MigrateAnonymousData(ctx context.Context) error {
    // 1. åˆ›å»ºé»˜è®¤åŒ¿åç”¨æˆ·
    anonymousUser := &model.User{
        ID:           "anonymous_user",
        Username:     "anonymous",
        Email:        "anonymous@system.local",
        PasswordHash: "",
        FullName:     "åŒ¿åç”¨æˆ·",
        Status:       model.UserStatusActive,
        CreatedAt:    time.Now(),
        UpdatedAt:    time.Now(),
    }
    
    if err := um.createDefaultUser(ctx, anonymousUser); err != nil {
        return fmt.Errorf("create anonymous user: %w", err)
    }
    
    // 2. æ›´æ–°ç°æœ‰çš„èŠå¤©ä¼šè¯
    if err := um.updateExistingChatSessions(ctx, anonymousUser.ID); err != nil {
        return fmt.Errorf("update existing chat sessions: %w", err)
    }
    
    // 3. åˆ†é…é»˜è®¤è§’è‰²
    if err := um.assignDefaultRoleToUser(ctx, anonymousUser.ID, "role_user"); err != nil {
        return fmt.Errorf("assign default role: %w", err)
    }
    
    return nil
}

func (um *UserMigration) createDefaultUser(ctx context.Context, user *model.User) error {
    query := `
        INSERT OR IGNORE INTO users (id, username, email, password_hash, full_name, status, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `
    
    _, err := um.db.ExecContext(ctx, query,
        user.ID, user.Username, user.Email, user.PasswordHash,
        user.FullName, user.Status, user.CreatedAt, user.UpdatedAt)
    
    return err
}

func (um *UserMigration) updateExistingChatSessions(ctx context.Context, userID string) error {
    query := `
        UPDATE chat_sessions 
        SET user_id = ? 
        WHERE user_id IS NULL OR user_id = ''
    `
    
    result, err := um.db.ExecContext(ctx, query, userID)
    if err != nil {
        return err
    }
    
    rowsAffected, _ := result.RowsAffected()
    fmt.Printf("Updated %d existing chat sessions\n", rowsAffected)
    
    return nil
}

func (um *UserMigration) assignDefaultRoleToUser(ctx context.Context, userID, roleID string) error {
    query := `
        INSERT OR IGNORE INTO user_roles (user_id, role_id, assigned_at)
        VALUES (?, ?, ?)
    `
    
    _, err := um.db.ExecContext(ctx, query, userID, roleID, time.Now())
    return err
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### è®¤è¯ç›¸å…³å•å…ƒæµ‹è¯•

```go
// internal/service/auth_service_test.go
package service

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

func TestAuthService_Login(t *testing.T) {
    mockUserRepo := &mocks.UserRepository{}
    mockSessionRepo := &mocks.SessionRepository{}
    
    authService := NewAuthService(mockUserRepo, mockSessionRepo, "test-secret")
    
    t.Run("æˆåŠŸç™»å½•", func(t *testing.T) {
        // å‡†å¤‡æµ‹è¯•æ•°æ®
        user := &model.User{
            ID:           "user-123",
            Username:     "testuser",
            Email:        "test@example.com",
            PasswordHash: "$2a$10$...", // bcrypt hash for "password123"
            Status:       model.UserStatusActive,
        }
        
        req := &LoginRequest{
            Username: "testuser",
            Password: "password123",
        }
        
        // è®¾ç½®Mock
        mockUserRepo.On("GetByUsernameOrEmail", mock.Anything, "testuser").
            Return(user, nil)
        mockSessionRepo.On("Create", mock.Anything, mock.AnythingOfType("*model.UserSession")).
            Return(nil)
        mockUserRepo.On("UpdateLastLogin", mock.Anything, "user-123", mock.AnythingOfType("time.Time")).
            Return(nil)
        
        // æ‰§è¡Œæµ‹è¯•
        response, err := authService.Login(context.Background(), req, "127.0.0.1", "test-agent")
        
        // éªŒè¯ç»“æœ
        assert.NoError(t, err)
        assert.NotNil(t, response)
        assert.Equal(t, user.ID, response.User.ID)
        assert.NotEmpty(t, response.Token)
        assert.NotEmpty(t, response.RefreshToken)
        
        // éªŒè¯Mockè°ƒç”¨
        mockUserRepo.AssertExpectations(t)
        mockSessionRepo.AssertExpectations(t)
    })
    
    t.Run("ç”¨æˆ·åä¸å­˜åœ¨", func(t *testing.T) {
        req := &LoginRequest{
            Username: "nonexistent",
            Password: "password123",
        }
        
        mockUserRepo.On("GetByUsernameOrEmail", mock.Anything, "nonexistent").
            Return(nil, errors.New("user not found"))
        
        response, err := authService.Login(context.Background(), req, "127.0.0.1", "test-agent")
        
        assert.Error(t, err)
        assert.Nil(t, response)
        assert.Contains(t, err.Error(), "invalid credentials")
    })
    
    t.Run("å¯†ç é”™è¯¯", func(t *testing.T) {
        user := &model.User{
            ID:           "user-123",
            Username:     "testuser",
            PasswordHash: "$2a$10$...", // bcrypt hash for "password123"
            Status:       model.UserStatusActive,
        }
        
        req := &LoginRequest{
            Username: "testuser",
            Password: "wrongpassword",
        }
        
        mockUserRepo.On("GetByUsernameOrEmail", mock.Anything, "testuser").
            Return(user, nil)
        
        response, err := authService.Login(context.Background(), req, "127.0.0.1", "test-agent")
        
        assert.Error(t, err)
        assert.Nil(t, response)
        assert.Contains(t, err.Error(), "invalid credentials")
    })
    
    t.Run("ç”¨æˆ·è¢«ç¦ç”¨", func(t *testing.T) {
        user := &model.User{
            ID:       "user-123",
            Username: "testuser",
            Status:   model.UserStatusInactive,
        }
        
        req := &LoginRequest{
            Username: "testuser",
            Password: "password123",
        }
        
        mockUserRepo.On("GetByUsernameOrEmail", mock.Anything, "testuser").
            Return(user, nil)
        
        response, err := authService.Login(context.Background(), req, "127.0.0.1", "test-agent")
        
        assert.Error(t, err)
        assert.Nil(t, response)
        assert.Contains(t, err.Error(), "user account is disabled")
    })
}

func TestPermissionService_CheckPermission(t *testing.T) {
    mockRoleRepo := &mocks.RoleRepository{}
    mockPermissionRepo := &mocks.PermissionRepository{}
    mockUserRepo := &mocks.UserRepository{}
    
    permissionService := NewPermissionService(mockRoleRepo, mockPermissionRepo, mockUserRepo)
    
    t.Run("ç”¨æˆ·å…·æœ‰æƒé™", func(t *testing.T) {
        userID := "user-123"
        roles := []*model.Role{
            {ID: "role-1", Name: "user"},
        }
        permissions := []*model.Permission{
            {ID: "perm-1", Name: "chat:create"},
            {ID: "perm-2", Name: "chat:read"},
        }
        
        mockRoleRepo.On("GetUserRoles", mock.Anything, userID).Return(roles, nil)
        mockPermissionRepo.On("GetByRoleIDs", mock.Anything, []string{"role-1"}).Return(permissions, nil)
        
        hasPermission, err := permissionService.CheckPermission(context.Background(), userID, "chat", "create")
        
        assert.NoError(t, err)
        assert.True(t, hasPermission)
    })
    
    t.Run("ç”¨æˆ·æ²¡æœ‰æƒé™", func(t *testing.T) {
        userID := "user-123"
        roles := []*model.Role{
            {ID: "role-1", Name: "user"},
        }
        permissions := []*model.Permission{
            {ID: "perm-1", Name: "chat:read"},
        }
        
        mockRoleRepo.On("GetUserRoles", mock.Anything, userID).Return(roles, nil)
        mockPermissionRepo.On("GetByRoleIDs", mock.Anything, []string{"role-1"}).Return(permissions, nil)
        
        hasPermission, err := permissionService.CheckPermission(context.Background(), userID, "user", "create")
        
        assert.NoError(t, err)
        assert.False(t, hasPermission)
    })
}
```

### é›†æˆæµ‹è¯•

```go
// tests/integration/auth_integration_test.go
package integration

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/stretchr/testify/assert"
)

func TestAuthIntegration(t *testing.T) {
    router := setupTestRouter()
    
    t.Run("å®Œæ•´è®¤è¯æµç¨‹", func(t *testing.T) {
        // 1. ç”¨æˆ·æ³¨å†Œ
        registerReq := map[string]string{
            "username":  "testuser",
            "email":     "test@example.com",
            "password":  "password123",
            "full_name": "Test User",
        }
        reqBody, _ := json.Marshal(registerReq)
        
        w := httptest.NewRecorder()
        req, _ := http.NewRequest("POST", "/api/v1/auth/register", bytes.NewBuffer(reqBody))
        req.Header.Set("Content-Type", "application/json")
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusCreated, w.Code)
        
        // 2. ç”¨æˆ·ç™»å½•
        loginReq := map[string]string{
            "username": "testuser",
            "password": "password123",
        }
        reqBody, _ = json.Marshal(loginReq)
        
        w = httptest.NewRecorder()
        req, _ = http.NewRequest("POST", "/api/v1/auth/login", bytes.NewBuffer(reqBody))
        req.Header.Set("Content-Type", "application/json")
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusOK, w.Code)
        
        var loginResp map[string]interface{}
        json.Unmarshal(w.Body.Bytes(), &loginResp)
        
        assert.True(t, loginResp["success"].(bool))
        
        data := loginResp["data"].(map[string]interface{})
        token := data["token"].(string)
        
        // 3. è®¿é—®å—ä¿æŠ¤çš„èµ„æº
        w = httptest.NewRecorder()
        req, _ = http.NewRequest("GET", "/api/v1/auth/profile", nil)
        req.Header.Set("Authorization", "Bearer "+token)
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusOK, w.Code)
        
        var profileResp map[string]interface{}
        json.Unmarshal(w.Body.Bytes(), &profileResp)
        
        assert.True(t, profileResp["success"].(bool))
        
        profile := profileResp["data"].(map[string]interface{})
        assert.Equal(t, "testuser", profile["username"])
        
        // 4. ç”¨æˆ·ç™»å‡º
        w = httptest.NewRecorder()
        req, _ = http.NewRequest("POST", "/api/v1/auth/logout", nil)
        req.Header.Set("Authorization", "Bearer "+token)
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusOK, w.Code)
        
        // 5. éªŒè¯Tokenå·²å¤±æ•ˆ
        w = httptest.NewRecorder()
        req, _ = http.NewRequest("GET", "/api/v1/auth/profile", nil)
        req.Header.Set("Authorization", "Bearer "+token)
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusUnauthorized, w.Code)
    })
}
```

## ğŸ“‹ äº¤ä»˜æ¸…å•

### 1. åç«¯äº¤ä»˜ç‰©
- [ ] å®Œæ•´çš„ç”¨æˆ·è®¤è¯æœåŠ¡
- [ ] RBACæƒé™ç®¡ç†ç³»ç»Ÿ
- [ ] JWT Tokenè®¤è¯ä¸­é—´ä»¶
- [ ] ç”¨æˆ·ç®¡ç†APIæ¥å£
- [ ] æƒé™ç®¡ç†APIæ¥å£
- [ ] æ•°æ®åº“è¿ç§»è„šæœ¬
- [ ] å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### 2. å‰ç«¯äº¤ä»˜ç‰©
- [ ] ç™»å½•æ³¨å†Œé¡µé¢
- [ ] ç”¨æˆ·èµ„æ–™ç®¡ç†ç•Œé¢
- [ ] æƒé™æ§åˆ¶ç»„ä»¶
- [ ] è·¯ç”±å®ˆå«å®ç°
- [ ] è®¤è¯çŠ¶æ€ç®¡ç†
- [ ] å“åº”å¼æƒé™èœå•

### 3. æ•°æ®åº“äº¤ä»˜ç‰©
- [ ] å®Œæ•´çš„ç”¨æˆ·ä½“ç³»è¡¨ç»“æ„
- [ ] åˆå§‹è§’è‰²æƒé™æ•°æ®
- [ ] æ•°æ®è¿ç§»è„šæœ¬
- [ ] ç´¢å¼•ä¼˜åŒ–æ–¹æ¡ˆ

### 4. æ–‡æ¡£äº¤ä»˜ç‰©
- [ ] æƒé™è®¾è®¡æ–‡æ¡£
- [ ] APIæ¥å£æ–‡æ¡£
- [ ] æ•°æ®è¿ç§»æŒ‡å—
- [ ] ç”¨æˆ·ç®¡ç†æ‰‹å†Œ

### 5. éªŒæ”¶æ ‡å‡†
- [ ] ç”¨æˆ·æ³¨å†Œç™»å½•åŠŸèƒ½å®Œæ•´ï¼ˆ100%ï¼‰
- [ ] æƒé™æ§åˆ¶ç²¾ç¡®åˆ°æ¥å£çº§åˆ«ï¼ˆ100%ï¼‰
- [ ] æ•°æ®å®Œå…¨éš”ç¦»æ— æ³„éœ²ï¼ˆ100%ï¼‰
- [ ] æƒé™éªŒè¯å“åº”æ—¶é—´ < 100ms
- [ ] ç°æœ‰æ•°æ®æ— ç¼è¿ç§»ï¼ˆ100%ï¼‰

---

**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š2å‘¨ï¼ˆåœ¨MVPåŸºç¡€ä¸Šå¢é‡å¼€å‘ï¼‰

**ä¾èµ–æ¡ä»¶**ï¼šMVPæ ¸å¿ƒåŠŸèƒ½å·²å®Œæˆå¹¶ç¨³å®šè¿è¡Œ

*æœ¬æ–‡æ¡£ç”±æŠ€æœ¯æ¶æ„å›¢é˜Ÿç»´æŠ¤ï¼Œç‰ˆæœ¬ï¼šv1.0ï¼Œæœ€åæ›´æ–°ï¼š2025-01-08*