# ğŸ¯ æç¤ºè¯å·¥ç¨‹æœ€ä½³å®è·µ

<div align="center">

![Prompt Engineering](https://img.shields.io/badge/Prompt_Engineering-Best_Practices-blue.svg)
![SQL Generation](https://img.shields.io/badge/SQL_Generation-PostgreSQL-green.svg)
![Accuracy](https://img.shields.io/badge/Target_Accuracy-70%25+-orange.svg)

**Chat2SQL P1é˜¶æ®µ - SQLç”Ÿæˆæç¤ºè¯è®¾è®¡ä¸ä¼˜åŒ–æŒ‡å—**

</div>

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸“é—¨é’ˆå¯¹Chat2SQLç³»ç»Ÿçš„SQLç”Ÿæˆæç¤ºè¯è®¾è®¡ï¼Œæä¾›ç³»ç»Ÿæ€§çš„æç¤ºè¯å·¥ç¨‹æ–¹æ³•è®ºã€æ¨¡æ¿åº“å’Œä¼˜åŒ–ç­–ç•¥ã€‚

## ğŸ¯ æ ¸å¿ƒåŸåˆ™

### 1. ç²¾ç¡®æ€§åŸåˆ™
- ç”Ÿæˆçš„SQLå¿…é¡»è¯­æ³•æ­£ç¡®
- å­—æ®µåå¿…é¡»ä¸æ•°æ®åº“ç»“æ„å®Œå…¨åŒ¹é…
- æ•°æ®ç±»å‹è½¬æ¢å¿…é¡»å‡†ç¡®

### 2. å®‰å…¨æ€§åŸåˆ™
- åªå…è®¸SELECTæŸ¥è¯¢æ“ä½œ
- ç¦æ­¢æ‰€æœ‰å†™æ“ä½œï¼ˆINSERTã€UPDATEã€DELETEï¼‰
- é˜²æ­¢SQLæ³¨å…¥æ”»å‡»

### 3. å¯ç†è§£æ€§åŸåˆ™
- æç¤ºè¯ç»“æ„æ¸…æ™°
- è§„åˆ™æ˜ç¡®ä¸”æ— æ­§ä¹‰
- ç¤ºä¾‹å…·æœ‰ä»£è¡¨æ€§

## ğŸ—ï¸ æç¤ºè¯æ¶æ„è®¾è®¡

### åŸºç¡€æ¶æ„æ¨¡æ¿

```go
// internal/ai/prompts/sql_generator.go
const BasePromptTemplate = `
## è§’è‰²å®šä¹‰
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„SQLæŸ¥è¯¢ç”Ÿæˆä¸“å®¶ï¼Œä¸“é—¨ä¸ºPostgreSQL 17æ•°æ®åº“ç”Ÿæˆå‡†ç¡®ã€å®‰å…¨çš„SELECTæŸ¥è¯¢è¯­å¥ã€‚

## æ•°æ®åº“ç»“æ„
{{.DatabaseSchema}}

## ç”¨æˆ·æŸ¥è¯¢
{{.UserQuery}}

{{if .QueryHistory}}
## å†å²æŸ¥è¯¢å‚è€ƒ
{{range .QueryHistory}}
- æŸ¥è¯¢: {{.Query}}
- SQL: {{.SQL}}
{{end}}
{{end}}

## ç”Ÿæˆè§„åˆ™
1. å®‰å…¨æ€§ï¼šåªç”ŸæˆSELECTæŸ¥è¯¢ï¼Œä¸¥ç¦DELETE/UPDATE/INSERT/DROPç­‰æ“ä½œ
2. å‡†ç¡®æ€§ï¼šå­—æ®µåå¿…é¡»ä¸ä¸Šè¿°æ•°æ®åº“ç»“æ„å®Œå…¨åŒ¹é…
3. è¯­æ³•ï¼šä½¿ç”¨PostgreSQL 17æ ‡å‡†è¯­æ³•
4. æ ¼å¼ï¼šè¿”å›çº¯SQLè¯­å¥ï¼Œä¸åŒ…å«è§£é‡Šæ–‡å­—å’Œmarkdownæ ¼å¼
5. æ€§èƒ½ï¼šé¿å…ä¸å¿…è¦çš„å…¨è¡¨æ‰«æï¼Œåˆç†ä½¿ç”¨ç´¢å¼•

## ç‰¹æ®Šå¤„ç†
- æ—¶é—´æŸ¥è¯¢ï¼šä½¿ç”¨æ ‡å‡†æ—¥æœŸå‡½æ•°ï¼Œå¦‚ DATE_TRUNC, NOW(), INTERVAL
- æ¨¡ç³ŠæŸ¥è¯¢ï¼šä½¿ç”¨ILIKEè¿›è¡Œå¤§å°å†™ä¸æ•æ„ŸåŒ¹é…
- èšåˆæŸ¥è¯¢ï¼šåˆç†ä½¿ç”¨GROUP BYå’ŒHAVINGå­å¥
- æ’åºï¼šæ˜ç¡®æŒ‡å®šORDER BYå­å¥

## è¾“å‡ºè¦æ±‚
ç›´æ¥è¿”å›SQLè¯­å¥ï¼Œä¸è¦åŒ…å«ä»»ä½•è§£é‡Šæ–‡å­—ã€‚

## ç”ŸæˆSQL
`
```

### é«˜çº§æç¤ºè¯æ¨¡æ¿

```go
// æ„å›¾æ„ŸçŸ¥çš„æç¤ºè¯æ¨¡æ¿
const IntentAwarePromptTemplate = `
## ç³»ç»Ÿè§’è‰²
ä½ æ˜¯Chat2SQLçš„æ ¸å¿ƒSQLç”Ÿæˆå¼•æ“ï¼Œå…·å¤‡ä»¥ä¸‹èƒ½åŠ›ï¼š
- ç†è§£ä¸­æ–‡è‡ªç„¶è¯­è¨€æŸ¥è¯¢æ„å›¾
- ç”Ÿæˆé«˜æ•ˆçš„PostgreSQLæŸ¥è¯¢è¯­å¥
- ç¡®ä¿æŸ¥è¯¢å®‰å…¨æ€§å’Œæ€§èƒ½ä¼˜åŒ–

## æŸ¥è¯¢æ„å›¾åˆ†æ
æŸ¥è¯¢ç±»å‹ï¼š{{.QueryIntent}}
å¤æ‚åº¦è¯„ä¼°ï¼š{{.ComplexityLevel}}

## æ•°æ®åº“ä¸Šä¸‹æ–‡
### è¡¨ç»“æ„ä¿¡æ¯
{{.DetailedSchema}}

### ä¸šåŠ¡ä¸Šä¸‹æ–‡
{{if .BusinessContext}}
{{.BusinessContext}}
{{end}}

## ç”¨æˆ·æŸ¥è¯¢è§£æ
åŸå§‹æŸ¥è¯¢ï¼š{{.UserQuery}}
å…³é”®å®ä½“ï¼š{{.ExtractedEntities}}
æ—¶é—´èŒƒå›´ï¼š{{.TimeRange}}

## SQLç”Ÿæˆç­–ç•¥
{{if eq .QueryIntent "aggregation"}}
### èšåˆæŸ¥è¯¢ç­–ç•¥
- è¯†åˆ«èšåˆå‡½æ•°ï¼šCOUNTã€SUMã€AVGã€MAXã€MIN
- åˆç†ä½¿ç”¨GROUP BYåˆ†ç»„
- æ·»åŠ é€‚å½“çš„HAVINGæ¡ä»¶
{{else if eq .QueryIntent "join"}}
### å…³è”æŸ¥è¯¢ç­–ç•¥
- åˆ†æè¡¨é—´å…³ç³»
- é€‰æ‹©æœ€ä¼˜çš„JOINç±»å‹
- ç¡®ä¿JOINæ¡ä»¶æ­£ç¡®
{{else if eq .QueryIntent "time_series"}}
### æ—¶é—´åºåˆ—æŸ¥è¯¢ç­–ç•¥
- ä½¿ç”¨åˆé€‚çš„æ—¶é—´å‡½æ•°
- è€ƒè™‘æ—¶åŒºå¤„ç†
- ä¼˜åŒ–æ—¶é—´èŒƒå›´æŸ¥è¯¢
{{end}}

## æ€§èƒ½ä¼˜åŒ–å»ºè®®
- åˆ©ç”¨ç°æœ‰ç´¢å¼•ï¼š{{.AvailableIndexes}}
- é¿å…å…¨è¡¨æ‰«æ
- åˆç†é™åˆ¶è¿”å›è®°å½•æ•°

## å®‰å…¨æ£€æŸ¥æ¸…å•
- âœ“ åªåŒ…å«SELECTæ“ä½œ
- âœ“ å­—æ®µåä¸schemaåŒ¹é…
- âœ“ é˜²æ­¢SQLæ³¨å…¥
- âœ“ åˆç†çš„WHEREæ¡ä»¶

## SQLè¾“å‡º
`
```

## ğŸ“š æç¤ºè¯æ¨¡æ¿åº“

### 1. åŸºç¡€æŸ¥è¯¢æ¨¡æ¿

```go
// ç®€å•æŸ¥è¯¢æ¨¡æ¿
const SimpleQueryTemplate = `
åŸºäºä»¥ä¸‹è¡¨ç»“æ„ï¼Œå°†ç”¨æˆ·æŸ¥è¯¢è½¬æ¢ä¸ºSQLï¼š

è¡¨ç»“æ„ï¼š{{.Schema}}
ç”¨æˆ·æŸ¥è¯¢ï¼š{{.Query}}

è¦æ±‚ï¼š
1. ç”ŸæˆSELECTæŸ¥è¯¢
2. å­—æ®µåç²¾ç¡®åŒ¹é…
3. è¿”å›çº¯SQLè¯­å¥

SQLï¼š
`

// æ¡ä»¶æŸ¥è¯¢æ¨¡æ¿
const ConditionalQueryTemplate = `
æ ¹æ®ç”¨æˆ·éœ€æ±‚ç”Ÿæˆå¸¦æ¡ä»¶çš„SQLæŸ¥è¯¢ï¼š

æ•°æ®åº“ä¿¡æ¯ï¼š{{.Schema}}
æŸ¥è¯¢éœ€æ±‚ï¼š{{.Query}}
ç­›é€‰æ¡ä»¶ï¼š{{.Conditions}}

ç”Ÿæˆè§„åˆ™ï¼š
- ä½¿ç”¨WHEREå­å¥æ·»åŠ ç­›é€‰æ¡ä»¶
- å­—ç¬¦ä¸²åŒ¹é…ä½¿ç”¨ILIKE
- æ•°å€¼æ¯”è¾ƒä½¿ç”¨ç²¾ç¡®æ“ä½œç¬¦
- æ—¶é—´æŸ¥è¯¢ä½¿ç”¨DATEå‡½æ•°

SQLè¯­å¥ï¼š
`
```

### 2. èšåˆæŸ¥è¯¢æ¨¡æ¿

```go
const AggregationTemplate = `
ä¸ºä»¥ä¸‹èšåˆåˆ†æéœ€æ±‚ç”ŸæˆSQLï¼š

## æ•°æ®æº
{{.Schema}}

## åˆ†æéœ€æ±‚
{{.Query}}

## èšåˆç­–ç•¥
- è¯†åˆ«åº¦é‡å­—æ®µï¼š{{.Metrics}}
- åˆ†ç»„ç»´åº¦ï¼š{{.Dimensions}}
- è¿‡æ»¤æ¡ä»¶ï¼š{{.Filters}}

## PostgreSQLèšåˆè¯­æ³•è¦æ±‚
1. SELECTå­å¥åŒ…å«åˆ†ç»„å­—æ®µå’Œèšåˆå‡½æ•°
2. GROUP BYåŒ…å«æ‰€æœ‰éèšåˆå­—æ®µ
3. ä½¿ç”¨HAVINGè¿›è¡Œèšåˆç»“æœç­›é€‰
4. ORDER BYæä¾›åˆç†æ’åº

ç”ŸæˆSQLï¼š
`
```

### 3. å…³è”æŸ¥è¯¢æ¨¡æ¿

```go
const JoinQueryTemplate = `
ç”Ÿæˆå¤šè¡¨å…³è”æŸ¥è¯¢SQLï¼š

## ç›¸å…³è¡¨ç»“æ„
{{range .Tables}}
### {{.TableName}}
{{.Schema}}
{{end}}

## è¡¨å…³ç³»è¯´æ˜
{{.Relationships}}

## æŸ¥è¯¢éœ€æ±‚
{{.Query}}

## JOINç­–ç•¥é€‰æ‹©
- INNER JOINï¼šè·å–åŒ¹é…è®°å½•
- LEFT JOINï¼šä¿ç•™ä¸»è¡¨æ‰€æœ‰è®°å½•
- RIGHT JOINï¼šä¿ç•™ä»è¡¨æ‰€æœ‰è®°å½•
- FULL OUTER JOINï¼šä¿ç•™æ‰€æœ‰è®°å½•

## æ€§èƒ½è€ƒè™‘
- ä¼˜å…ˆä½¿ç”¨æœ‰ç´¢å¼•çš„å­—æ®µä½œä¸ºJOINæ¡ä»¶
- åˆç†å®‰æ’JOINé¡ºåº
- åœ¨WHEREå­å¥ä¸­æ·»åŠ ç­›é€‰æ¡ä»¶

ç”ŸæˆSQLï¼š
`
```

### 4. æ—¶é—´åºåˆ—æ¨¡æ¿

```go
const TimeSeriesTemplate = `
ç”Ÿæˆæ—¶é—´åºåˆ—åˆ†æSQLï¼š

è¡¨ç»“æ„ï¼š{{.Schema}}
æ—¶é—´å­—æ®µï¼š{{.TimeColumn}}
æŸ¥è¯¢éœ€æ±‚ï¼š{{.Query}}
æ—¶é—´èŒƒå›´ï¼š{{.TimeRange}}

## PostgreSQLæ—¶é—´å‡½æ•°
- DATE_TRUNC('day', timestamp): æŒ‰å¤©åˆ†ç»„
- EXTRACT(YEAR FROM date): æå–å¹´ä»½
- NOW() - INTERVAL '7 days': æœ€è¿‘7å¤©
- AGE(timestamp1, timestamp2): è®¡ç®—æ—¶é—´å·®

## æ—¶é—´æŸ¥è¯¢æœ€ä½³å®è·µ
1. ä½¿ç”¨æ—¶é—´ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
2. æ˜ç¡®æŒ‡å®šæ—¶åŒºå¤„ç†
3. åˆç†è®¾ç½®æ—¶é—´èŒƒå›´é¿å…å…¨è¡¨æ‰«æ
4. ä½¿ç”¨DATE_TRUNCè¿›è¡Œæ—¶é—´åˆ†ç»„

SQLæŸ¥è¯¢ï¼š
`
```

## ğŸ”§ æç¤ºè¯ä¼˜åŒ–ç­–ç•¥

### 1. æ¸è¿›å¼ä¼˜åŒ–æ–¹æ³•

```go
// æç¤ºè¯ç‰ˆæœ¬ç®¡ç†
type PromptVersion struct {
    Version     string                 `json:"version"`
    Template    string                 `json:"template"`
    Performance PromptPerformance      `json:"performance"`
    TestCases   []PromptTestCase       `json:"test_cases"`
    CreatedAt   time.Time             `json:"created_at"`
}

type PromptPerformance struct {
    AccuracyRate    float64 `json:"accuracy_rate"`
    AvgResponseTime float64 `json:"avg_response_time"`
    TokenUsage      int     `json:"token_usage"`
    SuccessRate     float64 `json:"success_rate"`
}

// æç¤ºè¯A/Bæµ‹è¯•æ¡†æ¶
type PromptABTest struct {
    TestID      string    `json:"test_id"`
    VersionA    string    `json:"version_a"`
    VersionB    string    `json:"version_b"`
    SampleSize  int       `json:"sample_size"`
    StartTime   time.Time `json:"start_time"`
    Results     ABTestResults `json:"results"`
}
```

### 2. ä¸Šä¸‹æ–‡å¢å¼ºç­–ç•¥

```go
// åŠ¨æ€ä¸Šä¸‹æ–‡æ„å»º
func (pe *PromptEngine) BuildEnhancedContext(
    userQuery string, 
    connectionID int64) (*EnhancedContext, error) {
    
    context := &EnhancedContext{
        UserQuery: userQuery,
    }
    
    // 1. è·å–æ•°æ®åº“Schema
    schema, err := pe.schemaService.GetDetailedSchema(connectionID)
    if err != nil {
        return nil, err
    }
    context.DatabaseSchema = schema
    
    // 2. åˆ†ææŸ¥è¯¢æ„å›¾
    intent := pe.intentAnalyzer.Analyze(userQuery)
    context.QueryIntent = intent
    
    // 3. æå–å…³é”®å®ä½“
    entities := pe.entityExtractor.Extract(userQuery)
    context.ExtractedEntities = entities
    
    // 4. è·å–ç›¸å…³å†å²æŸ¥è¯¢
    history := pe.historyService.GetSimilarQueries(userQuery, 3)
    context.QueryHistory = history
    
    // 5. æ·»åŠ ä¸šåŠ¡ä¸Šä¸‹æ–‡
    if businessContext := pe.getBusinessContext(connectionID); businessContext != nil {
        context.BusinessContext = businessContext
    }
    
    return context, nil
}
```

### 3. å¤±è´¥æ¡ˆä¾‹å­¦ä¹ 

```go
// å¤±è´¥æ¡ˆä¾‹åˆ†æå’Œå­¦ä¹ 
type FailureAnalyzer struct {
    failureStore map[string]*FailureCase
    patterns     []FailurePattern
}

type FailureCase struct {
    UserQuery    string    `json:"user_query"`
    GeneratedSQL string    `json:"generated_sql"`
    ErrorType    string    `json:"error_type"`
    ErrorMessage string    `json:"error_message"`
    CorrectSQL   string    `json:"correct_sql"`
    Timestamp    time.Time `json:"timestamp"`
}

func (fa *FailureAnalyzer) LearnFromFailure(failure *FailureCase) {
    // 1. è¯†åˆ«å¤±è´¥æ¨¡å¼
    pattern := fa.identifyFailurePattern(failure)
    
    // 2. æ›´æ–°æç¤ºè¯æ¨¡æ¿
    if pattern.Frequency > 5 {
        fa.suggestPromptImprovement(pattern)
    }
    
    // 3. æ·»åŠ åˆ°è´Ÿé¢æ ·æœ¬åº“
    fa.addNegativeExample(failure)
}
```

## ğŸ“Š æç¤ºè¯è¯„ä¼°æŒ‡æ ‡

### 1. å‡†ç¡®ç‡è¯„ä¼°

```go
// å‡†ç¡®ç‡è¯„ä¼°æ¡†æ¶
type AccuracyEvaluator struct {
    testSuite    []TestCase
    sqlValidator *SQLValidator
    dbExecutor   *DatabaseExecutor
}

type TestCase struct {
    UserQuery      string `json:"user_query"`
    ExpectedSQL    string `json:"expected_sql"`
    ExpectedResult []map[string]interface{} `json:"expected_result"`
    Category       string `json:"category"`
    Difficulty     int    `json:"difficulty"`
}

func (ae *AccuracyEvaluator) EvaluatePrompt(
    promptTemplate string) (*EvaluationResult, error) {
    
    var correct, total int
    results := make([]TestResult, 0, len(ae.testSuite))
    
    for _, testCase := range ae.testSuite {
        // ç”ŸæˆSQL
        generatedSQL, err := ae.generateSQL(promptTemplate, testCase.UserQuery)
        if err != nil {
            results = append(results, TestResult{
                TestCase: testCase,
                Error:    err,
                Passed:   false,
            })
            total++
            continue
        }
        
        // éªŒè¯SQLè¯­æ³•
        if err := ae.sqlValidator.Validate(generatedSQL); err != nil {
            results = append(results, TestResult{
                TestCase:    testCase,
                GeneratedSQL: generatedSQL,
                Error:       err,
                Passed:      false,
            })
            total++
            continue
        }
        
        // æ‰§è¡Œå¹¶æ¯”è¾ƒç»“æœ
        passed := ae.compareResults(generatedSQL, testCase.ExpectedResult)
        if passed {
            correct++
        }
        total++
        
        results = append(results, TestResult{
            TestCase:     testCase,
            GeneratedSQL: generatedSQL,
            Passed:       passed,
        })
    }
    
    return &EvaluationResult{
        AccuracyRate: float64(correct) / float64(total),
        TotalTests:   total,
        PassedTests:  correct,
        Results:      results,
    }, nil
}
```

### 2. æ€§èƒ½è¯„ä¼°

```go
// æ€§èƒ½è¯„ä¼°æŒ‡æ ‡
type PerformanceMetrics struct {
    AvgTokenUsage     float64 `json:"avg_token_usage"`
    AvgResponseTime   float64 `json:"avg_response_time"`
    P95ResponseTime   float64 `json:"p95_response_time"`
    SuccessRate       float64 `json:"success_rate"`
    CostPerQuery      float64 `json:"cost_per_query"`
}

func (pe *PerformanceEvaluator) EvaluatePerformance(
    promptTemplate string, 
    testQueries []string) (*PerformanceMetrics, error) {
    
    var totalTokens, totalTime int64
    var costs []float64
    var responseTimes []time.Duration
    var successes int
    
    for _, query := range testQueries {
        start := time.Now()
        
        response, err := pe.generateWithMetrics(promptTemplate, query)
        duration := time.Since(start)
        
        if err == nil {
            successes++
            totalTokens += int64(response.TokensUsed)
            costs = append(costs, response.Cost)
        }
        
        totalTime += duration.Milliseconds()
        responseTimes = append(responseTimes, duration)
    }
    
    return &PerformanceMetrics{
        AvgTokenUsage:   float64(totalTokens) / float64(len(testQueries)),
        AvgResponseTime: float64(totalTime) / float64(len(testQueries)),
        P95ResponseTime: calculateP95(responseTimes),
        SuccessRate:     float64(successes) / float64(len(testQueries)),
        CostPerQuery:    calculateAverage(costs),
    }, nil
}
```

## ğŸ›ï¸ åŠ¨æ€æç¤ºè¯ç”Ÿæˆ

### 1. è‡ªé€‚åº”æç¤ºè¯å¼•æ“

```go
// è‡ªé€‚åº”æç¤ºè¯å¼•æ“
type AdaptivePromptEngine struct {
    baseTemplates    map[string]string
    userPreferences  map[int64]*UserPreference
    contextAnalyzer  *ContextAnalyzer
    performanceTracker *PerformanceTracker
}

func (ape *AdaptivePromptEngine) GenerateOptimalPrompt(
    userID int64, 
    query string, 
    context *QueryContext) (string, error) {
    
    // 1. åˆ†ææŸ¥è¯¢å¤æ‚åº¦
    complexity := ape.contextAnalyzer.AnalyzeComplexity(query)
    
    // 2. è·å–ç”¨æˆ·åå¥½
    preference := ape.userPreferences[userID]
    
    // 3. é€‰æ‹©åŸºç¡€æ¨¡æ¿
    baseTemplate := ape.selectBaseTemplate(complexity, preference)
    
    // 4. åŠ¨æ€è°ƒæ•´æ¨¡æ¿
    adjustedTemplate := ape.adjustTemplate(baseTemplate, context)
    
    // 5. æ·»åŠ ä¸ªæ€§åŒ–å…ƒç´ 
    finalTemplate := ape.personalize(adjustedTemplate, preference)
    
    return finalTemplate, nil
}

func (ape *AdaptivePromptEngine) adjustTemplate(
    template string, 
    context *QueryContext) string {
    
    // æ ¹æ®ä¸Šä¸‹æ–‡åŠ¨æ€è°ƒæ•´
    switch context.QueryIntent {
    case "aggregation":
        return ape.enhanceForAggregation(template, context)
    case "join":
        return ape.enhanceForJoin(template, context)
    case "time_series":
        return ape.enhanceForTimeSeries(template, context)
    default:
        return template
    }
}
```

### 2. å®æ—¶åé¦ˆä¼˜åŒ–

```go
// å®æ—¶åé¦ˆå­¦ä¹ ç³»ç»Ÿ
type FeedbackLearningSystem struct {
    feedbackStore   *FeedbackStore
    promptOptimizer *PromptOptimizer
    updateTrigger   chan *FeedbackEvent
}

type FeedbackEvent struct {
    UserID       int64     `json:"user_id"`
    QueryID      string    `json:"query_id"`
    UserQuery    string    `json:"user_query"`
    GeneratedSQL string    `json:"generated_sql"`
    UserRating   int       `json:"user_rating"`
    Feedback     string    `json:"feedback"`
    IsCorrect    bool      `json:"is_correct"`
    Timestamp    time.Time `json:"timestamp"`
}

func (fls *FeedbackLearningSystem) ProcessFeedback(event *FeedbackEvent) {
    // 1. å­˜å‚¨åé¦ˆ
    fls.feedbackStore.Store(event)
    
    // 2. åˆ†æåé¦ˆæ¨¡å¼
    pattern := fls.analyzeFeedbackPattern(event)
    
    // 3. è§¦å‘æç¤ºè¯ä¼˜åŒ–
    if pattern.ShouldOptimize() {
        fls.updateTrigger <- event
    }
}

func (fls *FeedbackLearningSystem) StartLearningLoop() {
    go func() {
        for event := range fls.updateTrigger {
            // å¼‚æ­¥ä¼˜åŒ–æç¤ºè¯
            optimizedPrompt := fls.promptOptimizer.OptimizeBasedOnFeedback(event)
            
            // A/Bæµ‹è¯•æ–°æç¤ºè¯
            fls.startABTest(optimizedPrompt)
        }
    }()
}
```

## ğŸ“‹ æµ‹è¯•ç”¨ä¾‹åº“

### 1. åŸºç¡€æŸ¥è¯¢æµ‹è¯•

```yaml
# test_cases/basic_queries.yaml
basic_queries:
  - name: "ç®€å•è¡¨æŸ¥è¯¢"
    user_query: "æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·ä¿¡æ¯"
    expected_sql: "SELECT * FROM users"
    category: "basic"
    difficulty: 1
    
  - name: "å­—æ®µé€‰æ‹©"
    user_query: "æ˜¾ç¤ºç”¨æˆ·å§“åå’Œé‚®ç®±"
    expected_sql: "SELECT name, email FROM users"
    category: "basic"
    difficulty: 1
    
  - name: "æ¡ä»¶æŸ¥è¯¢"
    user_query: "æŸ¥æ‰¾å¹´é¾„å¤§äº25å²çš„ç”¨æˆ·"
    expected_sql: "SELECT * FROM users WHERE age > 25"
    category: "basic"
    difficulty: 2
```

### 2. å¤æ‚æŸ¥è¯¢æµ‹è¯•

```yaml
# test_cases/complex_queries.yaml
complex_queries:
  - name: "èšåˆç»Ÿè®¡"
    user_query: "ç»Ÿè®¡å„éƒ¨é—¨çš„å‘˜å·¥æ•°é‡"
    expected_sql: "SELECT department, COUNT(*) as employee_count FROM employees GROUP BY department"
    category: "aggregation"
    difficulty: 3
    
  - name: "å¤šè¡¨å…³è”"
    user_query: "æŸ¥è¯¢ç”¨æˆ·åŠå…¶è®¢å•ä¿¡æ¯"
    expected_sql: "SELECT u.name, o.order_date, o.total_amount FROM users u LEFT JOIN orders o ON u.id = o.user_id"
    category: "join"
    difficulty: 4
    
  - name: "æ—¶é—´åºåˆ—åˆ†æ"
    user_query: "æŸ¥çœ‹æœ€è¿‘30å¤©çš„é”€å”®è¶‹åŠ¿"
    expected_sql: "SELECT DATE_TRUNC('day', created_at) as date, SUM(amount) as daily_sales FROM sales WHERE created_at >= NOW() - INTERVAL '30 days' GROUP BY DATE_TRUNC('day', created_at) ORDER BY date"
    category: "time_series"
    difficulty: 5
```

## ğŸš¨ å®‰å…¨æ£€æŸ¥æ¸…å•

### æç¤ºè¯å®‰å…¨å®¡æ ¸

```go
// æç¤ºè¯å®‰å…¨å®¡æ ¸å™¨
type PromptSecurityAuditor struct {
    blacklistPatterns []string
    whitelistOps      []string
    sqlValidator      *SecurityValidator
}

func (psa *PromptSecurityAuditor) AuditPrompt(template string) (*SecurityAuditResult, error) {
    result := &SecurityAuditResult{
        IsSecure: true,
        Issues:   make([]SecurityIssue, 0),
    }
    
    // 1. æ£€æŸ¥æ˜¯å¦åŒ…å«å±é™©æŒ‡ä»¤
    for _, pattern := range psa.blacklistPatterns {
        if strings.Contains(strings.ToLower(template), pattern) {
            result.Issues = append(result.Issues, SecurityIssue{
                Type:        "DANGEROUS_INSTRUCTION",
                Description: fmt.Sprintf("åŒ…å«å±é™©æ¨¡å¼: %s", pattern),
                Severity:    "HIGH",
            })
            result.IsSecure = false
        }
    }
    
    // 2. éªŒè¯å…è®¸çš„æ“ä½œ
    if !psa.validateAllowedOperations(template) {
        result.Issues = append(result.Issues, SecurityIssue{
            Type:        "UNAUTHORIZED_OPERATION",
            Description: "åŒ…å«ä¸å…è®¸çš„SQLæ“ä½œ",
            Severity:    "HIGH",
        })
        result.IsSecure = false
    }
    
    return result, nil
}

var securityBlacklist = []string{
    "delete", "update", "insert", "drop", "create", "alter",
    "truncate", "grant", "revoke", "exec", "execute",
    "xp_", "sp_", "master", "sys", "information_schema",
}
```

## ğŸ“ˆ æŒç»­ä¼˜åŒ–æµç¨‹

### 1. æ¯æ—¥ä¼˜åŒ–å¾ªç¯

```mermaid
graph LR
    A[æ”¶é›†ç”¨æˆ·åé¦ˆ] --> B[åˆ†æå¤±è´¥æ¡ˆä¾‹]
    B --> C[è¯†åˆ«æ”¹è¿›æ¨¡å¼]
    C --> D[æ›´æ–°æç¤ºè¯æ¨¡æ¿]
    D --> E[A/Bæµ‹è¯•éªŒè¯]
    E --> F[æ€§èƒ½è¯„ä¼°]
    F --> G[éƒ¨ç½²ä¼˜åŒ–ç‰ˆæœ¬]
    G --> A
```

### 2. ç‰ˆæœ¬è¿­ä»£ç­–ç•¥

```go
// æç¤ºè¯ç‰ˆæœ¬è¿­ä»£ç®¡ç†
type PromptVersionManager struct {
    versions      map[string]*PromptVersion
    currentActive string
    rollbackStack []string
    abTestManager *ABTestManager
}

func (pvm *PromptVersionManager) DeployNewVersion(
    version *PromptVersion) error {
    
    // 1. å®‰å…¨å®¡æ ¸
    auditResult, err := pvm.securityAuditor.Audit(version)
    if err != nil || !auditResult.IsSecure {
        return fmt.Errorf("å®‰å…¨å®¡æ ¸å¤±è´¥: %v", auditResult.Issues)
    }
    
    // 2. æ€§èƒ½é¢„è¯„ä¼°
    perfResult, err := pvm.performanceEvaluator.Evaluate(version)
    if err != nil || perfResult.AccuracyRate < 0.7 {
        return fmt.Errorf("æ€§èƒ½è¯„ä¼°ä¸è¾¾æ ‡: å‡†ç¡®ç‡ %.2f", perfResult.AccuracyRate)
    }
    
    // 3. ç°åº¦å‘å¸ƒ
    err = pvm.abTestManager.StartGradualRollout(version, 0.1) // 10%æµé‡
    if err != nil {
        return err
    }
    
    // 4. ç›‘æ§å’Œè‡ªåŠ¨å›æ»š
    go pvm.monitorAndAutoRollback(version)
    
    return nil
}
```

## ğŸ† æœ€ä½³å®è·µæ€»ç»“

### âœ… æˆåŠŸè¦ç´ 

1. **ç»“æ„åŒ–è®¾è®¡**ï¼šæ¸…æ™°çš„æç¤ºè¯ç»“æ„å’Œå±‚æ¬¡
2. **ä¸Šä¸‹æ–‡ä¸°å¯Œ**ï¼šå……åˆ†åˆ©ç”¨æ•°æ®åº“Schemaå’Œå†å²æŸ¥è¯¢
3. **å®‰å…¨ä¼˜å…ˆ**ï¼šä¸¥æ ¼çš„å®‰å…¨è§„åˆ™å’ŒéªŒè¯æœºåˆ¶
4. **æŒç»­ä¼˜åŒ–**ï¼šåŸºäºåé¦ˆçš„æŒç»­æ”¹è¿›å¾ªç¯

### âš ï¸ å¸¸è§é™·é˜±

1. **è¿‡åº¦å¤æ‚**ï¼šæç¤ºè¯è¿‡é•¿å¯¼è‡´æ¨¡å‹ç†è§£å›°éš¾
2. **è§„åˆ™å†²çª**ï¼šç›¸äº’çŸ›ç›¾çš„ç”Ÿæˆè§„åˆ™
3. **ä¸Šä¸‹æ–‡ä¸è¶³**ï¼šç¼ºä¹å¿…è¦çš„ä¸šåŠ¡ä¸Šä¸‹æ–‡ä¿¡æ¯
4. **æµ‹è¯•ä¸å……åˆ†**ï¼šè¾¹ç•Œæƒ…å†µè¦†ç›–ä¸è¶³

### ğŸ¯ ä¼˜åŒ–ç›®æ ‡

- **å‡†ç¡®ç‡**: > 70% (ç›®æ ‡: 85%+)
- **å“åº”æ—¶é—´**: < 3s (ç›®æ ‡: < 1s)
- **Tokenæ•ˆç‡**: < 2000 tokens/query
- **å®‰å…¨æ€§**: 100% é˜»æ­¢å±é™©æ“ä½œ

---

<div align="center">

**ğŸ¯ ä¼˜ç§€çš„æç¤ºè¯æ˜¯Chat2SQLæˆåŠŸçš„å…³é”®ï¼šç²¾ç¡®+å®‰å…¨+é«˜æ•ˆ**

</div>