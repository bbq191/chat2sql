# ğŸ§  å¤šæ¨¡å‹æ™ºèƒ½è·¯ç”±å®ç°æŒ‡å—

<div align="center">

![Routing](https://img.shields.io/badge/Routing-Multi_Model-blue.svg)
![Intelligence](https://img.shields.io/badge/Intelligence-AI_Router-green.svg)
![Performance](https://img.shields.io/badge/Performance->95%25-orange.svg)

**Chat2SQL P2é˜¶æ®µ - æ™ºèƒ½è·¯ç”±å¼•æ“å®Œæ•´å®ç°æ–¹æ¡ˆ**

</div>

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸“é—¨é’ˆå¯¹Chat2SQLç³»ç»Ÿçš„å¤šæ¨¡å‹æ™ºèƒ½è·¯ç”±å®ç°ï¼Œæä¾›ä»æ¶æ„è®¾è®¡åˆ°ä»£ç å®ç°çš„å®Œæ•´æŠ€æœ¯æ–¹æ¡ˆï¼Œå®ç°åŸºäºæŸ¥è¯¢å¤æ‚åº¦å’Œæˆæœ¬æ•ˆç›Šçš„æ™ºèƒ½æ¨¡å‹é€‰æ‹©ã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### æ™ºèƒ½è·¯ç”±èƒ½åŠ›
- âœ… **å¤šæ¨¡å‹ç®¡ç†**ï¼šæ”¯æŒOpenAIã€Claudeã€DeepSeekã€Ollamaç­‰å¤šç§æ¨¡å‹
- âœ… **å¤æ‚åº¦åˆ†æ**ï¼šåŸºäºæŸ¥è¯¢ç‰¹å¾è‡ªåŠ¨åˆ†æå¤æ‚åº¦å¹¶åˆ†ç±»
- âœ… **æ™ºèƒ½é€‰æ‹©**ï¼šå¤šç›®æ ‡ä¼˜åŒ–çš„æ¨¡å‹é€‰æ‹©ç®—æ³•
- âœ… **è´Ÿè½½å‡è¡¡**ï¼šåŠ¨æ€è´Ÿè½½åˆ†é…å’ŒQPSé™åˆ¶

### æ€§èƒ½æŒ‡æ ‡
| è·¯ç”±ç±»å‹ | å“åº”æ—¶é—´ | å‡†ç¡®ç‡ | æˆæœ¬èŠ‚çœ |
|---------|---------|--------|----------|
| **ç®€å•æŸ¥è¯¢è·¯ç”±** | < 50ms | > 98% | 85%+ |
| **ä¸­ç­‰æŸ¥è¯¢è·¯ç”±** | < 100ms | > 95% | 60%+ |
| **å¤æ‚æŸ¥è¯¢è·¯ç”±** | < 200ms | > 92% | 30%+ |

---

## ğŸ—ï¸ è·¯ç”±å¼•æ“æ¶æ„

### ğŸ“¦ æ ¸å¿ƒç»„ä»¶è®¾è®¡

```go
// internal/routing/router.go
package routing

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/langchaingo/langchaingo/llms"
)

type MultiModelRouter struct {
    // æ ¸å¿ƒç»„ä»¶
    modelRegistry   *ModelRegistry      // æ¨¡å‹æ³¨å†Œä¸­å¿ƒ
    complexityAnalyzer *ComplexityAnalyzer // å¤æ‚åº¦åˆ†æå™¨
    routingEngine   *RoutingEngine      // è·¯ç”±å†³ç­–å¼•æ“
    loadBalancer    *LoadBalancer       // è´Ÿè½½å‡è¡¡å™¨
    
    // é…ç½®å’Œç­–ç•¥
    config          *RouterConfig       // è·¯ç”±é…ç½®
    strategy        *RoutingStrategy    // è·¯ç”±ç­–ç•¥
    
    // ç›‘æ§å’Œç¼“å­˜
    metrics         *RouterMetrics      // è·¯ç”±æŒ‡æ ‡
    healthChecker   *HealthChecker      // å¥åº·æ£€æŸ¥
    
    // å¹¶å‘æ§åˆ¶
    mu              sync.RWMutex
    stopCh          chan struct{}
}

type RouterConfig struct {
    // æ¨¡å‹é…ç½®
    Models          []ModelConfig `yaml:"models"`
    
    // è·¯ç”±ç­–ç•¥é…ç½®
    ComplexityThresholds struct {
        Simple  float64 `yaml:"simple"`   // 0.3
        Medium  float64 `yaml:"medium"`   // 0.7
        Complex float64 `yaml:"complex"`  // 1.0
    } `yaml:"complexity_thresholds"`
    
    // æƒé‡é…ç½®
    Weights struct {
        Cost        float64 `yaml:"cost"`        // 0.4
        Performance float64 `yaml:"performance"` // 0.4
        Accuracy    float64 `yaml:"accuracy"`    // 0.2
    } `yaml:"weights"`
    
    // é™çº§ç­–ç•¥
    Fallback struct {
        Enabled     bool   `yaml:"enabled"`      // true
        MaxRetries  int    `yaml:"max_retries"`  // 3
        DefaultModel string `yaml:"default_model"` // "gpt-4o-mini"
    } `yaml:"fallback"`
}

type ModelConfig struct {
    Name            string        `yaml:"name"`             // "gpt-4o-mini"
    Provider        string        `yaml:"provider"`         // "openai"
    Category        string        `yaml:"category"`         // "simple|medium|complex"
    Endpoint        string        `yaml:"endpoint"`
    ApiKey          string        `yaml:"api_key"`
    
    // æ€§èƒ½å‚æ•°
    CostPer1K       float64       `yaml:"cost_per_1k"`      // $0.15
    MaxTokens       int           `yaml:"max_tokens"`       // 4096
    Timeout         time.Duration `yaml:"timeout"`          // 30s
    QPS             int           `yaml:"qps"`              // 100
    
    // è´¨é‡å‚æ•°
    Accuracy        float64       `yaml:"accuracy"`         // 0.85
    AvgLatency      time.Duration `yaml:"avg_latency"`      // 2s
    Reliability     float64       `yaml:"reliability"`      // 0.99
    
    // çŠ¶æ€ç®¡ç†
    Enabled         bool          `yaml:"enabled"`          // true
    Priority        int           `yaml:"priority"`         // 1-10
}
```

### ğŸ”§ è·¯ç”±å¼•æ“åˆå§‹åŒ–

```go
func NewMultiModelRouter(config *RouterConfig) (*MultiModelRouter, error) {
    router := &MultiModelRouter{
        config:             config,
        modelRegistry:      NewModelRegistry(),
        complexityAnalyzer: NewComplexityAnalyzer(),
        routingEngine:      NewRoutingEngine(),
        loadBalancer:       NewLoadBalancer(),
        metrics:           NewRouterMetrics(),
        healthChecker:     NewHealthChecker(),
        stopCh:            make(chan struct{}),
    }
    
    // æ³¨å†Œæ‰€æœ‰æ¨¡å‹
    if err := router.registerModels(); err != nil {
        return nil, fmt.Errorf("æ¨¡å‹æ³¨å†Œå¤±è´¥: %w", err)
    }
    
    // å¯åŠ¨å¥åº·æ£€æŸ¥
    go router.startHealthCheck()
    
    // å¯åŠ¨æŒ‡æ ‡æ”¶é›†
    go router.startMetricsCollection()
    
    return router, nil
}

func (r *MultiModelRouter) registerModels() error {
    for _, modelConfig := range r.config.Models {
        // åˆ›å»ºæ¨¡å‹å®ä¾‹
        model, err := r.createModelInstance(modelConfig)
        if err != nil {
            log.Warn("æ¨¡å‹åˆ›å»ºå¤±è´¥", zap.String("model", modelConfig.Name), zap.Error(err))
            continue
        }
        
        // æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒ
        if err := r.modelRegistry.Register(modelConfig.Name, model, modelConfig); err != nil {
            return fmt.Errorf("æ¨¡å‹æ³¨å†Œå¤±è´¥ %s: %w", modelConfig.Name, err)
        }
        
        log.Info("æ¨¡å‹æ³¨å†ŒæˆåŠŸ", 
            zap.String("name", modelConfig.Name),
            zap.String("category", modelConfig.Category),
            zap.Float64("cost", modelConfig.CostPer1K))
    }
    
    return nil
}

func (r *MultiModelRouter) createModelInstance(config ModelConfig) (llms.Model, error) {
    switch config.Provider {
    case "openai":
        return openai.New(
            openai.WithToken(config.ApiKey),
            openai.WithBaseURL(config.Endpoint),
            openai.WithModel(config.Name),
        )
    case "anthropic":
        return anthropic.New(
            anthropic.WithToken(config.ApiKey),
            anthropic.WithModel(config.Name),
        )
    case "deepseek":
        return openai.New( // DeepSeekä½¿ç”¨OpenAIå…¼å®¹æ¥å£
            openai.WithToken(config.ApiKey),
            openai.WithBaseURL(config.Endpoint),
            openai.WithModel(config.Name),
        )
    case "ollama":
        return ollama.New(
            ollama.WithServerURL(config.Endpoint),
            ollama.WithModel(config.Name),
        )
    default:
        return nil, fmt.Errorf("ä¸æ”¯æŒçš„æä¾›å•†: %s", config.Provider)
    }
}
```

---

## ğŸ” æŸ¥è¯¢å¤æ‚åº¦åˆ†æå¼•æ“

### å¤æ‚åº¦è¯„ä¼°ç®—æ³•

```go
// internal/routing/complexity.go
package routing

import (
    "context"
    "regexp"
    "strings"
    "unicode"
)

type ComplexityAnalyzer struct {
    // å…³é”®è¯åº“
    simpleKeywords   map[string]int
    complexKeywords  map[string]int
    
    // æ­£åˆ™è¡¨è¾¾å¼
    sqlPatterns      []*regexp.Regexp
    aggregatePattern *regexp.Regexp
    joinPattern      *regexp.Regexp
    
    // å­¦ä¹ æ¨¡å‹
    mlModel         *ComplexityMLModel
    
    // ç¼“å­˜
    analysisCache   *ComplexityCache
}

type ComplexityResult struct {
    Score          float64             `json:"score"`           // 0.0-1.0
    Category       ComplexityCategory  `json:"category"`        // Simple/Medium/Complex
    Features       *ComplexityFeatures `json:"features"`
    Confidence     float64             `json:"confidence"`      // 0.0-1.0
    Explanation    []string            `json:"explanation"`
    ProcessingTime time.Duration       `json:"processing_time"`
}

type ComplexityCategory string

const (
    CategorySimple  ComplexityCategory = "simple"
    CategoryMedium  ComplexityCategory = "medium"
    CategoryComplex ComplexityCategory = "complex"
)

type ComplexityFeatures struct {
    // æ–‡æœ¬ç‰¹å¾
    WordCount         int     `json:"word_count"`
    SentenceCount     int     `json:"sentence_count"`
    AvgWordLength     float64 `json:"avg_word_length"`
    
    // æŸ¥è¯¢ç‰¹å¾
    HasAggregation    bool    `json:"has_aggregation"`
    HasJoins          bool    `json:"has_joins"`
    HasSubqueries     bool    `json:"has_subqueries"`
    HasComplexLogic   bool    `json:"has_complex_logic"`
    
    // å…³é”®è¯ç‰¹å¾
    SimpleKeywordScore   float64 `json:"simple_keyword_score"`
    ComplexKeywordScore  float64 `json:"complex_keyword_score"`
    
    // ç»“æ„ç‰¹å¾
    NestedLevel       int     `json:"nested_level"`
    TableCount        int     `json:"table_count"`
    ConditionCount    int     `json:"condition_count"`
}

func NewComplexityAnalyzer() *ComplexityAnalyzer {
    analyzer := &ComplexityAnalyzer{
        simpleKeywords:  buildSimpleKeywords(),
        complexKeywords: buildComplexKeywords(),
        sqlPatterns:     buildSQLPatterns(),
        analysisCache:   NewComplexityCache(),
    }
    
    // ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
    analyzer.aggregatePattern = regexp.MustCompile(`(?i)\b(sum|avg|count|max|min|group\s+by|having)\b`)
    analyzer.joinPattern = regexp.MustCompile(`(?i)\b(join|inner\s+join|left\s+join|right\s+join|full\s+join)\b`)
    
    return analyzer
}

func (ca *ComplexityAnalyzer) AnalyzeComplexity(
    ctx context.Context, 
    query string) (*ComplexityResult, error) {
    
    start := time.Now()
    
    // æ£€æŸ¥ç¼“å­˜
    if cached := ca.analysisCache.Get(query); cached != nil {
        return cached, nil
    }
    
    // æå–ç‰¹å¾
    features := ca.extractFeatures(query)
    
    // è®¡ç®—å¤æ‚åº¦åˆ†æ•°
    score := ca.calculateComplexityScore(features)
    
    // åˆ†ç±»
    category := ca.categorizeComplexity(score)
    
    // è®¡ç®—ä¿¡å¿ƒåº¦
    confidence := ca.calculateConfidence(features, score)
    
    // ç”Ÿæˆè§£é‡Š
    explanation := ca.generateExplanation(features, category)
    
    result := &ComplexityResult{
        Score:          score,
        Category:       category,
        Features:       features,
        Confidence:     confidence,
        Explanation:    explanation,
        ProcessingTime: time.Since(start),
    }
    
    // ç¼“å­˜ç»“æœ
    ca.analysisCache.Set(query, result)
    
    return result, nil
}

func (ca *ComplexityAnalyzer) extractFeatures(query string) *ComplexityFeatures {
    queryLower := strings.ToLower(query)
    words := strings.Fields(query)
    sentences := strings.Split(query, "ã€‚")
    
    features := &ComplexityFeatures{
        WordCount:     len(words),
        SentenceCount: len(sentences),
    }
    
    // è®¡ç®—å¹³å‡è¯é•¿
    totalLength := 0
    for _, word := range words {
        totalLength += len(word)
    }
    if len(words) > 0 {
        features.AvgWordLength = float64(totalLength) / float64(len(words))
    }
    
    // æ£€æŸ¥SQLç‰¹å¾
    features.HasAggregation = ca.aggregatePattern.MatchString(queryLower)
    features.HasJoins = ca.joinPattern.MatchString(queryLower)
    features.HasSubqueries = strings.Contains(queryLower, "select") && 
                            (strings.Count(queryLower, "select") > 1)
    
    // åˆ†æå…³é”®è¯
    features.SimpleKeywordScore = ca.calculateKeywordScore(queryLower, ca.simpleKeywords)
    features.ComplexKeywordScore = ca.calculateKeywordScore(queryLower, ca.complexKeywords)
    
    // åˆ†æç»“æ„å¤æ‚åº¦
    features.NestedLevel = ca.calculateNestingLevel(queryLower)
    features.TableCount = ca.estimateTableCount(queryLower)
    features.ConditionCount = ca.countConditions(queryLower)
    
    return features
}

func (ca *ComplexityAnalyzer) calculateComplexityScore(features *ComplexityFeatures) float64 {
    score := 0.0
    
    // æ–‡æœ¬å¤æ‚åº¦ (30%)
    textComplexity := 0.0
    if features.WordCount > 20 {
        textComplexity += 0.3
    }
    if features.WordCount > 50 {
        textComplexity += 0.2
    }
    if features.AvgWordLength > 6 {
        textComplexity += 0.2
    }
    if features.SentenceCount > 2 {
        textComplexity += 0.3
    }
    score += textComplexity * 0.3
    
    // SQLç‰¹å¾å¤æ‚åº¦ (40%)
    sqlComplexity := 0.0
    if features.HasAggregation {
        sqlComplexity += 0.3
    }
    if features.HasJoins {
        sqlComplexity += 0.4
    }
    if features.HasSubqueries {
        sqlComplexity += 0.5
    }
    if features.TableCount > 2 {
        sqlComplexity += 0.2
    }
    if features.ConditionCount > 3 {
        sqlComplexity += 0.3
    }
    score += sqlComplexity * 0.4
    
    // å…³é”®è¯å¤æ‚åº¦ (20%)
    keywordComplexity := features.ComplexKeywordScore - features.SimpleKeywordScore
    if keywordComplexity < 0 {
        keywordComplexity = 0
    }
    score += keywordComplexity * 0.2
    
    // ç»“æ„å¤æ‚åº¦ (10%)
    structureComplexity := float64(features.NestedLevel) / 3.0
    if structureComplexity > 1.0 {
        structureComplexity = 1.0
    }
    score += structureComplexity * 0.1
    
    // ç¡®ä¿åˆ†æ•°åœ¨0-1èŒƒå›´å†…
    if score > 1.0 {
        score = 1.0
    }
    
    return score
}

func (ca *ComplexityAnalyzer) categorizeComplexity(score float64) ComplexityCategory {
    if score <= 0.3 {
        return CategorySimple
    } else if score <= 0.7 {
        return CategoryMedium
    } else {
        return CategoryComplex
    }
}

func buildSimpleKeywords() map[string]int {
    return map[string]int{
        "æŸ¥è¯¢":    3,
        "æ˜¾ç¤º":    3,
        "åˆ—å‡º":    3,
        "æ‰¾åˆ°":    2,
        "è·å–":    2,
        "select": 2,
        "from":   1,
        "where":  1,
        "ç”¨æˆ·":    1,
        "è®¢å•":    1,
        "å•†å“":    1,
    }
}

func buildComplexKeywords() map[string]int {
    return map[string]int{
        "ç»Ÿè®¡":    4,
        "åˆ†æ":    4,
        "è®¡ç®—":    3,
        "æ¯”è¾ƒ":    3,
        "å…³è”":    3,
        "èšåˆ":    3,
        "group":  3,
        "join":   3,
        "having": 4,
        "union":  4,
        "å­æŸ¥è¯¢":  5,
        "å¤æ‚":    5,
        "æ·±åº¦":    4,
    }
}

func (ca *ComplexityAnalyzer) calculateKeywordScore(query string, keywords map[string]int) float64 {
    score := 0.0
    totalWeight := 0
    
    for keyword, weight := range keywords {
        if strings.Contains(query, keyword) {
            score += float64(weight)
        }
        totalWeight += weight
    }
    
    if totalWeight > 0 {
        return score / float64(totalWeight)
    }
    return 0.0
}

func (ca *ComplexityAnalyzer) generateExplanation(
    features *ComplexityFeatures, 
    category ComplexityCategory) []string {
    
    var explanations []string
    
    switch category {
    case CategorySimple:
        explanations = append(explanations, "æŸ¥è¯¢ç»“æ„ç®€å•ï¼Œæ¶‰åŠåŸºç¡€çš„æ•°æ®æ£€ç´¢")
        if features.WordCount <= 10 {
            explanations = append(explanations, "æŸ¥è¯¢è¯æ±‡é‡è¾ƒå°‘")
        }
        if !features.HasJoins && !features.HasAggregation {
            explanations = append(explanations, "æ— å¤æ‚çš„è¡¨å…³è”å’Œèšåˆæ“ä½œ")
        }
        
    case CategoryMedium:
        explanations = append(explanations, "æŸ¥è¯¢å…·æœ‰ä¸­ç­‰å¤æ‚åº¦ï¼Œå¯èƒ½æ¶‰åŠå¤šè¡¨æ“ä½œ")
        if features.HasJoins {
            explanations = append(explanations, "åŒ…å«è¡¨è¿æ¥æ“ä½œ")
        }
        if features.HasAggregation {
            explanations = append(explanations, "åŒ…å«èšåˆå‡½æ•°")
        }
        if features.TableCount > 1 {
            explanations = append(explanations, fmt.Sprintf("æ¶‰åŠ%dä¸ªè¡¨", features.TableCount))
        }
        
    case CategoryComplex:
        explanations = append(explanations, "æŸ¥è¯¢å¤æ‚åº¦è¾ƒé«˜ï¼Œéœ€è¦æ·±åº¦åˆ†æå’Œå¤„ç†")
        if features.HasSubqueries {
            explanations = append(explanations, "åŒ…å«å­æŸ¥è¯¢")
        }
        if features.NestedLevel > 2 {
            explanations = append(explanations, "åµŒå¥—å±‚æ¬¡è¾ƒæ·±")
        }
        if features.ConditionCount > 3 {
            explanations = append(explanations, "æ¡ä»¶åˆ¤æ–­å¤æ‚")
        }
    }
    
    return explanations
}
```

---

## ğŸ¯ æ™ºèƒ½è·¯ç”±å†³ç­–å¼•æ“

### è·¯ç”±ç®—æ³•æ ¸å¿ƒå®ç°

```go
// internal/routing/engine.go
package routing

import (
    "context"
    "fmt"
    "math"
    "sort"
    "time"
)

type RoutingEngine struct {
    modelRegistry    *ModelRegistry
    loadBalancer     *LoadBalancer
    costCalculator   *CostCalculator
    performanceTracker *PerformanceTracker
    
    // è·¯ç”±ç­–ç•¥
    strategy         *RoutingStrategy
    
    // ç¼“å­˜å’Œç›‘æ§
    routingCache     *RoutingCache
    metrics          *RoutingMetrics
}

type RoutingStrategy struct {
    // æƒé‡é…ç½®
    CostWeight       float64  `yaml:"cost_weight"`       // 0.4
    PerformanceWeight float64 `yaml:"performance_weight"` // 0.4
    AccuracyWeight   float64  `yaml:"accuracy_weight"`   // 0.2
    
    // ç­–ç•¥å‚æ•°
    EnableCostOptimization bool `yaml:"enable_cost_optimization"` // true
    EnableLoadBalancing    bool `yaml:"enable_load_balancing"`    // true
    MaxRetries            int  `yaml:"max_retries"`              // 3
}

type RoutingRequest struct {
    Query           string                `json:"query"`
    ComplexityResult *ComplexityResult    `json:"complexity"`
    UserID          int64                 `json:"user_id"`
    RequestID       string                `json:"request_id"`
    Context         map[string]interface{} `json:"context"`
    
    // çº¦æŸæ¡ä»¶
    MaxCost         *float64              `json:"max_cost,omitempty"`
    MaxLatency      *time.Duration        `json:"max_latency,omitempty"`
    MinAccuracy     *float64              `json:"min_accuracy,omitempty"`
}

type RoutingResult struct {
    SelectedModel   *ModelInfo            `json:"selected_model"`
    AlternativeModels []*ModelInfo        `json:"alternative_models"`
    RoutingReason   string                `json:"routing_reason"`
    ExpectedCost    float64               `json:"expected_cost"`
    ExpectedLatency time.Duration         `json:"expected_latency"`
    ConfidenceScore float64               `json:"confidence_score"`
    ProcessingTime  time.Duration         `json:"processing_time"`
}

type ModelInfo struct {
    Name            string        `json:"name"`
    Provider        string        `json:"provider"`
    Category        string        `json:"category"`
    CurrentLoad     float64       `json:"current_load"`
    AvgLatency      time.Duration `json:"avg_latency"`
    CostPer1K       float64       `json:"cost_per_1k"`
    Accuracy        float64       `json:"accuracy"`
    Availability    float64       `json:"availability"`
    Score           float64       `json:"score"`
}

func NewRoutingEngine(
    modelRegistry *ModelRegistry,
    strategy *RoutingStrategy) *RoutingEngine {
    
    return &RoutingEngine{
        modelRegistry:      modelRegistry,
        loadBalancer:       NewLoadBalancer(),
        costCalculator:     NewCostCalculator(),
        performanceTracker: NewPerformanceTracker(),
        strategy:          strategy,
        routingCache:      NewRoutingCache(),
        metrics:           NewRoutingMetrics(),
    }
}

func (re *RoutingEngine) RouteRequest(
    ctx context.Context, 
    request *RoutingRequest) (*RoutingResult, error) {
    
    start := time.Now()
    defer func() {
        re.metrics.RecordRoutingDuration(time.Since(start))
    }()
    
    // 1. æ£€æŸ¥è·¯ç”±ç¼“å­˜
    cacheKey := re.generateCacheKey(request)
    if cached := re.routingCache.Get(cacheKey); cached != nil {
        re.metrics.RecordCacheHit()
        return cached, nil
    }
    
    // 2. è·å–å€™é€‰æ¨¡å‹
    candidates, err := re.getCandidateModels(request.ComplexityResult.Category)
    if err != nil {
        return nil, fmt.Errorf("è·å–å€™é€‰æ¨¡å‹å¤±è´¥: %w", err)
    }
    
    // 3. è¿‡æ»¤å¯ç”¨æ¨¡å‹
    availableModels := re.filterAvailableModels(candidates)
    if len(availableModels) == 0 {
        return nil, fmt.Errorf("æ²¡æœ‰å¯ç”¨æ¨¡å‹")
    }
    
    // 4. è®¡ç®—æ¨¡å‹åˆ†æ•°
    scoredModels := re.scoreModels(ctx, request, availableModels)
    
    // 5. é€‰æ‹©æœ€ä¼˜æ¨¡å‹
    selectedModel, alternatives := re.selectOptimalModel(scoredModels)
    
    // 6. æ„å»ºè·¯ç”±ç»“æœ
    result := &RoutingResult{
        SelectedModel:     selectedModel,
        AlternativeModels: alternatives,
        RoutingReason:     re.generateRoutingReason(request, selectedModel),
        ExpectedCost:      re.estimateCost(request, selectedModel),
        ExpectedLatency:   selectedModel.AvgLatency,
        ConfidenceScore:   re.calculateConfidence(selectedModel, scoredModels),
        ProcessingTime:    time.Since(start),
    }
    
    // 7. ç¼“å­˜ç»“æœ
    re.routingCache.Set(cacheKey, result)
    
    // 8. è®°å½•æŒ‡æ ‡
    re.metrics.RecordRoutingDecision(selectedModel.Name, request.ComplexityResult.Category)
    
    return result, nil
}

func (re *RoutingEngine) getCandidateModels(category ComplexityCategory) ([]*ModelInfo, error) {
    allModels := re.modelRegistry.GetAllModels()
    var candidates []*ModelInfo
    
    for _, model := range allModels {
        // æ ¹æ®å¤æ‚åº¦ç±»åˆ«ç­›é€‰æ¨¡å‹
        if re.isModelSuitableForCategory(model, category) {
            candidates = append(candidates, model)
        }
    }
    
    if len(candidates) == 0 {
        return nil, fmt.Errorf("æ²¡æœ‰é€‚åˆçš„å€™é€‰æ¨¡å‹")
    }
    
    return candidates, nil
}

func (re *RoutingEngine) isModelSuitableForCategory(
    model *ModelInfo, 
    category ComplexityCategory) bool {
    
    switch category {
    case CategorySimple:
        // ç®€å•æŸ¥è¯¢ä¼˜å…ˆä½¿ç”¨ä½æˆæœ¬æ¨¡å‹
        return model.Category == "simple" || model.Category == "medium"
    case CategoryMedium:
        // ä¸­ç­‰æŸ¥è¯¢ä½¿ç”¨å¹³è¡¡æ¨¡å‹
        return model.Category == "medium" || model.Category == "simple"
    case CategoryComplex:
        // å¤æ‚æŸ¥è¯¢ä½¿ç”¨é«˜èƒ½åŠ›æ¨¡å‹
        return model.Category == "complex" || model.Category == "medium"
    default:
        return false
    }
}

func (re *RoutingEngine) filterAvailableModels(candidates []*ModelInfo) []*ModelInfo {
    var available []*ModelInfo
    
    for _, model := range candidates {
        // æ£€æŸ¥æ¨¡å‹å¯ç”¨æ€§
        if model.Availability > 0.95 { // å¯ç”¨æ€§ > 95%
            // æ£€æŸ¥è´Ÿè½½
            if model.CurrentLoad < 0.8 { // è´Ÿè½½ < 80%
                available = append(available, model)
            }
        }
    }
    
    return available
}

func (re *RoutingEngine) scoreModels(
    ctx context.Context,
    request *RoutingRequest,
    models []*ModelInfo) []*ModelInfo {
    
    for _, model := range models {
        score := re.calculateModelScore(request, model)
        model.Score = score
    }
    
    // æŒ‰åˆ†æ•°æ’åº
    sort.Slice(models, func(i, j int) bool {
        return models[i].Score > models[j].Score
    })
    
    return models
}

func (re *RoutingEngine) calculateModelScore(
    request *RoutingRequest,
    model *ModelInfo) float64 {
    
    // æˆæœ¬åˆ†æ•° (è¶Šä½è¶Šå¥½)
    costScore := re.calculateCostScore(model, request.ComplexityResult)
    
    // æ€§èƒ½åˆ†æ•° (å»¶è¿Ÿè¶Šä½è¶Šå¥½)
    performanceScore := re.calculatePerformanceScore(model)
    
    // å‡†ç¡®ç‡åˆ†æ•°
    accuracyScore := model.Accuracy
    
    // å¯ç”¨æ€§åˆ†æ•°
    availabilityScore := model.Availability
    
    // è´Ÿè½½åˆ†æ•° (è´Ÿè½½è¶Šä½è¶Šå¥½)
    loadScore := 1.0 - model.CurrentLoad
    
    // åŠ æƒè®¡ç®—æ€»åˆ†
    totalScore := costScore*re.strategy.CostWeight +
                 performanceScore*re.strategy.PerformanceWeight +
                 accuracyScore*re.strategy.AccuracyWeight +
                 availabilityScore*0.1 +
                 loadScore*0.1
    
    return totalScore
}

func (re *RoutingEngine) calculateCostScore(
    model *ModelInfo,
    complexity *ComplexityResult) float64 {
    
    // ä¼°ç®—tokenä½¿ç”¨é‡
    estimatedTokens := re.estimateTokenUsage(complexity)
    
    // è®¡ç®—é¢„æœŸæˆæœ¬
    expectedCost := float64(estimatedTokens) * model.CostPer1K / 1000.0
    
    // å°†æˆæœ¬è½¬æ¢ä¸ºåˆ†æ•° (æˆæœ¬è¶Šä½åˆ†æ•°è¶Šé«˜)
    // ä½¿ç”¨åæ¯”ä¾‹å‡½æ•°
    maxCost := 1.0 // æœ€å¤§å¯æ¥å—æˆæœ¬ $1
    if expectedCost >= maxCost {
        return 0.0
    }
    
    return (maxCost - expectedCost) / maxCost
}

func (re *RoutingEngine) calculatePerformanceScore(model *ModelInfo) float64 {
    // å°†å»¶è¿Ÿè½¬æ¢ä¸ºåˆ†æ•° (å»¶è¿Ÿè¶Šä½åˆ†æ•°è¶Šé«˜)
    maxLatency := 10.0 // 10ç§’ä¸ºæœ€å¤§å¯æ¥å—å»¶è¿Ÿ
    latencySeconds := model.AvgLatency.Seconds()
    
    if latencySeconds >= maxLatency {
        return 0.0
    }
    
    return (maxLatency - latencySeconds) / maxLatency
}

func (re *RoutingEngine) selectOptimalModel(
    scoredModels []*ModelInfo) (*ModelInfo, []*ModelInfo) {
    
    if len(scoredModels) == 0 {
        return nil, nil
    }
    
    // æœ€ä¼˜æ¨¡å‹æ˜¯åˆ†æ•°æœ€é«˜çš„
    selectedModel := scoredModels[0]
    
    // å¤‡é€‰æ¨¡å‹
    var alternatives []*ModelInfo
    for i := 1; i < len(scoredModels) && i < 3; i++ {
        alternatives = append(alternatives, scoredModels[i])
    }
    
    return selectedModel, alternatives
}

func (re *RoutingEngine) generateRoutingReason(
    request *RoutingRequest,
    selectedModel *ModelInfo) string {
    
    category := request.ComplexityResult.Category
    
    switch category {
    case CategorySimple:
        return fmt.Sprintf("é€‰æ‹©%sï¼šç®€å•æŸ¥è¯¢ï¼Œä¼˜å…ˆè€ƒè™‘æˆæœ¬æ•ˆç›Š", selectedModel.Name)
    case CategoryMedium:
        return fmt.Sprintf("é€‰æ‹©%sï¼šä¸­ç­‰å¤æ‚åº¦æŸ¥è¯¢ï¼Œå¹³è¡¡æ€§èƒ½ä¸æˆæœ¬", selectedModel.Name)
    case CategoryComplex:
        return fmt.Sprintf("é€‰æ‹©%sï¼šå¤æ‚æŸ¥è¯¢ï¼Œä¼˜å…ˆè€ƒè™‘å‡†ç¡®ç‡å’Œæ€§èƒ½", selectedModel.Name)
    default:
        return fmt.Sprintf("é€‰æ‹©%sï¼šåŸºäºç»¼åˆè¯„åˆ†", selectedModel.Name)
    }
}

func (re *RoutingEngine) estimateCost(
    request *RoutingRequest,
    model *ModelInfo) float64 {
    
    estimatedTokens := re.estimateTokenUsage(request.ComplexityResult)
    return float64(estimatedTokens) * model.CostPer1K / 1000.0
}

func (re *RoutingEngine) estimateTokenUsage(complexity *ComplexityResult) int {
    // åŸºç¡€tokenæ•°
    baseTokens := 100
    
    // æ ¹æ®å¤æ‚åº¦è°ƒæ•´
    switch complexity.Category {
    case CategorySimple:
        return baseTokens + complexity.Features.WordCount*3
    case CategoryMedium:
        return baseTokens + complexity.Features.WordCount*5
    case CategoryComplex:
        return baseTokens + complexity.Features.WordCount*8
    default:
        return baseTokens
    }
}

func (re *RoutingEngine) calculateConfidence(
    selectedModel *ModelInfo,
    allModels []*ModelInfo) float64 {
    
    if len(allModels) <= 1 {
        return 1.0
    }
    
    // è®¡ç®—ä¸ç¬¬äºŒåçš„åˆ†æ•°å·®è·
    if len(allModels) >= 2 {
        scoreDiff := selectedModel.Score - allModels[1].Score
        // åˆ†æ•°å·®è·è¶Šå¤§ï¼Œä¿¡å¿ƒåº¦è¶Šé«˜
        confidence := 0.5 + scoreDiff*0.5
        return math.Min(confidence, 1.0)
    }
    
    return 0.8
}
```

---

## âš–ï¸ è´Ÿè½½å‡è¡¡ä¸æ•…éšœå¤„ç†

### æ™ºèƒ½è´Ÿè½½å‡è¡¡å™¨

```go
// internal/routing/load_balancer.go
package routing

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type LoadBalancer struct {
    // è´Ÿè½½è·Ÿè¸ª
    modelLoads      map[string]*ModelLoad
    qpsLimiters     map[string]*QPSLimiter
    
    // æ•…éšœå¤„ç†
    circuitBreakers map[string]*CircuitBreaker
    
    // é…ç½®
    config          *LoadBalancerConfig
    
    // å¹¶å‘æ§åˆ¶
    mu              sync.RWMutex
}

type LoadBalancerConfig struct {
    // QPSé™åˆ¶
    GlobalQPSLimit    int           `yaml:"global_qps_limit"`    // 1000
    PerModelQPSLimit  int           `yaml:"per_model_qps_limit"` // 100
    
    // ç†”æ–­é…ç½®
    CircuitBreakerConfig struct {
        FailureThreshold  int           `yaml:"failure_threshold"`  // 5
        RecoveryTimeout   time.Duration `yaml:"recovery_timeout"`   // 30s
        HalfOpenMaxCalls  int           `yaml:"half_open_max_calls"` // 3
    } `yaml:"circuit_breaker"`
    
    // è´Ÿè½½å‡è¡¡ç­–ç•¥
    Strategy         string        `yaml:"strategy"`           // "weighted_round_robin"
    HealthCheckInterval time.Duration `yaml:"health_check_interval"` // 10s
}

type ModelLoad struct {
    ModelName         string    `json:"model_name"`
    CurrentRequests   int       `json:"current_requests"`
    TotalRequests     int64     `json:"total_requests"`
    SuccessRequests   int64     `json:"success_requests"`
    FailedRequests    int64     `json:"failed_requests"`
    AvgResponseTime   time.Duration `json:"avg_response_time"`
    LastRequestTime   time.Time `json:"last_request_time"`
    LoadPercentage    float64   `json:"load_percentage"`
}

type QPSLimiter struct {
    limit     int
    requests  []time.Time
    mu        sync.Mutex
}

func NewLoadBalancer(config *LoadBalancerConfig) *LoadBalancer {
    lb := &LoadBalancer{
        modelLoads:      make(map[string]*ModelLoad),
        qpsLimiters:     make(map[string]*QPSLimiter),
        circuitBreakers: make(map[string]*CircuitBreaker),
        config:         config,
    }
    
    // å¯åŠ¨å®šæœŸæ¸…ç†
    go lb.startPeriodicCleanup()
    
    return lb
}

func (lb *LoadBalancer) CanAcceptRequest(
    ctx context.Context, 
    modelName string) (bool, error) {
    
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    // æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
    if cb, exists := lb.circuitBreakers[modelName]; exists {
        if !cb.CanExecute() {
            return false, fmt.Errorf("æ¨¡å‹ %s ç†”æ–­ä¸­", modelName)
        }
    }
    
    // æ£€æŸ¥QPSé™åˆ¶
    if limiter, exists := lb.qpsLimiters[modelName]; exists {
        if !limiter.Allow() {
            return false, fmt.Errorf("æ¨¡å‹ %s QPSé™åˆ¶", modelName)
        }
    }
    
    // æ£€æŸ¥è´Ÿè½½
    if load, exists := lb.modelLoads[modelName]; exists {
        if load.LoadPercentage > 0.9 { // è´Ÿè½½è¶…è¿‡90%
            return false, fmt.Errorf("æ¨¡å‹ %s è´Ÿè½½è¿‡é«˜", modelName)
        }
    }
    
    return true, nil
}

func (lb *LoadBalancer) RecordRequest(
    modelName string, 
    success bool, 
    responseTime time.Duration) {
    
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    // æ›´æ–°è´Ÿè½½ç»Ÿè®¡
    load, exists := lb.modelLoads[modelName]
    if !exists {
        load = &ModelLoad{
            ModelName: modelName,
        }
        lb.modelLoads[modelName] = load
    }
    
    load.TotalRequests++
    load.LastRequestTime = time.Now()
    
    if success {
        load.SuccessRequests++
    } else {
        load.FailedRequests++
    }
    
    // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
    if load.AvgResponseTime == 0 {
        load.AvgResponseTime = responseTime
    } else {
        // æŒ‡æ•°ç§»åŠ¨å¹³å‡
        alpha := 0.1
        load.AvgResponseTime = time.Duration(
            float64(load.AvgResponseTime)*(1-alpha) + 
            float64(responseTime)*alpha)
    }
    
    // æ›´æ–°è´Ÿè½½ç™¾åˆ†æ¯”
    load.LoadPercentage = lb.calculateLoadPercentage(load)
    
    // æ›´æ–°ç†”æ–­å™¨
    if cb, exists := lb.circuitBreakers[modelName]; exists {
        if success {
            cb.RecordSuccess()
        } else {
            cb.RecordFailure()
        }
    }
}

func (lb *LoadBalancer) calculateLoadPercentage(load *ModelLoad) float64 {
    if load.TotalRequests == 0 {
        return 0.0
    }
    
    // åŸºäºæˆåŠŸç‡å’Œå“åº”æ—¶é—´è®¡ç®—è´Ÿè½½
    successRate := float64(load.SuccessRequests) / float64(load.TotalRequests)
    
    // å“åº”æ—¶é—´å› å­ (å“åº”æ—¶é—´è¶Šé•¿ï¼Œè´Ÿè½½è¶Šé«˜)
    baseResponseTime := 2.0 // 2ç§’åŸºå‡†
    responseTimeFactor := load.AvgResponseTime.Seconds() / baseResponseTime
    if responseTimeFactor > 2.0 {
        responseTimeFactor = 2.0
    }
    
    // å½“å‰è¯·æ±‚æ•°å› å­
    maxConcurrent := 10.0 // æœ€å¤§å¹¶å‘
    concurrentFactor := float64(load.CurrentRequests) / maxConcurrent
    if concurrentFactor > 1.0 {
        concurrentFactor = 1.0
    }
    
    // ç»¼åˆè´Ÿè½½ = (1 - æˆåŠŸç‡) * 0.4 + å“åº”æ—¶é—´å› å­ * 0.3 + å¹¶å‘å› å­ * 0.3
    loadPercentage := (1.0-successRate)*0.4 + 
                      (responseTimeFactor-1.0)*0.3 + 
                      concurrentFactor*0.3
    
    if loadPercentage < 0 {
        loadPercentage = 0
    }
    if loadPercentage > 1 {
        loadPercentage = 1
    }
    
    return loadPercentage
}

func (lb *LoadBalancer) GetModelLoad(modelName string) *ModelLoad {
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    if load, exists := lb.modelLoads[modelName]; exists {
        // è¿”å›å‰¯æœ¬é¿å…å¹¶å‘é—®é¢˜
        return &ModelLoad{
            ModelName:       load.ModelName,
            CurrentRequests: load.CurrentRequests,
            TotalRequests:   load.TotalRequests,
            SuccessRequests: load.SuccessRequests,
            FailedRequests:  load.FailedRequests,
            AvgResponseTime: load.AvgResponseTime,
            LastRequestTime: load.LastRequestTime,
            LoadPercentage:  load.LoadPercentage,
        }
    }
    
    return nil
}

func (lb *LoadBalancer) GetAllModelLoads() map[string]*ModelLoad {
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    result := make(map[string]*ModelLoad)
    for name, load := range lb.modelLoads {
        result[name] = &ModelLoad{
            ModelName:       load.ModelName,
            CurrentRequests: load.CurrentRequests,
            TotalRequests:   load.TotalRequests,
            SuccessRequests: load.SuccessRequests,
            FailedRequests:  load.FailedRequests,
            AvgResponseTime: load.AvgResponseTime,
            LastRequestTime: load.LastRequestTime,
            LoadPercentage:  load.LoadPercentage,
        }
    }
    
    return result
}

// QPSé™åˆ¶å™¨å®ç°
func NewQPSLimiter(limit int) *QPSLimiter {
    return &QPSLimiter{
        limit:    limit,
        requests: make([]time.Time, 0),
    }
}

func (ql *QPSLimiter) Allow() bool {
    ql.mu.Lock()
    defer ql.mu.Unlock()
    
    now := time.Now()
    
    // æ¸…ç†1ç§’å‰çš„è¯·æ±‚
    cutoff := now.Add(-time.Second)
    for len(ql.requests) > 0 && ql.requests[0].Before(cutoff) {
        ql.requests = ql.requests[1:]
    }
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
    if len(ql.requests) >= ql.limit {
        return false
    }
    
    // è®°å½•æ–°è¯·æ±‚
    ql.requests = append(ql.requests, now)
    return true
}

func (lb *LoadBalancer) startPeriodicCleanup() {
    ticker := time.NewTicker(lb.config.HealthCheckInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            lb.cleanup()
        }
    }
}

func (lb *LoadBalancer) cleanup() {
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    now := time.Now()
    
    // æ¸…ç†é•¿æ—¶é—´æœªä½¿ç”¨çš„æ¨¡å‹è´Ÿè½½ä¿¡æ¯
    for name, load := range lb.modelLoads {
        if now.Sub(load.LastRequestTime) > 1*time.Hour {
            delete(lb.modelLoads, name)
        }
    }
}
```

---

## ğŸ› ï¸ é…ç½®å’Œéƒ¨ç½²

### è·¯ç”±é…ç½®ç¤ºä¾‹

```yaml
# config/router_config.yaml
router:
  # æ¨¡å‹é…ç½®
  models:
    # ç®€å•æŸ¥è¯¢æ¨¡å‹
    - name: "ollama-llama3"
      provider: "ollama"
      category: "simple"
      endpoint: "http://localhost:11434"
      cost_per_1k: 0.0
      max_tokens: 4096
      timeout: "30s"
      qps: 50
      accuracy: 0.75
      avg_latency: "3s"
      reliability: 0.95
      enabled: true
      priority: 8
      
    - name: "deepseek-coder"
      provider: "deepseek"
      category: "simple"
      endpoint: "https://api.deepseek.com/v1"
      api_key: "${DEEPSEEK_API_KEY}"
      cost_per_1k: 0.14
      max_tokens: 4096
      timeout: "15s"
      qps: 100
      accuracy: 0.82
      avg_latency: "2s"
      reliability: 0.98
      enabled: true
      priority: 7
      
    # ä¸­ç­‰å¤æ‚æŸ¥è¯¢æ¨¡å‹
    - name: "gpt-4o-mini"
      provider: "openai"
      category: "medium"
      endpoint: "https://api.openai.com/v1"
      api_key: "${OPENAI_API_KEY}"
      cost_per_1k: 0.15
      max_tokens: 4096
      timeout: "20s"
      qps: 80
      accuracy: 0.88
      avg_latency: "2s"
      reliability: 0.99
      enabled: true
      priority: 6
      
    - name: "claude-3-haiku"
      provider: "anthropic"
      category: "medium"
      endpoint: "https://api.anthropic.com/v1"
      api_key: "${ANTHROPIC_API_KEY}"
      cost_per_1k: 0.25
      max_tokens: 4096
      timeout: "25s"
      qps: 60
      accuracy: 0.90
      avg_latency: "3s"
      reliability: 0.99
      enabled: true
      priority: 5
      
    # å¤æ‚æŸ¥è¯¢æ¨¡å‹
    - name: "gpt-4o"
      provider: "openai"
      category: "complex"
      endpoint: "https://api.openai.com/v1"
      api_key: "${OPENAI_API_KEY}"
      cost_per_1k: 2.50
      max_tokens: 4096
      timeout: "30s"
      qps: 40
      accuracy: 0.94
      avg_latency: "4s"
      reliability: 0.99
      enabled: true
      priority: 3
      
    - name: "claude-3.5-sonnet"
      provider: "anthropic"
      category: "complex"
      endpoint: "https://api.anthropic.com/v1"
      api_key: "${ANTHROPIC_API_KEY}"
      cost_per_1k: 3.00
      max_tokens: 4096
      timeout: "35s"
      qps: 30
      accuracy: 0.96
      avg_latency: "5s"
      reliability: 0.99
      enabled: true
      priority: 2

  # å¤æ‚åº¦é˜ˆå€¼
  complexity_thresholds:
    simple: 0.3
    medium: 0.7
    complex: 1.0

  # è·¯ç”±ç­–ç•¥æƒé‡
  weights:
    cost: 0.4
    performance: 0.4
    accuracy: 0.2

  # é™çº§ç­–ç•¥
  fallback:
    enabled: true
    max_retries: 3
    default_model: "gpt-4o-mini"

# è´Ÿè½½å‡è¡¡é…ç½®
load_balancer:
  global_qps_limit: 1000
  per_model_qps_limit: 100
  strategy: "weighted_round_robin"
  health_check_interval: "10s"
  
  circuit_breaker:
    failure_threshold: 5
    recovery_timeout: "30s"
    half_open_max_calls: 3
```

### éƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# deploy/deploy_router.sh

set -e

echo "ğŸš€ éƒ¨ç½²æ™ºèƒ½è·¯ç”±ç³»ç»Ÿ..."

# 1. æ„å»ºè·¯ç”±æœåŠ¡
echo "ğŸ“¦ æ„å»ºè·¯ç”±æœåŠ¡..."
go build -o bin/router ./cmd/router

# 2. éƒ¨ç½²é…ç½®æ–‡ä»¶
echo "âš™ï¸ éƒ¨ç½²é…ç½®æ–‡ä»¶..."
cp config/router_config.yaml /etc/chat2sql/
cp config/prometheus.yml /etc/chat2sql/

# 3. å¯åŠ¨Redis (ç”¨äºç¼“å­˜)
echo "ğŸ”´ å¯åŠ¨RedisæœåŠ¡..."
docker run -d --name chat2sql-redis \
  -p 6379:6379 \
  -v redis-data:/data \
  redis:7.4-alpine \
  redis-server --appendonly yes

# 4. å¯åŠ¨è·¯ç”±æœåŠ¡
echo "ğŸ§  å¯åŠ¨è·¯ç”±æœåŠ¡..."
./bin/router \
  --config=/etc/chat2sql/router_config.yaml \
  --log-level=info \
  --metrics-port=9090

echo "âœ… è·¯ç”±ç³»ç»Ÿéƒ¨ç½²å®Œæˆï¼"
echo "ğŸŒ è·¯ç”±API: http://localhost:8080/api/v1/route"
echo "ğŸ“Š ç›‘æ§é¢æ¿: http://localhost:9090/metrics"
```

---

## ğŸ“Š ç›‘æ§å’Œè°ƒä¼˜

### è·¯ç”±æ€§èƒ½ç›‘æ§

```go
// internal/routing/metrics.go
package routing

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

type RouterMetrics struct {
    // è·¯ç”±å†³ç­–æŒ‡æ ‡
    RoutingDuration     prometheus.Histogram
    RoutingDecisions    *prometheus.CounterVec
    ModelSelection      *prometheus.CounterVec
    
    // ç¼“å­˜æ€§èƒ½
    CacheHitRate        prometheus.Gauge
    CacheMissRate       prometheus.Gauge
    
    // è´Ÿè½½å‡è¡¡
    ModelLoadGauge      *prometheus.GaugeVec
    QPSLimitCounter     *prometheus.CounterVec
    
    // é”™è¯¯ç›‘æ§
    RoutingErrors       *prometheus.CounterVec
    ModelFailures       *prometheus.CounterVec
}

func NewRouterMetrics() *RouterMetrics {
    return &RouterMetrics{
        RoutingDuration: promauto.NewHistogram(prometheus.HistogramOpts{
            Name: "chat2sql_routing_duration_seconds",
            Help: "è·¯ç”±å†³ç­–è€—æ—¶åˆ†å¸ƒ",
            Buckets: prometheus.DefBuckets,
        }),
        
        RoutingDecisions: promauto.NewCounterVec(prometheus.CounterOpts{
            Name: "chat2sql_routing_decisions_total",
            Help: "è·¯ç”±å†³ç­–æ€»æ•°",
        }, []string{"model", "category", "reason"}),
        
        ModelSelection: promauto.NewCounterVec(prometheus.CounterOpts{
            Name: "chat2sql_model_selection_total", 
            Help: "æ¨¡å‹é€‰æ‹©æ€»æ•°",
        }, []string{"model", "provider"}),
        
        CacheHitRate: promauto.NewGauge(prometheus.GaugeOpts{
            Name: "chat2sql_routing_cache_hit_rate",
            Help: "è·¯ç”±ç¼“å­˜å‘½ä¸­ç‡",
        }),
        
        ModelLoadGauge: promauto.NewGaugeVec(prometheus.GaugeOpts{
            Name: "chat2sql_model_load_percentage",
            Help: "æ¨¡å‹è´Ÿè½½ç™¾åˆ†æ¯”",
        }, []string{"model"}),
    }
}
```

---

<div align="center">

**ğŸ§  æ™ºèƒ½è·¯ç”±æˆåŠŸå…³é”®ï¼šç²¾ç¡®åˆ†æ + æ™ºèƒ½å†³ç­– + åŠ¨æ€è´Ÿè½½å‡è¡¡**

</div>