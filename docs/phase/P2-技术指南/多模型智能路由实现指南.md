# 🧠 多模型智能路由实现指南

<div align="center">

![Routing](https://img.shields.io/badge/Routing-Multi_Model-blue.svg)
![Intelligence](https://img.shields.io/badge/Intelligence-AI_Router-green.svg)
![Performance](https://img.shields.io/badge/Performance->95%25-orange.svg)

**Chat2SQL P2阶段 - 智能路由引擎完整实现方案**

</div>

## 📋 概述

本文档专门针对Chat2SQL系统的多模型智能路由实现，提供从架构设计到代码实现的完整技术方案，实现基于查询复杂度和成本效益的智能模型选择。

## 🎯 核心功能

### 智能路由能力
- ✅ **多模型管理**：支持OpenAI、Claude、DeepSeek、Ollama等多种模型
- ✅ **复杂度分析**：基于查询特征自动分析复杂度并分类
- ✅ **智能选择**：多目标优化的模型选择算法
- ✅ **负载均衡**：动态负载分配和QPS限制

### 性能指标
| 路由类型 | 响应时间 | 准确率 | 成本节省 |
|---------|---------|--------|----------|
| **简单查询路由** | < 50ms | > 98% | 85%+ |
| **中等查询路由** | < 100ms | > 95% | 60%+ |
| **复杂查询路由** | < 200ms | > 92% | 30%+ |

---

## 🏗️ 路由引擎架构

### 📦 核心组件设计

```go
// internal/routing/router.go
package routing

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/langchaingo/langchaingo/llms"
)

type MultiModelRouter struct {
    // 核心组件
    modelRegistry   *ModelRegistry      // 模型注册中心
    complexityAnalyzer *ComplexityAnalyzer // 复杂度分析器
    routingEngine   *RoutingEngine      // 路由决策引擎
    loadBalancer    *LoadBalancer       // 负载均衡器
    
    // 配置和策略
    config          *RouterConfig       // 路由配置
    strategy        *RoutingStrategy    // 路由策略
    
    // 监控和缓存
    metrics         *RouterMetrics      // 路由指标
    healthChecker   *HealthChecker      // 健康检查
    
    // 并发控制
    mu              sync.RWMutex
    stopCh          chan struct{}
}

type RouterConfig struct {
    // 模型配置
    Models          []ModelConfig `yaml:"models"`
    
    // 路由策略配置
    ComplexityThresholds struct {
        Simple  float64 `yaml:"simple"`   // 0.3
        Medium  float64 `yaml:"medium"`   // 0.7
        Complex float64 `yaml:"complex"`  // 1.0
    } `yaml:"complexity_thresholds"`
    
    // 权重配置
    Weights struct {
        Cost        float64 `yaml:"cost"`        // 0.4
        Performance float64 `yaml:"performance"` // 0.4
        Accuracy    float64 `yaml:"accuracy"`    // 0.2
    } `yaml:"weights"`
    
    // 降级策略
    Fallback struct {
        Enabled     bool   `yaml:"enabled"`      // true
        MaxRetries  int    `yaml:"max_retries"`  // 3
        DefaultModel string `yaml:"default_model"` // "gpt-4o-mini"
    } `yaml:"fallback"`
}

type ModelConfig struct {
    Name            string        `yaml:"name"`             // "gpt-4o-mini"
    Provider        string        `yaml:"provider"`         // "openai"
    Category        string        `yaml:"category"`         // "simple|medium|complex"
    Endpoint        string        `yaml:"endpoint"`
    ApiKey          string        `yaml:"api_key"`
    
    // 性能参数
    CostPer1K       float64       `yaml:"cost_per_1k"`      // $0.15
    MaxTokens       int           `yaml:"max_tokens"`       // 4096
    Timeout         time.Duration `yaml:"timeout"`          // 30s
    QPS             int           `yaml:"qps"`              // 100
    
    // 质量参数
    Accuracy        float64       `yaml:"accuracy"`         // 0.85
    AvgLatency      time.Duration `yaml:"avg_latency"`      // 2s
    Reliability     float64       `yaml:"reliability"`      // 0.99
    
    // 状态管理
    Enabled         bool          `yaml:"enabled"`          // true
    Priority        int           `yaml:"priority"`         // 1-10
}
```

### 🔧 路由引擎初始化

```go
func NewMultiModelRouter(config *RouterConfig) (*MultiModelRouter, error) {
    router := &MultiModelRouter{
        config:             config,
        modelRegistry:      NewModelRegistry(),
        complexityAnalyzer: NewComplexityAnalyzer(),
        routingEngine:      NewRoutingEngine(),
        loadBalancer:       NewLoadBalancer(),
        metrics:           NewRouterMetrics(),
        healthChecker:     NewHealthChecker(),
        stopCh:            make(chan struct{}),
    }
    
    // 注册所有模型
    if err := router.registerModels(); err != nil {
        return nil, fmt.Errorf("模型注册失败: %w", err)
    }
    
    // 启动健康检查
    go router.startHealthCheck()
    
    // 启动指标收集
    go router.startMetricsCollection()
    
    return router, nil
}

func (r *MultiModelRouter) registerModels() error {
    for _, modelConfig := range r.config.Models {
        // 创建模型实例
        model, err := r.createModelInstance(modelConfig)
        if err != nil {
            log.Warn("模型创建失败", zap.String("model", modelConfig.Name), zap.Error(err))
            continue
        }
        
        // 注册到注册中心
        if err := r.modelRegistry.Register(modelConfig.Name, model, modelConfig); err != nil {
            return fmt.Errorf("模型注册失败 %s: %w", modelConfig.Name, err)
        }
        
        log.Info("模型注册成功", 
            zap.String("name", modelConfig.Name),
            zap.String("category", modelConfig.Category),
            zap.Float64("cost", modelConfig.CostPer1K))
    }
    
    return nil
}

func (r *MultiModelRouter) createModelInstance(config ModelConfig) (llms.Model, error) {
    switch config.Provider {
    case "openai":
        return openai.New(
            openai.WithToken(config.ApiKey),
            openai.WithBaseURL(config.Endpoint),
            openai.WithModel(config.Name),
        )
    case "anthropic":
        return anthropic.New(
            anthropic.WithToken(config.ApiKey),
            anthropic.WithModel(config.Name),
        )
    case "deepseek":
        return openai.New( // DeepSeek使用OpenAI兼容接口
            openai.WithToken(config.ApiKey),
            openai.WithBaseURL(config.Endpoint),
            openai.WithModel(config.Name),
        )
    case "ollama":
        return ollama.New(
            ollama.WithServerURL(config.Endpoint),
            ollama.WithModel(config.Name),
        )
    default:
        return nil, fmt.Errorf("不支持的提供商: %s", config.Provider)
    }
}
```

---

## 🔍 查询复杂度分析引擎

### 复杂度评估算法

```go
// internal/routing/complexity.go
package routing

import (
    "context"
    "regexp"
    "strings"
    "unicode"
)

type ComplexityAnalyzer struct {
    // 关键词库
    simpleKeywords   map[string]int
    complexKeywords  map[string]int
    
    // 正则表达式
    sqlPatterns      []*regexp.Regexp
    aggregatePattern *regexp.Regexp
    joinPattern      *regexp.Regexp
    
    // 学习模型
    mlModel         *ComplexityMLModel
    
    // 缓存
    analysisCache   *ComplexityCache
}

type ComplexityResult struct {
    Score          float64             `json:"score"`           // 0.0-1.0
    Category       ComplexityCategory  `json:"category"`        // Simple/Medium/Complex
    Features       *ComplexityFeatures `json:"features"`
    Confidence     float64             `json:"confidence"`      // 0.0-1.0
    Explanation    []string            `json:"explanation"`
    ProcessingTime time.Duration       `json:"processing_time"`
}

type ComplexityCategory string

const (
    CategorySimple  ComplexityCategory = "simple"
    CategoryMedium  ComplexityCategory = "medium"
    CategoryComplex ComplexityCategory = "complex"
)

type ComplexityFeatures struct {
    // 文本特征
    WordCount         int     `json:"word_count"`
    SentenceCount     int     `json:"sentence_count"`
    AvgWordLength     float64 `json:"avg_word_length"`
    
    // 查询特征
    HasAggregation    bool    `json:"has_aggregation"`
    HasJoins          bool    `json:"has_joins"`
    HasSubqueries     bool    `json:"has_subqueries"`
    HasComplexLogic   bool    `json:"has_complex_logic"`
    
    // 关键词特征
    SimpleKeywordScore   float64 `json:"simple_keyword_score"`
    ComplexKeywordScore  float64 `json:"complex_keyword_score"`
    
    // 结构特征
    NestedLevel       int     `json:"nested_level"`
    TableCount        int     `json:"table_count"`
    ConditionCount    int     `json:"condition_count"`
}

func NewComplexityAnalyzer() *ComplexityAnalyzer {
    analyzer := &ComplexityAnalyzer{
        simpleKeywords:  buildSimpleKeywords(),
        complexKeywords: buildComplexKeywords(),
        sqlPatterns:     buildSQLPatterns(),
        analysisCache:   NewComplexityCache(),
    }
    
    // 编译正则表达式
    analyzer.aggregatePattern = regexp.MustCompile(`(?i)\b(sum|avg|count|max|min|group\s+by|having)\b`)
    analyzer.joinPattern = regexp.MustCompile(`(?i)\b(join|inner\s+join|left\s+join|right\s+join|full\s+join)\b`)
    
    return analyzer
}

func (ca *ComplexityAnalyzer) AnalyzeComplexity(
    ctx context.Context, 
    query string) (*ComplexityResult, error) {
    
    start := time.Now()
    
    // 检查缓存
    if cached := ca.analysisCache.Get(query); cached != nil {
        return cached, nil
    }
    
    // 提取特征
    features := ca.extractFeatures(query)
    
    // 计算复杂度分数
    score := ca.calculateComplexityScore(features)
    
    // 分类
    category := ca.categorizeComplexity(score)
    
    // 计算信心度
    confidence := ca.calculateConfidence(features, score)
    
    // 生成解释
    explanation := ca.generateExplanation(features, category)
    
    result := &ComplexityResult{
        Score:          score,
        Category:       category,
        Features:       features,
        Confidence:     confidence,
        Explanation:    explanation,
        ProcessingTime: time.Since(start),
    }
    
    // 缓存结果
    ca.analysisCache.Set(query, result)
    
    return result, nil
}

func (ca *ComplexityAnalyzer) extractFeatures(query string) *ComplexityFeatures {
    queryLower := strings.ToLower(query)
    words := strings.Fields(query)
    sentences := strings.Split(query, "。")
    
    features := &ComplexityFeatures{
        WordCount:     len(words),
        SentenceCount: len(sentences),
    }
    
    // 计算平均词长
    totalLength := 0
    for _, word := range words {
        totalLength += len(word)
    }
    if len(words) > 0 {
        features.AvgWordLength = float64(totalLength) / float64(len(words))
    }
    
    // 检查SQL特征
    features.HasAggregation = ca.aggregatePattern.MatchString(queryLower)
    features.HasJoins = ca.joinPattern.MatchString(queryLower)
    features.HasSubqueries = strings.Contains(queryLower, "select") && 
                            (strings.Count(queryLower, "select") > 1)
    
    // 分析关键词
    features.SimpleKeywordScore = ca.calculateKeywordScore(queryLower, ca.simpleKeywords)
    features.ComplexKeywordScore = ca.calculateKeywordScore(queryLower, ca.complexKeywords)
    
    // 分析结构复杂度
    features.NestedLevel = ca.calculateNestingLevel(queryLower)
    features.TableCount = ca.estimateTableCount(queryLower)
    features.ConditionCount = ca.countConditions(queryLower)
    
    return features
}

func (ca *ComplexityAnalyzer) calculateComplexityScore(features *ComplexityFeatures) float64 {
    score := 0.0
    
    // 文本复杂度 (30%)
    textComplexity := 0.0
    if features.WordCount > 20 {
        textComplexity += 0.3
    }
    if features.WordCount > 50 {
        textComplexity += 0.2
    }
    if features.AvgWordLength > 6 {
        textComplexity += 0.2
    }
    if features.SentenceCount > 2 {
        textComplexity += 0.3
    }
    score += textComplexity * 0.3
    
    // SQL特征复杂度 (40%)
    sqlComplexity := 0.0
    if features.HasAggregation {
        sqlComplexity += 0.3
    }
    if features.HasJoins {
        sqlComplexity += 0.4
    }
    if features.HasSubqueries {
        sqlComplexity += 0.5
    }
    if features.TableCount > 2 {
        sqlComplexity += 0.2
    }
    if features.ConditionCount > 3 {
        sqlComplexity += 0.3
    }
    score += sqlComplexity * 0.4
    
    // 关键词复杂度 (20%)
    keywordComplexity := features.ComplexKeywordScore - features.SimpleKeywordScore
    if keywordComplexity < 0 {
        keywordComplexity = 0
    }
    score += keywordComplexity * 0.2
    
    // 结构复杂度 (10%)
    structureComplexity := float64(features.NestedLevel) / 3.0
    if structureComplexity > 1.0 {
        structureComplexity = 1.0
    }
    score += structureComplexity * 0.1
    
    // 确保分数在0-1范围内
    if score > 1.0 {
        score = 1.0
    }
    
    return score
}

func (ca *ComplexityAnalyzer) categorizeComplexity(score float64) ComplexityCategory {
    if score <= 0.3 {
        return CategorySimple
    } else if score <= 0.7 {
        return CategoryMedium
    } else {
        return CategoryComplex
    }
}

func buildSimpleKeywords() map[string]int {
    return map[string]int{
        "查询":    3,
        "显示":    3,
        "列出":    3,
        "找到":    2,
        "获取":    2,
        "select": 2,
        "from":   1,
        "where":  1,
        "用户":    1,
        "订单":    1,
        "商品":    1,
    }
}

func buildComplexKeywords() map[string]int {
    return map[string]int{
        "统计":    4,
        "分析":    4,
        "计算":    3,
        "比较":    3,
        "关联":    3,
        "聚合":    3,
        "group":  3,
        "join":   3,
        "having": 4,
        "union":  4,
        "子查询":  5,
        "复杂":    5,
        "深度":    4,
    }
}

func (ca *ComplexityAnalyzer) calculateKeywordScore(query string, keywords map[string]int) float64 {
    score := 0.0
    totalWeight := 0
    
    for keyword, weight := range keywords {
        if strings.Contains(query, keyword) {
            score += float64(weight)
        }
        totalWeight += weight
    }
    
    if totalWeight > 0 {
        return score / float64(totalWeight)
    }
    return 0.0
}

func (ca *ComplexityAnalyzer) generateExplanation(
    features *ComplexityFeatures, 
    category ComplexityCategory) []string {
    
    var explanations []string
    
    switch category {
    case CategorySimple:
        explanations = append(explanations, "查询结构简单，涉及基础的数据检索")
        if features.WordCount <= 10 {
            explanations = append(explanations, "查询词汇量较少")
        }
        if !features.HasJoins && !features.HasAggregation {
            explanations = append(explanations, "无复杂的表关联和聚合操作")
        }
        
    case CategoryMedium:
        explanations = append(explanations, "查询具有中等复杂度，可能涉及多表操作")
        if features.HasJoins {
            explanations = append(explanations, "包含表连接操作")
        }
        if features.HasAggregation {
            explanations = append(explanations, "包含聚合函数")
        }
        if features.TableCount > 1 {
            explanations = append(explanations, fmt.Sprintf("涉及%d个表", features.TableCount))
        }
        
    case CategoryComplex:
        explanations = append(explanations, "查询复杂度较高，需要深度分析和处理")
        if features.HasSubqueries {
            explanations = append(explanations, "包含子查询")
        }
        if features.NestedLevel > 2 {
            explanations = append(explanations, "嵌套层次较深")
        }
        if features.ConditionCount > 3 {
            explanations = append(explanations, "条件判断复杂")
        }
    }
    
    return explanations
}
```

---

## 🎯 智能路由决策引擎

### 路由算法核心实现

```go
// internal/routing/engine.go
package routing

import (
    "context"
    "fmt"
    "math"
    "sort"
    "time"
)

type RoutingEngine struct {
    modelRegistry    *ModelRegistry
    loadBalancer     *LoadBalancer
    costCalculator   *CostCalculator
    performanceTracker *PerformanceTracker
    
    // 路由策略
    strategy         *RoutingStrategy
    
    // 缓存和监控
    routingCache     *RoutingCache
    metrics          *RoutingMetrics
}

type RoutingStrategy struct {
    // 权重配置
    CostWeight       float64  `yaml:"cost_weight"`       // 0.4
    PerformanceWeight float64 `yaml:"performance_weight"` // 0.4
    AccuracyWeight   float64  `yaml:"accuracy_weight"`   // 0.2
    
    // 策略参数
    EnableCostOptimization bool `yaml:"enable_cost_optimization"` // true
    EnableLoadBalancing    bool `yaml:"enable_load_balancing"`    // true
    MaxRetries            int  `yaml:"max_retries"`              // 3
}

type RoutingRequest struct {
    Query           string                `json:"query"`
    ComplexityResult *ComplexityResult    `json:"complexity"`
    UserID          int64                 `json:"user_id"`
    RequestID       string                `json:"request_id"`
    Context         map[string]interface{} `json:"context"`
    
    // 约束条件
    MaxCost         *float64              `json:"max_cost,omitempty"`
    MaxLatency      *time.Duration        `json:"max_latency,omitempty"`
    MinAccuracy     *float64              `json:"min_accuracy,omitempty"`
}

type RoutingResult struct {
    SelectedModel   *ModelInfo            `json:"selected_model"`
    AlternativeModels []*ModelInfo        `json:"alternative_models"`
    RoutingReason   string                `json:"routing_reason"`
    ExpectedCost    float64               `json:"expected_cost"`
    ExpectedLatency time.Duration         `json:"expected_latency"`
    ConfidenceScore float64               `json:"confidence_score"`
    ProcessingTime  time.Duration         `json:"processing_time"`
}

type ModelInfo struct {
    Name            string        `json:"name"`
    Provider        string        `json:"provider"`
    Category        string        `json:"category"`
    CurrentLoad     float64       `json:"current_load"`
    AvgLatency      time.Duration `json:"avg_latency"`
    CostPer1K       float64       `json:"cost_per_1k"`
    Accuracy        float64       `json:"accuracy"`
    Availability    float64       `json:"availability"`
    Score           float64       `json:"score"`
}

func NewRoutingEngine(
    modelRegistry *ModelRegistry,
    strategy *RoutingStrategy) *RoutingEngine {
    
    return &RoutingEngine{
        modelRegistry:      modelRegistry,
        loadBalancer:       NewLoadBalancer(),
        costCalculator:     NewCostCalculator(),
        performanceTracker: NewPerformanceTracker(),
        strategy:          strategy,
        routingCache:      NewRoutingCache(),
        metrics:           NewRoutingMetrics(),
    }
}

func (re *RoutingEngine) RouteRequest(
    ctx context.Context, 
    request *RoutingRequest) (*RoutingResult, error) {
    
    start := time.Now()
    defer func() {
        re.metrics.RecordRoutingDuration(time.Since(start))
    }()
    
    // 1. 检查路由缓存
    cacheKey := re.generateCacheKey(request)
    if cached := re.routingCache.Get(cacheKey); cached != nil {
        re.metrics.RecordCacheHit()
        return cached, nil
    }
    
    // 2. 获取候选模型
    candidates, err := re.getCandidateModels(request.ComplexityResult.Category)
    if err != nil {
        return nil, fmt.Errorf("获取候选模型失败: %w", err)
    }
    
    // 3. 过滤可用模型
    availableModels := re.filterAvailableModels(candidates)
    if len(availableModels) == 0 {
        return nil, fmt.Errorf("没有可用模型")
    }
    
    // 4. 计算模型分数
    scoredModels := re.scoreModels(ctx, request, availableModels)
    
    // 5. 选择最优模型
    selectedModel, alternatives := re.selectOptimalModel(scoredModels)
    
    // 6. 构建路由结果
    result := &RoutingResult{
        SelectedModel:     selectedModel,
        AlternativeModels: alternatives,
        RoutingReason:     re.generateRoutingReason(request, selectedModel),
        ExpectedCost:      re.estimateCost(request, selectedModel),
        ExpectedLatency:   selectedModel.AvgLatency,
        ConfidenceScore:   re.calculateConfidence(selectedModel, scoredModels),
        ProcessingTime:    time.Since(start),
    }
    
    // 7. 缓存结果
    re.routingCache.Set(cacheKey, result)
    
    // 8. 记录指标
    re.metrics.RecordRoutingDecision(selectedModel.Name, request.ComplexityResult.Category)
    
    return result, nil
}

func (re *RoutingEngine) getCandidateModels(category ComplexityCategory) ([]*ModelInfo, error) {
    allModels := re.modelRegistry.GetAllModels()
    var candidates []*ModelInfo
    
    for _, model := range allModels {
        // 根据复杂度类别筛选模型
        if re.isModelSuitableForCategory(model, category) {
            candidates = append(candidates, model)
        }
    }
    
    if len(candidates) == 0 {
        return nil, fmt.Errorf("没有适合的候选模型")
    }
    
    return candidates, nil
}

func (re *RoutingEngine) isModelSuitableForCategory(
    model *ModelInfo, 
    category ComplexityCategory) bool {
    
    switch category {
    case CategorySimple:
        // 简单查询优先使用低成本模型
        return model.Category == "simple" || model.Category == "medium"
    case CategoryMedium:
        // 中等查询使用平衡模型
        return model.Category == "medium" || model.Category == "simple"
    case CategoryComplex:
        // 复杂查询使用高能力模型
        return model.Category == "complex" || model.Category == "medium"
    default:
        return false
    }
}

func (re *RoutingEngine) filterAvailableModels(candidates []*ModelInfo) []*ModelInfo {
    var available []*ModelInfo
    
    for _, model := range candidates {
        // 检查模型可用性
        if model.Availability > 0.95 { // 可用性 > 95%
            // 检查负载
            if model.CurrentLoad < 0.8 { // 负载 < 80%
                available = append(available, model)
            }
        }
    }
    
    return available
}

func (re *RoutingEngine) scoreModels(
    ctx context.Context,
    request *RoutingRequest,
    models []*ModelInfo) []*ModelInfo {
    
    for _, model := range models {
        score := re.calculateModelScore(request, model)
        model.Score = score
    }
    
    // 按分数排序
    sort.Slice(models, func(i, j int) bool {
        return models[i].Score > models[j].Score
    })
    
    return models
}

func (re *RoutingEngine) calculateModelScore(
    request *RoutingRequest,
    model *ModelInfo) float64 {
    
    // 成本分数 (越低越好)
    costScore := re.calculateCostScore(model, request.ComplexityResult)
    
    // 性能分数 (延迟越低越好)
    performanceScore := re.calculatePerformanceScore(model)
    
    // 准确率分数
    accuracyScore := model.Accuracy
    
    // 可用性分数
    availabilityScore := model.Availability
    
    // 负载分数 (负载越低越好)
    loadScore := 1.0 - model.CurrentLoad
    
    // 加权计算总分
    totalScore := costScore*re.strategy.CostWeight +
                 performanceScore*re.strategy.PerformanceWeight +
                 accuracyScore*re.strategy.AccuracyWeight +
                 availabilityScore*0.1 +
                 loadScore*0.1
    
    return totalScore
}

func (re *RoutingEngine) calculateCostScore(
    model *ModelInfo,
    complexity *ComplexityResult) float64 {
    
    // 估算token使用量
    estimatedTokens := re.estimateTokenUsage(complexity)
    
    // 计算预期成本
    expectedCost := float64(estimatedTokens) * model.CostPer1K / 1000.0
    
    // 将成本转换为分数 (成本越低分数越高)
    // 使用反比例函数
    maxCost := 1.0 // 最大可接受成本 $1
    if expectedCost >= maxCost {
        return 0.0
    }
    
    return (maxCost - expectedCost) / maxCost
}

func (re *RoutingEngine) calculatePerformanceScore(model *ModelInfo) float64 {
    // 将延迟转换为分数 (延迟越低分数越高)
    maxLatency := 10.0 // 10秒为最大可接受延迟
    latencySeconds := model.AvgLatency.Seconds()
    
    if latencySeconds >= maxLatency {
        return 0.0
    }
    
    return (maxLatency - latencySeconds) / maxLatency
}

func (re *RoutingEngine) selectOptimalModel(
    scoredModels []*ModelInfo) (*ModelInfo, []*ModelInfo) {
    
    if len(scoredModels) == 0 {
        return nil, nil
    }
    
    // 最优模型是分数最高的
    selectedModel := scoredModels[0]
    
    // 备选模型
    var alternatives []*ModelInfo
    for i := 1; i < len(scoredModels) && i < 3; i++ {
        alternatives = append(alternatives, scoredModels[i])
    }
    
    return selectedModel, alternatives
}

func (re *RoutingEngine) generateRoutingReason(
    request *RoutingRequest,
    selectedModel *ModelInfo) string {
    
    category := request.ComplexityResult.Category
    
    switch category {
    case CategorySimple:
        return fmt.Sprintf("选择%s：简单查询，优先考虑成本效益", selectedModel.Name)
    case CategoryMedium:
        return fmt.Sprintf("选择%s：中等复杂度查询，平衡性能与成本", selectedModel.Name)
    case CategoryComplex:
        return fmt.Sprintf("选择%s：复杂查询，优先考虑准确率和性能", selectedModel.Name)
    default:
        return fmt.Sprintf("选择%s：基于综合评分", selectedModel.Name)
    }
}

func (re *RoutingEngine) estimateCost(
    request *RoutingRequest,
    model *ModelInfo) float64 {
    
    estimatedTokens := re.estimateTokenUsage(request.ComplexityResult)
    return float64(estimatedTokens) * model.CostPer1K / 1000.0
}

func (re *RoutingEngine) estimateTokenUsage(complexity *ComplexityResult) int {
    // 基础token数
    baseTokens := 100
    
    // 根据复杂度调整
    switch complexity.Category {
    case CategorySimple:
        return baseTokens + complexity.Features.WordCount*3
    case CategoryMedium:
        return baseTokens + complexity.Features.WordCount*5
    case CategoryComplex:
        return baseTokens + complexity.Features.WordCount*8
    default:
        return baseTokens
    }
}

func (re *RoutingEngine) calculateConfidence(
    selectedModel *ModelInfo,
    allModels []*ModelInfo) float64 {
    
    if len(allModels) <= 1 {
        return 1.0
    }
    
    // 计算与第二名的分数差距
    if len(allModels) >= 2 {
        scoreDiff := selectedModel.Score - allModels[1].Score
        // 分数差距越大，信心度越高
        confidence := 0.5 + scoreDiff*0.5
        return math.Min(confidence, 1.0)
    }
    
    return 0.8
}
```

---

## ⚖️ 负载均衡与故障处理

### 智能负载均衡器

```go
// internal/routing/load_balancer.go
package routing

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type LoadBalancer struct {
    // 负载跟踪
    modelLoads      map[string]*ModelLoad
    qpsLimiters     map[string]*QPSLimiter
    
    // 故障处理
    circuitBreakers map[string]*CircuitBreaker
    
    // 配置
    config          *LoadBalancerConfig
    
    // 并发控制
    mu              sync.RWMutex
}

type LoadBalancerConfig struct {
    // QPS限制
    GlobalQPSLimit    int           `yaml:"global_qps_limit"`    // 1000
    PerModelQPSLimit  int           `yaml:"per_model_qps_limit"` // 100
    
    // 熔断配置
    CircuitBreakerConfig struct {
        FailureThreshold  int           `yaml:"failure_threshold"`  // 5
        RecoveryTimeout   time.Duration `yaml:"recovery_timeout"`   // 30s
        HalfOpenMaxCalls  int           `yaml:"half_open_max_calls"` // 3
    } `yaml:"circuit_breaker"`
    
    // 负载均衡策略
    Strategy         string        `yaml:"strategy"`           // "weighted_round_robin"
    HealthCheckInterval time.Duration `yaml:"health_check_interval"` // 10s
}

type ModelLoad struct {
    ModelName         string    `json:"model_name"`
    CurrentRequests   int       `json:"current_requests"`
    TotalRequests     int64     `json:"total_requests"`
    SuccessRequests   int64     `json:"success_requests"`
    FailedRequests    int64     `json:"failed_requests"`
    AvgResponseTime   time.Duration `json:"avg_response_time"`
    LastRequestTime   time.Time `json:"last_request_time"`
    LoadPercentage    float64   `json:"load_percentage"`
}

type QPSLimiter struct {
    limit     int
    requests  []time.Time
    mu        sync.Mutex
}

func NewLoadBalancer(config *LoadBalancerConfig) *LoadBalancer {
    lb := &LoadBalancer{
        modelLoads:      make(map[string]*ModelLoad),
        qpsLimiters:     make(map[string]*QPSLimiter),
        circuitBreakers: make(map[string]*CircuitBreaker),
        config:         config,
    }
    
    // 启动定期清理
    go lb.startPeriodicCleanup()
    
    return lb
}

func (lb *LoadBalancer) CanAcceptRequest(
    ctx context.Context, 
    modelName string) (bool, error) {
    
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    // 检查熔断器状态
    if cb, exists := lb.circuitBreakers[modelName]; exists {
        if !cb.CanExecute() {
            return false, fmt.Errorf("模型 %s 熔断中", modelName)
        }
    }
    
    // 检查QPS限制
    if limiter, exists := lb.qpsLimiters[modelName]; exists {
        if !limiter.Allow() {
            return false, fmt.Errorf("模型 %s QPS限制", modelName)
        }
    }
    
    // 检查负载
    if load, exists := lb.modelLoads[modelName]; exists {
        if load.LoadPercentage > 0.9 { // 负载超过90%
            return false, fmt.Errorf("模型 %s 负载过高", modelName)
        }
    }
    
    return true, nil
}

func (lb *LoadBalancer) RecordRequest(
    modelName string, 
    success bool, 
    responseTime time.Duration) {
    
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    // 更新负载统计
    load, exists := lb.modelLoads[modelName]
    if !exists {
        load = &ModelLoad{
            ModelName: modelName,
        }
        lb.modelLoads[modelName] = load
    }
    
    load.TotalRequests++
    load.LastRequestTime = time.Now()
    
    if success {
        load.SuccessRequests++
    } else {
        load.FailedRequests++
    }
    
    // 更新平均响应时间
    if load.AvgResponseTime == 0 {
        load.AvgResponseTime = responseTime
    } else {
        // 指数移动平均
        alpha := 0.1
        load.AvgResponseTime = time.Duration(
            float64(load.AvgResponseTime)*(1-alpha) + 
            float64(responseTime)*alpha)
    }
    
    // 更新负载百分比
    load.LoadPercentage = lb.calculateLoadPercentage(load)
    
    // 更新熔断器
    if cb, exists := lb.circuitBreakers[modelName]; exists {
        if success {
            cb.RecordSuccess()
        } else {
            cb.RecordFailure()
        }
    }
}

func (lb *LoadBalancer) calculateLoadPercentage(load *ModelLoad) float64 {
    if load.TotalRequests == 0 {
        return 0.0
    }
    
    // 基于成功率和响应时间计算负载
    successRate := float64(load.SuccessRequests) / float64(load.TotalRequests)
    
    // 响应时间因子 (响应时间越长，负载越高)
    baseResponseTime := 2.0 // 2秒基准
    responseTimeFactor := load.AvgResponseTime.Seconds() / baseResponseTime
    if responseTimeFactor > 2.0 {
        responseTimeFactor = 2.0
    }
    
    // 当前请求数因子
    maxConcurrent := 10.0 // 最大并发
    concurrentFactor := float64(load.CurrentRequests) / maxConcurrent
    if concurrentFactor > 1.0 {
        concurrentFactor = 1.0
    }
    
    // 综合负载 = (1 - 成功率) * 0.4 + 响应时间因子 * 0.3 + 并发因子 * 0.3
    loadPercentage := (1.0-successRate)*0.4 + 
                      (responseTimeFactor-1.0)*0.3 + 
                      concurrentFactor*0.3
    
    if loadPercentage < 0 {
        loadPercentage = 0
    }
    if loadPercentage > 1 {
        loadPercentage = 1
    }
    
    return loadPercentage
}

func (lb *LoadBalancer) GetModelLoad(modelName string) *ModelLoad {
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    if load, exists := lb.modelLoads[modelName]; exists {
        // 返回副本避免并发问题
        return &ModelLoad{
            ModelName:       load.ModelName,
            CurrentRequests: load.CurrentRequests,
            TotalRequests:   load.TotalRequests,
            SuccessRequests: load.SuccessRequests,
            FailedRequests:  load.FailedRequests,
            AvgResponseTime: load.AvgResponseTime,
            LastRequestTime: load.LastRequestTime,
            LoadPercentage:  load.LoadPercentage,
        }
    }
    
    return nil
}

func (lb *LoadBalancer) GetAllModelLoads() map[string]*ModelLoad {
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    result := make(map[string]*ModelLoad)
    for name, load := range lb.modelLoads {
        result[name] = &ModelLoad{
            ModelName:       load.ModelName,
            CurrentRequests: load.CurrentRequests,
            TotalRequests:   load.TotalRequests,
            SuccessRequests: load.SuccessRequests,
            FailedRequests:  load.FailedRequests,
            AvgResponseTime: load.AvgResponseTime,
            LastRequestTime: load.LastRequestTime,
            LoadPercentage:  load.LoadPercentage,
        }
    }
    
    return result
}

// QPS限制器实现
func NewQPSLimiter(limit int) *QPSLimiter {
    return &QPSLimiter{
        limit:    limit,
        requests: make([]time.Time, 0),
    }
}

func (ql *QPSLimiter) Allow() bool {
    ql.mu.Lock()
    defer ql.mu.Unlock()
    
    now := time.Now()
    
    // 清理1秒前的请求
    cutoff := now.Add(-time.Second)
    for len(ql.requests) > 0 && ql.requests[0].Before(cutoff) {
        ql.requests = ql.requests[1:]
    }
    
    // 检查是否超过限制
    if len(ql.requests) >= ql.limit {
        return false
    }
    
    // 记录新请求
    ql.requests = append(ql.requests, now)
    return true
}

func (lb *LoadBalancer) startPeriodicCleanup() {
    ticker := time.NewTicker(lb.config.HealthCheckInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            lb.cleanup()
        }
    }
}

func (lb *LoadBalancer) cleanup() {
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    now := time.Now()
    
    // 清理长时间未使用的模型负载信息
    for name, load := range lb.modelLoads {
        if now.Sub(load.LastRequestTime) > 1*time.Hour {
            delete(lb.modelLoads, name)
        }
    }
}
```

---

## 🛠️ 配置和部署

### 路由配置示例

```yaml
# config/router_config.yaml
router:
  # 模型配置
  models:
    # 简单查询模型
    - name: "ollama-llama3"
      provider: "ollama"
      category: "simple"
      endpoint: "http://localhost:11434"
      cost_per_1k: 0.0
      max_tokens: 4096
      timeout: "30s"
      qps: 50
      accuracy: 0.75
      avg_latency: "3s"
      reliability: 0.95
      enabled: true
      priority: 8
      
    - name: "deepseek-coder"
      provider: "deepseek"
      category: "simple"
      endpoint: "https://api.deepseek.com/v1"
      api_key: "${DEEPSEEK_API_KEY}"
      cost_per_1k: 0.14
      max_tokens: 4096
      timeout: "15s"
      qps: 100
      accuracy: 0.82
      avg_latency: "2s"
      reliability: 0.98
      enabled: true
      priority: 7
      
    # 中等复杂查询模型
    - name: "gpt-4o-mini"
      provider: "openai"
      category: "medium"
      endpoint: "https://api.openai.com/v1"
      api_key: "${OPENAI_API_KEY}"
      cost_per_1k: 0.15
      max_tokens: 4096
      timeout: "20s"
      qps: 80
      accuracy: 0.88
      avg_latency: "2s"
      reliability: 0.99
      enabled: true
      priority: 6
      
    - name: "claude-3-haiku"
      provider: "anthropic"
      category: "medium"
      endpoint: "https://api.anthropic.com/v1"
      api_key: "${ANTHROPIC_API_KEY}"
      cost_per_1k: 0.25
      max_tokens: 4096
      timeout: "25s"
      qps: 60
      accuracy: 0.90
      avg_latency: "3s"
      reliability: 0.99
      enabled: true
      priority: 5
      
    # 复杂查询模型
    - name: "gpt-4o"
      provider: "openai"
      category: "complex"
      endpoint: "https://api.openai.com/v1"
      api_key: "${OPENAI_API_KEY}"
      cost_per_1k: 2.50
      max_tokens: 4096
      timeout: "30s"
      qps: 40
      accuracy: 0.94
      avg_latency: "4s"
      reliability: 0.99
      enabled: true
      priority: 3
      
    - name: "claude-3.5-sonnet"
      provider: "anthropic"
      category: "complex"
      endpoint: "https://api.anthropic.com/v1"
      api_key: "${ANTHROPIC_API_KEY}"
      cost_per_1k: 3.00
      max_tokens: 4096
      timeout: "35s"
      qps: 30
      accuracy: 0.96
      avg_latency: "5s"
      reliability: 0.99
      enabled: true
      priority: 2

  # 复杂度阈值
  complexity_thresholds:
    simple: 0.3
    medium: 0.7
    complex: 1.0

  # 路由策略权重
  weights:
    cost: 0.4
    performance: 0.4
    accuracy: 0.2

  # 降级策略
  fallback:
    enabled: true
    max_retries: 3
    default_model: "gpt-4o-mini"

# 负载均衡配置
load_balancer:
  global_qps_limit: 1000
  per_model_qps_limit: 100
  strategy: "weighted_round_robin"
  health_check_interval: "10s"
  
  circuit_breaker:
    failure_threshold: 5
    recovery_timeout: "30s"
    half_open_max_calls: 3
```

### 部署脚本

```bash
#!/bin/bash
# deploy/deploy_router.sh

set -e

echo "🚀 部署智能路由系统..."

# 1. 构建路由服务
echo "📦 构建路由服务..."
go build -o bin/router ./cmd/router

# 2. 部署配置文件
echo "⚙️ 部署配置文件..."
cp config/router_config.yaml /etc/chat2sql/
cp config/prometheus.yml /etc/chat2sql/

# 3. 启动Redis (用于缓存)
echo "🔴 启动Redis服务..."
docker run -d --name chat2sql-redis \
  -p 6379:6379 \
  -v redis-data:/data \
  redis:7.4-alpine \
  redis-server --appendonly yes

# 4. 启动路由服务
echo "🧠 启动路由服务..."
./bin/router \
  --config=/etc/chat2sql/router_config.yaml \
  --log-level=info \
  --metrics-port=9090

echo "✅ 路由系统部署完成！"
echo "🌐 路由API: http://localhost:8080/api/v1/route"
echo "📊 监控面板: http://localhost:9090/metrics"
```

---

## 📊 监控和调优

### 路由性能监控

```go
// internal/routing/metrics.go
package routing

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

type RouterMetrics struct {
    // 路由决策指标
    RoutingDuration     prometheus.Histogram
    RoutingDecisions    *prometheus.CounterVec
    ModelSelection      *prometheus.CounterVec
    
    // 缓存性能
    CacheHitRate        prometheus.Gauge
    CacheMissRate       prometheus.Gauge
    
    // 负载均衡
    ModelLoadGauge      *prometheus.GaugeVec
    QPSLimitCounter     *prometheus.CounterVec
    
    // 错误监控
    RoutingErrors       *prometheus.CounterVec
    ModelFailures       *prometheus.CounterVec
}

func NewRouterMetrics() *RouterMetrics {
    return &RouterMetrics{
        RoutingDuration: promauto.NewHistogram(prometheus.HistogramOpts{
            Name: "chat2sql_routing_duration_seconds",
            Help: "路由决策耗时分布",
            Buckets: prometheus.DefBuckets,
        }),
        
        RoutingDecisions: promauto.NewCounterVec(prometheus.CounterOpts{
            Name: "chat2sql_routing_decisions_total",
            Help: "路由决策总数",
        }, []string{"model", "category", "reason"}),
        
        ModelSelection: promauto.NewCounterVec(prometheus.CounterOpts{
            Name: "chat2sql_model_selection_total", 
            Help: "模型选择总数",
        }, []string{"model", "provider"}),
        
        CacheHitRate: promauto.NewGauge(prometheus.GaugeOpts{
            Name: "chat2sql_routing_cache_hit_rate",
            Help: "路由缓存命中率",
        }),
        
        ModelLoadGauge: promauto.NewGaugeVec(prometheus.GaugeOpts{
            Name: "chat2sql_model_load_percentage",
            Help: "模型负载百分比",
        }, []string{"model"}),
    }
}
```

---

<div align="center">

**🧠 智能路由成功关键：精确分析 + 智能决策 + 动态负载均衡**

</div>