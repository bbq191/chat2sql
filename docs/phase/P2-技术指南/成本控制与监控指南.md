# ğŸ’° æˆæœ¬æ§åˆ¶ä¸ç›‘æ§æŒ‡å—

<div align="center">

![Cost](https://img.shields.io/badge/Cost-Control-green.svg)
![Budget](https://img.shields.io/badge/Budget-Management-blue.svg)
![Savings](https://img.shields.io/badge/Savings->50%25-orange.svg)

**Chat2SQL P2é˜¶æ®µ - æ™ºèƒ½æˆæœ¬æ§åˆ¶ä¸ç›‘æ§å®Œæ•´å®ç°æ–¹æ¡ˆ**

</div>

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸“é—¨é’ˆå¯¹Chat2SQLç³»ç»Ÿçš„æˆæœ¬æ§åˆ¶ä¸ç›‘æ§å®ç°ï¼Œæä¾›ä»æ¶æ„è®¾è®¡åˆ°ä»£ç å®ç°çš„å®Œæ•´æŠ€æœ¯æ–¹æ¡ˆï¼Œå®ç°å®æ—¶æˆæœ¬è¿½è¸ªã€é¢„ç®—ç®¡ç†å’Œæ™ºèƒ½æˆæœ¬ä¼˜åŒ–ï¼Œç¡®ä¿AIè°ƒç”¨æˆæœ¬çš„æœ‰æ•ˆæ§åˆ¶ã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### æˆæœ¬æ§åˆ¶èƒ½åŠ›
- âœ… **å®æ—¶æˆæœ¬è¿½è¸ª**ï¼šTokenä½¿ç”¨é‡å’Œæˆæœ¬çš„å®æ—¶ç»Ÿè®¡
- âœ… **å¤šç»´é¢„ç®—ç®¡ç†**ï¼šç”¨æˆ·/éƒ¨é—¨/å…¬å¸çº§åˆ«çš„é¢„ç®—æ§åˆ¶
- âœ… **æˆæœ¬é¢„æµ‹æ¨¡å‹**ï¼šåŸºäºå†å²æ•°æ®çš„æˆæœ¬è¶‹åŠ¿é¢„æµ‹
- âœ… **æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ**ï¼šå¤šçº§æˆæœ¬å‘Šè­¦å’Œè‡ªåŠ¨åŒ–å“åº”

### æˆæœ¬ä¼˜åŒ–æŒ‡æ ‡
| æ§åˆ¶ç»´åº¦ | èŠ‚çœç›®æ ‡ | ç›‘æ§ç²¾åº¦ | å“åº”æ—¶é—´ |
|---------|---------|---------|----------|
| **æ¨¡å‹è·¯ç”±ä¼˜åŒ–** | > 60% | å®æ—¶ | < 1s |
| **ç¼“å­˜å‘½ä¸­æå‡** | > 30% | å®æ—¶ | < 100ms |
| **é¢„ç®—æ§åˆ¶** | 100% | å®æ—¶ | < 500ms |

---

## ğŸ—ï¸ æˆæœ¬æ§åˆ¶ç³»ç»Ÿæ¶æ„

### ğŸ“¦ æ ¸å¿ƒç»„ä»¶è®¾è®¡

```go
// internal/cost/controller.go
package cost

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/shopspring/decimal"
)

type CostController struct {
    // æ ¸å¿ƒç»„ä»¶
    usageTracker    *UsageTracker       // ä½¿ç”¨é‡è¿½è¸ª
    budgetManager   *BudgetManager      // é¢„ç®—ç®¡ç†
    costCalculator  *CostCalculator     // æˆæœ¬è®¡ç®—
    predictor       *CostPredictor      // æˆæœ¬é¢„æµ‹
    
    // å‘Šè­¦ç³»ç»Ÿ
    alertManager    *AlertManager       // å‘Šè­¦ç®¡ç†
    notifier        *CostNotifier       // é€šçŸ¥ç³»ç»Ÿ
    
    // å­˜å‚¨
    storage         *CostStorage        // æˆæœ¬æ•°æ®å­˜å‚¨
    cache           *CostCache          // æˆæœ¬ç¼“å­˜
    
    // é…ç½®
    config          *CostConfig         // æˆæœ¬é…ç½®
    
    // ç›‘æ§
    metrics         *CostMetrics        // æˆæœ¬æŒ‡æ ‡
    
    // å¹¶å‘æ§åˆ¶
    mu              sync.RWMutex
    stopCh          chan struct{}
}

type CostConfig struct {
    // é¢„ç®—é…ç½®
    Budgets struct {
        UserDaily       decimal.Decimal `yaml:"user_daily"`       // $5.00
        DepartmentWeekly decimal.Decimal `yaml:"department_weekly"` // $500.00
        CompanyMonthly  decimal.Decimal `yaml:"company_monthly"`  // $10000.00
    } `yaml:"budgets"`
    
    // å‘Šè­¦é˜ˆå€¼
    AlertThresholds struct {
        Warning       float64 `yaml:"warning"`        // 0.8 (80%)
        Critical      float64 `yaml:"critical"`       // 0.9 (90%)
        Emergency     float64 `yaml:"emergency"`      // 0.95 (95%)
    } `yaml:"alert_thresholds"`
    
    // æˆæœ¬æ§åˆ¶ç­–ç•¥
    Controls struct {
        EnableAutoLimit    bool            `yaml:"enable_auto_limit"`     // true
        EnableEmergencyStop bool           `yaml:"enable_emergency_stop"` // true
        GracePeriod       time.Duration   `yaml:"grace_period"`          // 5m
        CooldownPeriod    time.Duration   `yaml:"cooldown_period"`       // 1h
    } `yaml:"controls"`
    
    // æ¨¡å‹æˆæœ¬é…ç½®
    ModelCosts map[string]ModelCostConfig `yaml:"model_costs"`
}

type ModelCostConfig struct {
    InputCostPer1K   decimal.Decimal `yaml:"input_cost_per_1k"`   // è¾“å…¥tokenæˆæœ¬
    OutputCostPer1K  decimal.Decimal `yaml:"output_cost_per_1k"`  // è¾“å‡ºtokenæˆæœ¬
    Provider         string          `yaml:"provider"`            // æä¾›å•†
    Model            string          `yaml:"model"`               // æ¨¡å‹åç§°
    LastUpdated      time.Time       `yaml:"last_updated"`        // æœ€åæ›´æ–°æ—¶é—´
}

type UsageRecord struct {
    // åŸºç¡€ä¿¡æ¯
    ID              string          `json:"id"`
    RequestID       string          `json:"request_id"`
    UserID          int64           `json:"user_id"`
    DepartmentID    int64           `json:"department_id"`
    
    // æ¨¡å‹ä¿¡æ¯
    Model           string          `json:"model"`
    Provider        string          `json:"provider"`
    
    // Tokenä½¿ç”¨é‡
    InputTokens     int             `json:"input_tokens"`
    OutputTokens    int             `json:"output_tokens"`
    TotalTokens     int             `json:"total_tokens"`
    
    // æˆæœ¬ä¿¡æ¯
    InputCost       decimal.Decimal `json:"input_cost"`
    OutputCost      decimal.Decimal `json:"output_cost"`
    TotalCost       decimal.Decimal `json:"total_cost"`
    
    // æ—¶é—´ä¿¡æ¯
    Timestamp       time.Time       `json:"timestamp"`
    ResponseTime    time.Duration   `json:"response_time"`
    
    // æŸ¥è¯¢ä¿¡æ¯
    Query           string          `json:"query"`
    QueryComplexity string          `json:"query_complexity"`
    CacheHit        bool           `json:"cache_hit"`
    
    // è´¨é‡ä¿¡æ¯
    Success         bool           `json:"success"`
    Confidence      float64        `json:"confidence"`
    
    // å…ƒæ•°æ®
    Metadata        map[string]interface{} `json:"metadata"`
}
```

### ğŸ”§ æˆæœ¬æ§åˆ¶å™¨åˆå§‹åŒ–

```go
func NewCostController(config *CostConfig) (*CostController, error) {
    controller := &CostController{
        usageTracker:   NewUsageTracker(),
        budgetManager:  NewBudgetManager(config.Budgets),
        costCalculator: NewCostCalculator(config.ModelCosts),
        predictor:      NewCostPredictor(),
        alertManager:   NewAlertManager(config.AlertThresholds),
        notifier:       NewCostNotifier(),
        storage:        NewCostStorage(),
        cache:          NewCostCache(),
        config:        config,
        metrics:       NewCostMetrics(),
        stopCh:        make(chan struct{}),
    }
    
    // å¯åŠ¨åå°ä»»åŠ¡
    go controller.startBackgroundTasks()
    
    return controller, nil
}

func (cc *CostController) startBackgroundTasks() {
    // å®æ—¶æˆæœ¬ç»Ÿè®¡
    go cc.startRealTimeTracking()
    
    // é¢„ç®—æ£€æŸ¥
    go cc.startBudgetMonitoring()
    
    // æˆæœ¬é¢„æµ‹
    go cc.startCostPrediction()
    
    // å‘Šè­¦æ£€æŸ¥
    go cc.startAlertMonitoring()
    
    // æ•°æ®æ¸…ç†
    go cc.startDataCleanup()
}

func (cc *CostController) RecordUsage(ctx context.Context, usage *UsageRecord) error {
    start := time.Now()
    defer func() {
        cc.metrics.RecordOperationDuration("record_usage", time.Since(start))
    }()
    
    // 1. è®¡ç®—æˆæœ¬
    if err := cc.calculateCost(usage); err != nil {
        cc.metrics.RecordError("cost_calculation")
        return fmt.Errorf("æˆæœ¬è®¡ç®—å¤±è´¥: %w", err)
    }
    
    // 2. è®°å½•ä½¿ç”¨é‡
    if err := cc.usageTracker.Track(usage); err != nil {
        cc.metrics.RecordError("usage_tracking")
        return fmt.Errorf("ä½¿ç”¨é‡è¿½è¸ªå¤±è´¥: %w", err)
    }
    
    // 3. æ£€æŸ¥é¢„ç®—
    if err := cc.checkBudgetLimits(ctx, usage); err != nil {
        cc.metrics.RecordBudgetViolation(usage.UserID, usage.DepartmentID)
        return fmt.Errorf("é¢„ç®—æ£€æŸ¥å¤±è´¥: %w", err)
    }
    
    // 4. æ›´æ–°ç»Ÿè®¡
    cc.updateStatistics(usage)
    
    // 5. å¼‚æ­¥å­˜å‚¨
    go func() {
        if err := cc.storage.Store(context.Background(), usage); err != nil {
            log.Error("æˆæœ¬æ•°æ®å­˜å‚¨å¤±è´¥", zap.Error(err))
        }
    }()
    
    return nil
}

func (cc *CostController) calculateCost(usage *UsageRecord) error {
    modelConfig, exists := cc.config.ModelCosts[usage.Model]
    if !exists {
        return fmt.Errorf("æ¨¡å‹æˆæœ¬é…ç½®ä¸å­˜åœ¨: %s", usage.Model)
    }
    
    // è®¡ç®—è¾“å…¥æˆæœ¬
    usage.InputCost = modelConfig.InputCostPer1K.Mul(
        decimal.NewFromInt(int64(usage.InputTokens))).Div(decimal.NewFromInt(1000))
    
    // è®¡ç®—è¾“å‡ºæˆæœ¬
    usage.OutputCost = modelConfig.OutputCostPer1K.Mul(
        decimal.NewFromInt(int64(usage.OutputTokens))).Div(decimal.NewFromInt(1000))
    
    // è®¡ç®—æ€»æˆæœ¬
    usage.TotalCost = usage.InputCost.Add(usage.OutputCost)
    
    return nil
}
```

---

## ğŸ“Š å®æ—¶ä½¿ç”¨é‡è¿½è¸ª

### é«˜æ€§èƒ½ä½¿ç”¨é‡è¿½è¸ªå™¨

```go
// internal/cost/usage_tracker.go
package cost

import (
    "sync"
    "time"
    
    "github.com/shopspring/decimal"
)

type UsageTracker struct {
    // å®æ—¶ç»Ÿè®¡
    currentUsage    map[string]*UsageStats  // æŒ‰ç”¨æˆ·/éƒ¨é—¨çš„å®æ—¶ä½¿ç”¨ç»Ÿè®¡
    
    // æ—¶é—´çª—å£ç»Ÿè®¡
    hourlyUsage     *TimeWindowStats        // æŒ‰å°æ—¶ç»Ÿè®¡
    dailyUsage      *TimeWindowStats        // æŒ‰æ—¥ç»Ÿè®¡
    monthlyUsage    *TimeWindowStats        // æŒ‰æœˆç»Ÿè®¡
    
    // å¹¶å‘æ§åˆ¶
    mu              sync.RWMutex
    
    // é…ç½®
    config          *TrackerConfig
}

type UsageStats struct {
    // åŸºç¡€ç»Ÿè®¡
    TotalRequests   int64           `json:"total_requests"`
    SuccessRequests int64           `json:"success_requests"`
    FailedRequests  int64           `json:"failed_requests"`
    
    // Tokenç»Ÿè®¡
    TotalTokens     int64           `json:"total_tokens"`
    InputTokens     int64           `json:"input_tokens"`
    OutputTokens    int64           `json:"output_tokens"`
    
    // æˆæœ¬ç»Ÿè®¡
    TotalCost       decimal.Decimal `json:"total_cost"`
    AvgCostPerRequest decimal.Decimal `json:"avg_cost_per_request"`
    
    // æ¨¡å‹ä½¿ç”¨ç»Ÿè®¡
    ModelUsage      map[string]*ModelUsageStats `json:"model_usage"`
    
    // æ—¶é—´ç»Ÿè®¡
    FirstRequest    time.Time       `json:"first_request"`
    LastRequest     time.Time       `json:"last_request"`
    
    // æ€§èƒ½ç»Ÿè®¡
    AvgResponseTime time.Duration   `json:"avg_response_time"`
    TotalResponseTime time.Duration `json:"total_response_time"`
}

type ModelUsageStats struct {
    Requests        int64           `json:"requests"`
    Tokens          int64           `json:"tokens"`
    Cost            decimal.Decimal `json:"cost"`
    AvgConfidence   float64         `json:"avg_confidence"`
    SuccessRate     float64         `json:"success_rate"`
}

type TimeWindowStats struct {
    windows         map[string]*UsageStats  // æ—¶é—´çª—å£ -> ç»Ÿè®¡æ•°æ®
    windowSize      time.Duration           // çª—å£å¤§å°
    maxWindows      int                     // æœ€å¤§çª—å£æ•°
    mu              sync.RWMutex
}

func NewUsageTracker() *UsageTracker {
    return &UsageTracker{
        currentUsage:  make(map[string]*UsageStats),
        hourlyUsage:   NewTimeWindowStats(time.Hour, 48),      // ä¿æŒ48å°æ—¶
        dailyUsage:    NewTimeWindowStats(24*time.Hour, 30),   // ä¿æŒ30å¤©
        monthlyUsage:  NewTimeWindowStats(30*24*time.Hour, 12), // ä¿æŒ12ä¸ªæœˆ
    }
}

func (ut *UsageTracker) Track(usage *UsageRecord) error {
    ut.mu.Lock()
    defer ut.mu.Unlock()
    
    // 1. æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
    userKey := fmt.Sprintf("user:%d", usage.UserID)
    ut.updateUsageStats(userKey, usage)
    
    // 2. æ›´æ–°éƒ¨é—¨ç»Ÿè®¡
    deptKey := fmt.Sprintf("dept:%d", usage.DepartmentID)
    ut.updateUsageStats(deptKey, usage)
    
    // 3. æ›´æ–°å…¨å±€ç»Ÿè®¡
    ut.updateUsageStats("global", usage)
    
    // 4. æ›´æ–°æ—¶é—´çª—å£ç»Ÿè®¡
    ut.updateTimeWindowStats(usage)
    
    return nil
}

func (ut *UsageTracker) updateUsageStats(key string, usage *UsageRecord) {
    stats, exists := ut.currentUsage[key]
    if !exists {
        stats = &UsageStats{
            ModelUsage:   make(map[string]*ModelUsageStats),
            FirstRequest: usage.Timestamp,
        }
        ut.currentUsage[key] = stats
    }
    
    // æ›´æ–°åŸºç¡€ç»Ÿè®¡
    stats.TotalRequests++
    if usage.Success {
        stats.SuccessRequests++
    } else {
        stats.FailedRequests++
    }
    
    // æ›´æ–°Tokenç»Ÿè®¡
    stats.TotalTokens += int64(usage.TotalTokens)
    stats.InputTokens += int64(usage.InputTokens)
    stats.OutputTokens += int64(usage.OutputTokens)
    
    // æ›´æ–°æˆæœ¬ç»Ÿè®¡
    stats.TotalCost = stats.TotalCost.Add(usage.TotalCost)
    stats.AvgCostPerRequest = stats.TotalCost.Div(decimal.NewFromInt(stats.TotalRequests))
    
    // æ›´æ–°æ¨¡å‹ä½¿ç”¨ç»Ÿè®¡
    modelStats, exists := stats.ModelUsage[usage.Model]
    if !exists {
        modelStats = &ModelUsageStats{}
        stats.ModelUsage[usage.Model] = modelStats
    }
    
    modelStats.Requests++
    modelStats.Tokens += int64(usage.TotalTokens)
    modelStats.Cost = modelStats.Cost.Add(usage.TotalCost)
    
    // æ›´æ–°å¹³å‡ä¿¡å¿ƒåº¦
    if usage.Success {
        oldConfidence := modelStats.AvgConfidence
        newCount := modelStats.Requests
        modelStats.AvgConfidence = (oldConfidence*float64(newCount-1) + usage.Confidence) / float64(newCount)
    }
    
    // æ›´æ–°æˆåŠŸç‡
    successCount := int64(0)
    if usage.Success {
        successCount = 1
    }
    modelStats.SuccessRate = float64(successCount) / float64(modelStats.Requests)
    
    // æ›´æ–°æ—¶é—´ç»Ÿè®¡
    stats.LastRequest = usage.Timestamp
    
    // æ›´æ–°æ€§èƒ½ç»Ÿè®¡
    stats.TotalResponseTime += usage.ResponseTime
    stats.AvgResponseTime = stats.TotalResponseTime / time.Duration(stats.TotalRequests)
}

func (ut *UsageTracker) updateTimeWindowStats(usage *UsageRecord) {
    // æ›´æ–°å°æ—¶ç»Ÿè®¡
    hourKey := usage.Timestamp.Format("2006-01-02-15")
    ut.hourlyUsage.Update(hourKey, usage)
    
    // æ›´æ–°æ—¥ç»Ÿè®¡
    dayKey := usage.Timestamp.Format("2006-01-02")
    ut.dailyUsage.Update(dayKey, usage)
    
    // æ›´æ–°æœˆç»Ÿè®¡
    monthKey := usage.Timestamp.Format("2006-01")
    ut.monthlyUsage.Update(monthKey, usage)
}

func (ut *UsageTracker) GetUsageStats(key string) *UsageStats {
    ut.mu.RLock()
    defer ut.mu.RUnlock()
    
    if stats, exists := ut.currentUsage[key]; exists {
        // è¿”å›å‰¯æœ¬é¿å…å¹¶å‘é—®é¢˜
        return ut.copyUsageStats(stats)
    }
    
    return nil
}

func (ut *UsageTracker) GetUserUsage(userID int64) *UsageStats {
    key := fmt.Sprintf("user:%d", userID)
    return ut.GetUsageStats(key)
}

func (ut *UsageTracker) GetDepartmentUsage(deptID int64) *UsageStats {
    key := fmt.Sprintf("dept:%d", deptID)
    return ut.GetUsageStats(key)
}

func (ut *UsageTracker) GetGlobalUsage() *UsageStats {
    return ut.GetUsageStats("global")
}

func (ut *UsageTracker) GetTimeWindowUsage(window string, windowType string) []*UsageStats {
    ut.mu.RLock()
    defer ut.mu.RUnlock()
    
    var timeStats *TimeWindowStats
    switch windowType {
    case "hour":
        timeStats = ut.hourlyUsage
    case "day":
        timeStats = ut.dailyUsage
    case "month":
        timeStats = ut.monthlyUsage
    default:
        return nil
    }
    
    return timeStats.GetRecentStats(24) // è·å–æœ€è¿‘24ä¸ªçª—å£
}

// æ—¶é—´çª—å£ç»Ÿè®¡å®ç°
func NewTimeWindowStats(windowSize time.Duration, maxWindows int) *TimeWindowStats {
    return &TimeWindowStats{
        windows:    make(map[string]*UsageStats),
        windowSize: windowSize,
        maxWindows: maxWindows,
    }
}

func (tws *TimeWindowStats) Update(key string, usage *UsageRecord) {
    tws.mu.Lock()
    defer tws.mu.Unlock()
    
    stats, exists := tws.windows[key]
    if !exists {
        stats = &UsageStats{
            ModelUsage:   make(map[string]*ModelUsageStats),
            FirstRequest: usage.Timestamp,
        }
        tws.windows[key] = stats
    }
    
    // æ›´æ–°ç»Ÿè®¡ (å¤ç”¨updateUsageStatsçš„é€»è¾‘)
    // ... (ç±»ä¼¼å®ç°)
    
    // æ¸…ç†æ—§çª—å£
    tws.cleanupOldWindows()
}

func (tws *TimeWindowStats) cleanupOldWindows() {
    if len(tws.windows) <= tws.maxWindows {
        return
    }
    
    // è·å–æ‰€æœ‰çª—å£é”®å¹¶æ’åº
    keys := make([]string, 0, len(tws.windows))
    for key := range tws.windows {
        keys = append(keys, key)
    }
    
    sort.Strings(keys)
    
    // åˆ é™¤æœ€æ—§çš„çª—å£
    deleteCount := len(keys) - tws.maxWindows
    for i := 0; i < deleteCount; i++ {
        delete(tws.windows, keys[i])
    }
}

func (tws *TimeWindowStats) GetRecentStats(count int) []*UsageStats {
    tws.mu.RLock()
    defer tws.mu.RUnlock()
    
    keys := make([]string, 0, len(tws.windows))
    for key := range tws.windows {
        keys = append(keys, key)
    }
    
    sort.Strings(keys)
    
    // è·å–æœ€æ–°çš„countä¸ªçª—å£
    start := len(keys) - count
    if start < 0 {
        start = 0
    }
    
    result := make([]*UsageStats, 0, count)
    for i := start; i < len(keys); i++ {
        if stats, exists := tws.windows[keys[i]]; exists {
            result = append(result, stats)
        }
    }
    
    return result
}
```

---

## ğŸ’³ é¢„ç®—ç®¡ç†ç³»ç»Ÿ

### å¤šç»´åº¦é¢„ç®—æ§åˆ¶

```go
// internal/cost/budget_manager.go
package cost

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/shopspring/decimal"
)

type BudgetManager struct {
    // é¢„ç®—é…ç½®
    budgets         map[string]*Budget      // é¢„ç®—é…ç½®
    
    // ä½¿ç”¨é‡è¿½è¸ª
    usageTracker    *UsageTracker          // ä½¿ç”¨é‡è¿½è¸ªå™¨
    
    // å‘Šè­¦ç®¡ç†
    alertManager    *AlertManager          // å‘Šè­¦ç®¡ç†å™¨
    
    // å¹¶å‘æ§åˆ¶
    mu              sync.RWMutex
    
    // é…ç½®
    config          *BudgetConfig
}

type Budget struct {
    // åŸºç¡€ä¿¡æ¯
    ID              string          `json:"id"`
    Name            string          `json:"name"`
    Type            BudgetType      `json:"type"`           // user/department/company
    EntityID        int64           `json:"entity_id"`      // å®ä½“ID
    
    // é¢„ç®—é…ç½®
    Amount          decimal.Decimal `json:"amount"`         // é¢„ç®—é‡‘é¢
    Period          BudgetPeriod    `json:"period"`         // é¢„ç®—å‘¨æœŸ
    Currency        string          `json:"currency"`       // è´§å¸å•ä½
    
    // ä½¿ç”¨æƒ…å†µ
    Used            decimal.Decimal `json:"used"`           // å·²ä½¿ç”¨é‡‘é¢
    Remaining       decimal.Decimal `json:"remaining"`      // å‰©ä½™é‡‘é¢
    UsagePercentage float64         `json:"usage_percentage"` // ä½¿ç”¨ç™¾åˆ†æ¯”
    
    // æ—¶é—´ä¿¡æ¯
    StartTime       time.Time       `json:"start_time"`     // å¼€å§‹æ—¶é—´
    EndTime         time.Time       `json:"end_time"`       // ç»“æŸæ—¶é—´
    LastUpdated     time.Time       `json:"last_updated"`   // æœ€åæ›´æ–°æ—¶é—´
    
    // å‘Šè­¦é…ç½®
    AlertThresholds []float64       `json:"alert_thresholds"` // å‘Šè­¦é˜ˆå€¼
    AlertEnabled    bool           `json:"alert_enabled"`    // æ˜¯å¦å¯ç”¨å‘Šè­¦
    
    // æ§åˆ¶ç­–ç•¥
    Controls        *BudgetControls `json:"controls"`       // é¢„ç®—æ§åˆ¶ç­–ç•¥
    
    // çŠ¶æ€
    Status          BudgetStatus    `json:"status"`         // é¢„ç®—çŠ¶æ€
    
    // å…ƒæ•°æ®
    Metadata        map[string]interface{} `json:"metadata"`
}

type BudgetType string
type BudgetPeriod string
type BudgetStatus string

const (
    BudgetTypeUser       BudgetType = "user"
    BudgetTypeDepartment BudgetType = "department"
    BudgetTypeCompany    BudgetType = "company"
    
    BudgetPeriodDaily    BudgetPeriod = "daily"
    BudgetPeriodWeekly   BudgetPeriod = "weekly"
    BudgetPeriodMonthly  BudgetPeriod = "monthly"
    BudgetPeriodYearly   BudgetPeriod = "yearly"
    
    BudgetStatusActive   BudgetStatus = "active"
    BudgetStatusWarning  BudgetStatus = "warning"
    BudgetStatusCritical BudgetStatus = "critical"
    BudgetStatusExceeded BudgetStatus = "exceeded"
    BudgetStatusExpired  BudgetStatus = "expired"
)

type BudgetControls struct {
    // é™åˆ¶ç­–ç•¥
    EnableHardLimit     bool            `json:"enable_hard_limit"`     // ç¡¬é™åˆ¶
    EnableSoftLimit     bool            `json:"enable_soft_limit"`     // è½¯é™åˆ¶
    SoftLimitThreshold  float64         `json:"soft_limit_threshold"`  // è½¯é™åˆ¶é˜ˆå€¼
    
    // è‡ªåŠ¨æ§åˆ¶
    EnableAutoThrottle  bool            `json:"enable_auto_throttle"`  // è‡ªåŠ¨é™æµ
    ThrottleThreshold   float64         `json:"throttle_threshold"`    // é™æµé˜ˆå€¼
    ThrottleRate        float64         `json:"throttle_rate"`         // é™æµæ¯”ä¾‹
    
    // ç´§æ€¥æ§åˆ¶
    EnableEmergencyStop bool            `json:"enable_emergency_stop"` // ç´§æ€¥åœæ­¢
    EmergencyThreshold  float64         `json:"emergency_threshold"`   // ç´§æ€¥åœæ­¢é˜ˆå€¼
    
    // å†·å´æœŸ
    CooldownPeriod      time.Duration   `json:"cooldown_period"`       // å†·å´æœŸ
    LastControlAction   time.Time       `json:"last_control_action"`   // æœ€åæ§åˆ¶åŠ¨ä½œæ—¶é—´
}

func NewBudgetManager(config *BudgetConfig) *BudgetManager {
    return &BudgetManager{
        budgets:      make(map[string]*Budget),
        config:       config,
        usageTracker: NewUsageTracker(),
        alertManager: NewAlertManager(nil),
    }
}

func (bm *BudgetManager) CreateBudget(budget *Budget) error {
    bm.mu.Lock()
    defer bm.mu.Unlock()
    
    // éªŒè¯é¢„ç®—é…ç½®
    if err := bm.validateBudget(budget); err != nil {
        return fmt.Errorf("é¢„ç®—é…ç½®éªŒè¯å¤±è´¥: %w", err)
    }
    
    // è®¾ç½®é¢„ç®—æ—¶é—´èŒƒå›´
    if err := bm.setBudgetPeriod(budget); err != nil {
        return fmt.Errorf("è®¾ç½®é¢„ç®—å‘¨æœŸå¤±è´¥: %w", err)
    }
    
    // åˆå§‹åŒ–é¢„ç®—çŠ¶æ€
    budget.Used = decimal.Zero
    budget.Remaining = budget.Amount
    budget.UsagePercentage = 0.0
    budget.Status = BudgetStatusActive
    budget.LastUpdated = time.Now()
    
    // å­˜å‚¨é¢„ç®—
    bm.budgets[budget.ID] = budget
    
    return nil
}

func (bm *BudgetManager) CheckBudgetLimit(ctx context.Context, usage *UsageRecord) error {
    // æ£€æŸ¥ç”¨æˆ·é¢„ç®—
    if err := bm.checkUserBudget(usage); err != nil {
        return err
    }
    
    // æ£€æŸ¥éƒ¨é—¨é¢„ç®—
    if err := bm.checkDepartmentBudget(usage); err != nil {
        return err
    }
    
    // æ£€æŸ¥å…¬å¸é¢„ç®—
    if err := bm.checkCompanyBudget(usage); err != nil {
        return err
    }
    
    return nil
}

func (bm *BudgetManager) checkUserBudget(usage *UsageRecord) error {
    userBudgetID := fmt.Sprintf("user_%d_daily", usage.UserID)
    budget := bm.getBudget(userBudgetID)
    
    if budget == nil {
        // å¦‚æœæ²¡æœ‰ç”¨æˆ·é¢„ç®—ï¼Œåˆ›å»ºé»˜è®¤é¢„ç®—
        budget = bm.createDefaultUserBudget(usage.UserID)
    }
    
    return bm.validateUsageAgainstBudget(budget, usage.TotalCost)
}

func (bm *BudgetManager) checkDepartmentBudget(usage *UsageRecord) error {
    deptBudgetID := fmt.Sprintf("dept_%d_weekly", usage.DepartmentID)
    budget := bm.getBudget(deptBudgetID)
    
    if budget == nil {
        budget = bm.createDefaultDepartmentBudget(usage.DepartmentID)
    }
    
    return bm.validateUsageAgainstBudget(budget, usage.TotalCost)
}

func (bm *BudgetManager) validateUsageAgainstBudget(budget *Budget, cost decimal.Decimal) error {
    // æ£€æŸ¥é¢„ç®—æ˜¯å¦è¿‡æœŸ
    if time.Now().After(budget.EndTime) {
        return fmt.Errorf("é¢„ç®—å·²è¿‡æœŸ: %s", budget.ID)
    }
    
    // è®¡ç®—ä½¿ç”¨åçš„æ€»æˆæœ¬
    projectedUsed := budget.Used.Add(cost)
    projectedPercentage := projectedUsed.Div(budget.Amount).InexactFloat64()
    
    // æ£€æŸ¥ç¡¬é™åˆ¶
    if budget.Controls != nil && budget.Controls.EnableHardLimit {
        if projectedPercentage >= 1.0 {
            return fmt.Errorf("è¶…å‡ºç¡¬é¢„ç®—é™åˆ¶: %s, ä½¿ç”¨ç‡: %.2f%%", 
                budget.ID, projectedPercentage*100)
        }
    }
    
    // æ£€æŸ¥ç´§æ€¥åœæ­¢
    if budget.Controls != nil && budget.Controls.EnableEmergencyStop {
        if projectedPercentage >= budget.Controls.EmergencyThreshold {
            return fmt.Errorf("è§¦å‘ç´§æ€¥åœæ­¢: %s, ä½¿ç”¨ç‡: %.2f%%", 
                budget.ID, projectedPercentage*100)
        }
    }
    
    // æ£€æŸ¥é™æµ
    if budget.Controls != nil && budget.Controls.EnableAutoThrottle {
        if projectedPercentage >= budget.Controls.ThrottleThreshold {
            // æ£€æŸ¥å†·å´æœŸ
            if time.Since(budget.Controls.LastControlAction) < budget.Controls.CooldownPeriod {
                return fmt.Errorf("é¢„ç®—é™æµä¸­ï¼Œè¯·ç¨åé‡è¯•: %s", budget.ID)
            }
            
            // åº”ç”¨é™æµ
            return bm.applyThrottling(budget, cost)
        }
    }
    
    return nil
}

func (bm *BudgetManager) UpdateBudgetUsage(usage *UsageRecord) error {
    bm.mu.Lock()
    defer bm.mu.Unlock()
    
    // æ›´æ–°ç”¨æˆ·é¢„ç®—
    userBudgetID := fmt.Sprintf("user_%d_daily", usage.UserID)
    if err := bm.updateSingleBudget(userBudgetID, usage.TotalCost); err != nil {
        return err
    }
    
    // æ›´æ–°éƒ¨é—¨é¢„ç®—
    deptBudgetID := fmt.Sprintf("dept_%d_weekly", usage.DepartmentID)
    if err := bm.updateSingleBudget(deptBudgetID, usage.TotalCost); err != nil {
        return err
    }
    
    // æ›´æ–°å…¬å¸é¢„ç®—
    companyBudgetID := "company_monthly"
    if err := bm.updateSingleBudget(companyBudgetID, usage.TotalCost); err != nil {
        return err
    }
    
    return nil
}

func (bm *BudgetManager) updateSingleBudget(budgetID string, cost decimal.Decimal) error {
    budget, exists := bm.budgets[budgetID]
    if !exists {
        return fmt.Errorf("é¢„ç®—ä¸å­˜åœ¨: %s", budgetID)
    }
    
    // æ›´æ–°ä½¿ç”¨é‡
    budget.Used = budget.Used.Add(cost)
    budget.Remaining = budget.Amount.Sub(budget.Used)
    budget.UsagePercentage = budget.Used.Div(budget.Amount).InexactFloat64()
    budget.LastUpdated = time.Now()
    
    // æ›´æ–°é¢„ç®—çŠ¶æ€
    bm.updateBudgetStatus(budget)
    
    // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
    if budget.AlertEnabled {
        bm.checkBudgetAlerts(budget)
    }
    
    return nil
}

func (bm *BudgetManager) updateBudgetStatus(budget *Budget) {
    percentage := budget.UsagePercentage
    
    switch {
    case percentage >= 1.0:
        budget.Status = BudgetStatusExceeded
    case percentage >= 0.9:
        budget.Status = BudgetStatusCritical
    case percentage >= 0.8:
        budget.Status = BudgetStatusWarning
    default:
        budget.Status = BudgetStatusActive
    }
}

func (bm *BudgetManager) checkBudgetAlerts(budget *Budget) {
    for _, threshold := range budget.AlertThresholds {
        if budget.UsagePercentage >= threshold {
            alert := &CostAlert{
                Type:        AlertTypeBudget,
                Level:       bm.getAlertLevel(threshold),
                BudgetID:    budget.ID,
                Message:     fmt.Sprintf("é¢„ç®—ä½¿ç”¨ç‡è¾¾åˆ°%.1f%%", threshold*100),
                Threshold:   threshold,
                CurrentValue: budget.UsagePercentage,
                Timestamp:   time.Now(),
            }
            
            bm.alertManager.TriggerAlert(alert)
        }
    }
}

func (bm *BudgetManager) getBudget(budgetID string) *Budget {
    bm.mu.RLock()
    defer bm.mu.RUnlock()
    
    return bm.budgets[budgetID]
}

func (bm *BudgetManager) GetAllBudgets() map[string]*Budget {
    bm.mu.RLock()
    defer bm.mu.RUnlock()
    
    result := make(map[string]*Budget)
    for id, budget := range bm.budgets {
        result[id] = budget
    }
    
    return result
}

func (bm *BudgetManager) GetUserBudgets(userID int64) []*Budget {
    bm.mu.RLock()
    defer bm.mu.RUnlock()
    
    var result []*Budget
    for _, budget := range bm.budgets {
        if budget.Type == BudgetTypeUser && budget.EntityID == userID {
            result = append(result, budget)
        }
    }
    
    return result
}

func (bm *BudgetManager) createDefaultUserBudget(userID int64) *Budget {
    budget := &Budget{
        ID:       fmt.Sprintf("user_%d_daily", userID),
        Name:     fmt.Sprintf("ç”¨æˆ·%dæ—¥é¢„ç®—", userID),
        Type:     BudgetTypeUser,
        EntityID: userID,
        Amount:   decimal.NewFromFloat(5.0), // $5 daily
        Period:   BudgetPeriodDaily,
        Currency: "USD",
        AlertThresholds: []float64{0.8, 0.9, 0.95},
        AlertEnabled: true,
        Controls: &BudgetControls{
            EnableHardLimit:     true,
            EnableAutoThrottle:  true,
            ThrottleThreshold:   0.85,
            ThrottleRate:        0.5,
            EnableEmergencyStop: true,
            EmergencyThreshold:  0.95,
            CooldownPeriod:      5 * time.Minute,
        },
        Status: BudgetStatusActive,
    }
    
    bm.setBudgetPeriod(budget)
    bm.budgets[budget.ID] = budget
    
    return budget
}
```

---

## ğŸ“ˆ æˆæœ¬é¢„æµ‹æ¨¡å‹

### æ™ºèƒ½æˆæœ¬é¢„æµ‹

```go
// internal/cost/predictor.go
package cost

import (
    "context"
    "math"
    "sort"
    "time"
    
    "github.com/shopspring/decimal"
)

type CostPredictor struct {
    // å†å²æ•°æ®
    historicalData  []*CostDataPoint
    
    // é¢„æµ‹æ¨¡å‹
    trendModel      *TrendModel
    seasonalModel   *SeasonalModel
    regressionModel *RegressionModel
    
    // é…ç½®
    config          *PredictorConfig
    
    // ç¼“å­˜
    predictionCache map[string]*PredictionResult
}

type CostDataPoint struct {
    Timestamp    time.Time       `json:"timestamp"`
    Cost         decimal.Decimal `json:"cost"`
    Requests     int64           `json:"requests"`
    Tokens       int64           `json:"tokens"`
    UserID       int64           `json:"user_id,omitempty"`
    DepartmentID int64           `json:"department_id,omitempty"`
    Model        string          `json:"model,omitempty"`
}

type PredictionResult struct {
    // é¢„æµ‹ä¿¡æ¯
    PredictedCost     decimal.Decimal `json:"predicted_cost"`
    Confidence        float64         `json:"confidence"`
    PredictionRange   *PredictionRange `json:"prediction_range"`
    
    // è¶‹åŠ¿åˆ†æ
    Trend             string          `json:"trend"`           // increasing/decreasing/stable
    TrendStrength     float64         `json:"trend_strength"`  // 0-1
    
    // æ—¶é—´ä¿¡æ¯
    PredictionTime    time.Time       `json:"prediction_time"`
    PredictionPeriod  time.Duration   `json:"prediction_period"`
    
    // å› ç´ åˆ†æ
    CostFactors       []*CostFactor   `json:"cost_factors"`
    
    // å»ºè®®
    Recommendations   []string        `json:"recommendations"`
}

type PredictionRange struct {
    LowerBound  decimal.Decimal `json:"lower_bound"`
    UpperBound  decimal.Decimal `json:"upper_bound"`
    Probability float64         `json:"probability"`  // ç½®ä¿¡æ¦‚ç‡
}

type CostFactor struct {
    Name        string  `json:"name"`
    Impact      float64 `json:"impact"`      // å½±å“ç¨‹åº¦ (-1 to 1)
    Confidence  float64 `json:"confidence"`  // ä¿¡å¿ƒåº¦ (0 to 1)
    Description string  `json:"description"`
}

func NewCostPredictor(config *PredictorConfig) *CostPredictor {
    return &CostPredictor{
        historicalData:  make([]*CostDataPoint, 0),
        trendModel:      NewTrendModel(),
        seasonalModel:   NewSeasonalModel(),
        regressionModel: NewRegressionModel(),
        config:         config,
        predictionCache: make(map[string]*PredictionResult),
    }
}

func (cp *CostPredictor) PredictCost(
    ctx context.Context,
    userID int64,
    period time.Duration) (*PredictionResult, error) {
    
    // æ£€æŸ¥ç¼“å­˜
    cacheKey := fmt.Sprintf("user_%d_%s", userID, period.String())
    if cached := cp.predictionCache[cacheKey]; cached != nil {
        return cached, nil
    }
    
    // è·å–å†å²æ•°æ®
    historicalData := cp.getHistoricalData(userID, 30*24*time.Hour) // 30å¤©å†å²
    if len(historicalData) < 7 { // è‡³å°‘éœ€è¦7ä¸ªæ•°æ®ç‚¹
        return cp.generateDefaultPrediction(period), nil
    }
    
    // æ‰§è¡Œé¢„æµ‹
    result := &PredictionResult{
        PredictionTime:   time.Now(),
        PredictionPeriod: period,
        CostFactors:      make([]*CostFactor, 0),
        Recommendations:  make([]string, 0),
    }
    
    // 1. è¶‹åŠ¿åˆ†æ
    trend := cp.analyzeTrend(historicalData)
    result.Trend = trend.Direction
    result.TrendStrength = trend.Strength
    
    // 2. å­£èŠ‚æ€§åˆ†æ
    seasonal := cp.analyzeSeasonality(historicalData)
    
    // 3. å›å½’é¢„æµ‹
    regression := cp.performRegression(historicalData, period)
    
    // 4. ç»„åˆé¢„æµ‹
    result.PredictedCost = cp.combinePredictions(trend, seasonal, regression)
    
    // 5. è®¡ç®—ç½®ä¿¡åº¦å’ŒèŒƒå›´
    result.Confidence = cp.calculateConfidence(historicalData, result.PredictedCost)
    result.PredictionRange = cp.calculatePredictionRange(result.PredictedCost, result.Confidence)
    
    // 6. åˆ†ææˆæœ¬å› ç´ 
    result.CostFactors = cp.analyzeCostFactors(historicalData)
    
    // 7. ç”Ÿæˆå»ºè®®
    result.Recommendations = cp.generateRecommendations(result)
    
    // ç¼“å­˜ç»“æœ
    cp.predictionCache[cacheKey] = result
    
    return result, nil
}

func (cp *CostPredictor) analyzeTrend(data []*CostDataPoint) *TrendAnalysis {
    if len(data) < 2 {
        return &TrendAnalysis{Direction: "stable", Strength: 0.0}
    }
    
    // è®¡ç®—çº¿æ€§å›å½’æ–œç‡
    n := float64(len(data))
    sumX, sumY, sumXY, sumX2 := 0.0, 0.0, 0.0, 0.0
    
    for i, point := range data {
        x := float64(i)
        y := point.Cost.InexactFloat64()
        
        sumX += x
        sumY += y
        sumXY += x * y
        sumX2 += x * x
    }
    
    // è®¡ç®—æ–œç‡
    slope := (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)
    
    // åˆ¤æ–­è¶‹åŠ¿æ–¹å‘å’Œå¼ºåº¦
    direction := "stable"
    strength := math.Abs(slope)
    
    if slope > 0.01 {
        direction = "increasing"
    } else if slope < -0.01 {
        direction = "decreasing"
    }
    
    // å½’ä¸€åŒ–å¼ºåº¦å€¼
    strength = math.Min(strength*100, 1.0)
    
    return &TrendAnalysis{
        Direction: direction,
        Strength:  strength,
        Slope:     slope,
    }
}

func (cp *CostPredictor) analyzeSeasonality(data []*CostDataPoint) *SeasonalAnalysis {
    // åˆ†æå‘¨å†…æ¨¡å¼
    weeklyPattern := make(map[int][]decimal.Decimal) // æ˜ŸæœŸ -> æˆæœ¬åˆ—è¡¨
    
    // åˆ†æå°æ—¶æ¨¡å¼
    hourlyPattern := make(map[int][]decimal.Decimal) // å°æ—¶ -> æˆæœ¬åˆ—è¡¨
    
    for _, point := range data {
        weekday := int(point.Timestamp.Weekday())
        hour := point.Timestamp.Hour()
        
        weeklyPattern[weekday] = append(weeklyPattern[weekday], point.Cost)
        hourlyPattern[hour] = append(hourlyPattern[hour], point.Cost)
    }
    
    // è®¡ç®—å‘¨å†…å¹³å‡æˆæœ¬
    weeklyAvg := make(map[int]decimal.Decimal)
    for day, costs := range weeklyPattern {
        if len(costs) > 0 {
            sum := decimal.Zero
            for _, cost := range costs {
                sum = sum.Add(cost)
            }
            weeklyAvg[day] = sum.Div(decimal.NewFromInt(int64(len(costs))))
        }
    }
    
    // è®¡ç®—å°æ—¶å¹³å‡æˆæœ¬
    hourlyAvg := make(map[int]decimal.Decimal)
    for hour, costs := range hourlyPattern {
        if len(costs) > 0 {
            sum := decimal.Zero
            for _, cost := range costs {
                sum = sum.Add(cost)
            }
            hourlyAvg[hour] = sum.Div(decimal.NewFromInt(int64(len(costs))))
        }
    }
    
    return &SeasonalAnalysis{
        WeeklyPattern: weeklyAvg,
        HourlyPattern: hourlyAvg,
        HasWeeklyPattern: cp.detectPattern(weeklyPattern),
        HasHourlyPattern: cp.detectPattern(hourlyPattern),
    }
}

func (cp *CostPredictor) performRegression(data []*CostDataPoint, period time.Duration) *RegressionResult {
    if len(data) < 3 {
        return &RegressionResult{PredictedValue: decimal.Zero, Accuracy: 0.0}
    }
    
    // ä½¿ç”¨æœ€è¿‘çš„æ•°æ®ç‚¹è¿›è¡Œçº¿æ€§å›å½’
    recentData := data
    if len(data) > 14 { // åªä½¿ç”¨æœ€è¿‘14å¤©çš„æ•°æ®
        recentData = data[len(data)-14:]
    }
    
    // è®¡ç®—å¹³å‡æ—¥æˆæœ¬
    dailyCosts := cp.aggregateByDay(recentData)
    
    if len(dailyCosts) < 2 {
        return &RegressionResult{PredictedValue: decimal.Zero, Accuracy: 0.0}
    }
    
    // çº¿æ€§å›å½’é¢„æµ‹
    n := float64(len(dailyCosts))
    days := period.Hours() / 24 // é¢„æµ‹å¤©æ•°
    
    // è®¡ç®—å›å½’ç³»æ•°
    sumX, sumY, sumXY, sumX2 := 0.0, 0.0, 0.0, 0.0
    for i, cost := range dailyCosts {
        x := float64(i)
        y := cost.InexactFloat64()
        
        sumX += x
        sumY += y
        sumXY += x * y
        sumX2 += x * x
    }
    
    slope := (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)
    intercept := (sumY - slope*sumX) / n
    
    // é¢„æµ‹å€¼
    predictedDaily := slope*n + intercept
    predictedTotal := predictedDaily * days
    
    // è®¡ç®—å‡†ç¡®åº¦ï¼ˆåŸºäºå†å²æ‹Ÿåˆåº¦ï¼‰
    accuracy := cp.calculateRegressionAccuracy(dailyCosts, slope, intercept)
    
    return &RegressionResult{
        PredictedValue: decimal.NewFromFloat(math.Max(predictedTotal, 0)),
        Accuracy:      accuracy,
        Slope:         slope,
        Intercept:     intercept,
    }
}

func (cp *CostPredictor) combinePredictions(
    trend *TrendAnalysis,
    seasonal *SeasonalAnalysis,
    regression *RegressionResult) decimal.Decimal {
    
    // åŸºç¡€é¢„æµ‹å€¼æ¥è‡ªå›å½’
    basePrediction := regression.PredictedValue
    
    // è¶‹åŠ¿è°ƒæ•´
    trendAdjustment := 1.0
    if trend.Direction == "increasing" {
        trendAdjustment = 1.0 + trend.Strength*0.2 // æœ€å¤§20%å¢é•¿è°ƒæ•´
    } else if trend.Direction == "decreasing" {
        trendAdjustment = 1.0 - trend.Strength*0.2 // æœ€å¤§20%ä¸‹é™è°ƒæ•´
    }
    
    // åº”ç”¨è°ƒæ•´
    adjustedPrediction := basePrediction.Mul(decimal.NewFromFloat(trendAdjustment))
    
    return adjustedPrediction
}

func (cp *CostPredictor) calculateConfidence(
    data []*CostDataPoint,
    prediction decimal.Decimal) float64 {
    
    if len(data) < 3 {
        return 0.5 // ä½ç½®ä¿¡åº¦
    }
    
    // è®¡ç®—å†å²æ•°æ®çš„å˜å¼‚ç³»æ•°
    costs := make([]float64, len(data))
    sum := 0.0
    
    for i, point := range data {
        cost := point.Cost.InexactFloat64()
        costs[i] = cost
        sum += cost
    }
    
    mean := sum / float64(len(costs))
    
    // è®¡ç®—æ ‡å‡†å·®
    variance := 0.0
    for _, cost := range costs {
        variance += math.Pow(cost-mean, 2)
    }
    stdDev := math.Sqrt(variance / float64(len(costs)))
    
    // å˜å¼‚ç³»æ•°
    cv := stdDev / mean
    
    // ç½®ä¿¡åº¦ä¸å˜å¼‚ç³»æ•°æˆåæ¯”
    confidence := 1.0 / (1.0 + cv)
    
    // æ•°æ®é‡è°ƒæ•´
    dataQualityFactor := math.Min(float64(len(data))/30.0, 1.0) // 30å¤©ä¸ºæ»¡åˆ†
    
    return confidence * dataQualityFactor
}

func (cp *CostPredictor) generateRecommendations(result *PredictionResult) []string {
    var recommendations []string
    
    // åŸºäºè¶‹åŠ¿çš„å»ºè®®
    if result.Trend == "increasing" && result.TrendStrength > 0.5 {
        recommendations = append(recommendations, 
            "æˆæœ¬å‘ˆä¸Šå‡è¶‹åŠ¿ï¼Œå»ºè®®ä¼˜åŒ–æ¨¡å‹é€‰æ‹©ç­–ç•¥æˆ–å¢åŠ ç¼“å­˜ä½¿ç”¨")
    }
    
    // åŸºäºé¢„æµ‹æˆæœ¬çš„å»ºè®®
    if result.Confidence > 0.8 {
        recommendations = append(recommendations,
            "é¢„æµ‹ç½®ä¿¡åº¦è¾ƒé«˜ï¼Œå»ºè®®æŒ‰é¢„æµ‹ç»“æœåˆ¶å®šé¢„ç®—è®¡åˆ’")
    } else {
        recommendations = append(recommendations,
            "é¢„æµ‹ä¸ç¡®å®šæ€§è¾ƒå¤§ï¼Œå»ºè®®å¢åŠ ç›‘æ§é¢‘ç‡å¹¶å‡†å¤‡åº”æ€¥é¢„ç®—")
    }
    
    // åŸºäºæˆæœ¬å› ç´ çš„å»ºè®®
    for _, factor := range result.CostFactors {
        if factor.Impact > 0.3 && factor.Confidence > 0.7 {
            recommendations = append(recommendations,
                fmt.Sprintf("å…³æ³¨%så¯¹æˆæœ¬çš„å½±å“ï¼Œè€ƒè™‘ç›¸åº”ä¼˜åŒ–æªæ–½", factor.Name))
        }
    }
    
    return recommendations
}
```

---

## ğŸš¨ å‘Šè­¦ç³»ç»Ÿ

### æ™ºèƒ½æˆæœ¬å‘Šè­¦

```go
// internal/cost/alert_manager.go
package cost

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type AlertManager struct {
    // å‘Šè­¦è§„åˆ™
    rules           map[string]*AlertRule
    
    // å‘Šè­¦çŠ¶æ€
    activeAlerts    map[string]*Alert
    alertHistory    []*Alert
    
    // é€šçŸ¥å™¨
    notifiers       []AlertNotifier
    
    // é…ç½®
    config          *AlertConfig
    
    // å¹¶å‘æ§åˆ¶
    mu              sync.RWMutex
}

type AlertRule struct {
    ID              string          `json:"id"`
    Name            string          `json:"name"`
    Type            AlertType       `json:"type"`
    Condition       *AlertCondition `json:"condition"`
    Actions         []AlertAction   `json:"actions"`
    Enabled         bool           `json:"enabled"`
    Cooldown        time.Duration  `json:"cooldown"`
    LastTriggered   time.Time      `json:"last_triggered"`
}

type AlertCondition struct {
    Metric          string          `json:"metric"`          // cost_per_hour, budget_usage, etc.
    Operator        string          `json:"operator"`        // >, <, >=, <=, ==
    Threshold       float64         `json:"threshold"`       // é˜ˆå€¼
    Duration        time.Duration   `json:"duration"`        // æŒç»­æ—¶é—´
    Aggregation     string          `json:"aggregation"`     // sum, avg, max, min
}

type AlertAction struct {
    Type            string                 `json:"type"`            // notify, throttle, stop
    Parameters      map[string]interface{} `json:"parameters"`
}

type Alert struct {
    ID              string          `json:"id"`
    RuleID          string          `json:"rule_id"`
    Type            AlertType       `json:"type"`
    Level           AlertLevel      `json:"level"`
    Title           string          `json:"title"`
    Message         string          `json:"message"`
    
    // ä¸Šä¸‹æ–‡ä¿¡æ¯
    EntityType      string          `json:"entity_type"`     // user, department, company
    EntityID        int64           `json:"entity_id"`
    
    // å‘Šè­¦æ•°æ®
    CurrentValue    float64         `json:"current_value"`
    ThresholdValue  float64         `json:"threshold_value"`
    
    // æ—¶é—´ä¿¡æ¯
    StartTime       time.Time       `json:"start_time"`
    LastUpdate      time.Time       `json:"last_update"`
    ResolvedTime    *time.Time      `json:"resolved_time,omitempty"`
    
    // çŠ¶æ€
    Status          AlertStatus     `json:"status"`
    
    // å…ƒæ•°æ®
    Labels          map[string]string      `json:"labels"`
    Annotations     map[string]string      `json:"annotations"`
}

type AlertType string
type AlertLevel string  
type AlertStatus string

const (
    AlertTypeCost      AlertType = "cost"
    AlertTypeBudget    AlertType = "budget"
    AlertTypeUsage     AlertType = "usage"
    AlertTypeQuota     AlertType = "quota"
    
    AlertLevelInfo     AlertLevel = "info"
    AlertLevelWarning  AlertLevel = "warning"
    AlertLevelCritical AlertLevel = "critical"
    AlertLevelEmergency AlertLevel = "emergency"
    
    AlertStatusFiring   AlertStatus = "firing"
    AlertStatusResolved AlertStatus = "resolved"
    AlertStatusSilenced AlertStatus = "silenced"
)

func NewAlertManager(config *AlertConfig) *AlertManager {
    am := &AlertManager{
        rules:        make(map[string]*AlertRule),
        activeAlerts: make(map[string]*Alert),
        alertHistory: make([]*Alert, 0),
        config:       config,
        notifiers:    make([]AlertNotifier, 0),
    }
    
    // åŠ è½½é»˜è®¤å‘Šè­¦è§„åˆ™
    am.loadDefaultRules()
    
    // å¯åŠ¨å‘Šè­¦æ£€æŸ¥
    go am.startAlertMonitoring()
    
    return am
}

func (am *AlertManager) loadDefaultRules() {
    // é«˜æˆæœ¬å‘Šè­¦è§„åˆ™
    am.AddRule(&AlertRule{
        ID:   "high_hourly_cost",
        Name: "å°æ—¶æˆæœ¬è¿‡é«˜",
        Type: AlertTypeCost,
        Condition: &AlertCondition{
            Metric:      "cost_per_hour",
            Operator:    ">",
            Threshold:   10.0, // $10/hour
            Duration:    5 * time.Minute,
            Aggregation: "sum",
        },
        Actions: []AlertAction{
            {Type: "notify", Parameters: map[string]interface{}{"channel": "cost-alerts"}},
            {Type: "throttle", Parameters: map[string]interface{}{"rate": 0.5}},
        },
        Enabled:  true,
        Cooldown: 15 * time.Minute,
    })
    
    // é¢„ç®—å‘Šè­¦è§„åˆ™
    am.AddRule(&AlertRule{
        ID:   "budget_warning",
        Name: "é¢„ç®—ä½¿ç”¨è­¦å‘Š",
        Type: AlertTypeBudget,
        Condition: &AlertCondition{
            Metric:      "budget_usage_percentage",
            Operator:    ">=",
            Threshold:   80.0, // 80%
            Duration:    1 * time.Minute,
            Aggregation: "max",
        },
        Actions: []AlertAction{
            {Type: "notify", Parameters: map[string]interface{}{"channel": "budget-alerts"}},
        },
        Enabled:  true,
        Cooldown: 30 * time.Minute,
    })
    
    // ç´§æ€¥é¢„ç®—å‘Šè­¦
    am.AddRule(&AlertRule{
        ID:   "budget_critical",
        Name: "é¢„ç®—ä¸´ç•Œè­¦å‘Š", 
        Type: AlertTypeBudget,
        Condition: &AlertCondition{
            Metric:      "budget_usage_percentage",
            Operator:    ">=",
            Threshold:   95.0, // 95%
            Duration:    30 * time.Second,
            Aggregation: "max",
        },
        Actions: []AlertAction{
            {Type: "notify", Parameters: map[string]interface{}{"channel": "emergency-alerts"}},
            {Type: "stop", Parameters: map[string]interface{}{"grace_period": "5m"}},
        },
        Enabled:  true,
        Cooldown: 5 * time.Minute,
    })
}

func (am *AlertManager) TriggerAlert(alert *Alert) error {
    am.mu.Lock()
    defer am.mu.Unlock()
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå‘Šè­¦
    existingAlert := am.findExistingAlert(alert)
    if existingAlert != nil {
        // æ›´æ–°ç°æœ‰å‘Šè­¦
        existingAlert.LastUpdate = time.Now()
        existingAlert.CurrentValue = alert.CurrentValue
        return nil
    }
    
    // åˆ›å»ºæ–°å‘Šè­¦
    alert.ID = fmt.Sprintf("%s_%d", alert.Type, time.Now().UnixNano())
    alert.StartTime = time.Now()
    alert.LastUpdate = time.Now()
    alert.Status = AlertStatusFiring
    
    // å­˜å‚¨å‘Šè­¦
    am.activeAlerts[alert.ID] = alert
    am.alertHistory = append(am.alertHistory, alert)
    
    // æ‰§è¡Œå‘Šè­¦åŠ¨ä½œ
    go am.executeAlertActions(alert)
    
    return nil
}

func (am *AlertManager) executeAlertActions(alert *Alert) {
    // æŸ¥æ‰¾å¯¹åº”çš„è§„åˆ™
    rule := am.findRuleByType(alert.Type)
    if rule == nil {
        return
    }
    
    // æ£€æŸ¥å†·å´æœŸ
    if time.Since(rule.LastTriggered) < rule.Cooldown {
        return
    }
    
    // æ›´æ–°è§¦å‘æ—¶é—´
    rule.LastTriggered = time.Now()
    
    // æ‰§è¡ŒåŠ¨ä½œ
    for _, action := range rule.Actions {
        switch action.Type {
        case "notify":
            am.sendNotification(alert, action.Parameters)
        case "throttle":
            am.applyThrottling(alert, action.Parameters)
        case "stop":
            am.applyEmergencyStop(alert, action.Parameters)
        }
    }
}

func (am *AlertManager) sendNotification(alert *Alert, params map[string]interface{}) {
    for _, notifier := range am.notifiers {
        notification := &AlertNotification{
            Alert:     alert,
            Channel:   params["channel"].(string),
            Message:   am.formatAlertMessage(alert),
            Timestamp: time.Now(),
        }
        
        if err := notifier.Send(notification); err != nil {
            log.Error("å‘Šè­¦é€šçŸ¥å‘é€å¤±è´¥", 
                zap.String("alert_id", alert.ID),
                zap.Error(err))
        }
    }
}

func (am *AlertManager) formatAlertMessage(alert *Alert) string {
    switch alert.Type {
    case AlertTypeCost:
        return fmt.Sprintf("ğŸš¨ æˆæœ¬å‘Šè­¦ï¼š%s\nå½“å‰å€¼ï¼š$%.2f\né˜ˆå€¼ï¼š$%.2f\næ—¶é—´ï¼š%s",
            alert.Title, alert.CurrentValue, alert.ThresholdValue, 
            alert.StartTime.Format("2006-01-02 15:04:05"))
            
    case AlertTypeBudget:
        return fmt.Sprintf("ğŸ’° é¢„ç®—å‘Šè­¦ï¼š%s\nä½¿ç”¨ç‡ï¼š%.1f%%\né˜ˆå€¼ï¼š%.1f%%\næ—¶é—´ï¼š%s",
            alert.Title, alert.CurrentValue, alert.ThresholdValue,
            alert.StartTime.Format("2006-01-02 15:04:05"))
            
    default:
        return fmt.Sprintf("ğŸ“¢ ç³»ç»Ÿå‘Šè­¦ï¼š%s\nè¯¦æƒ…ï¼š%s\næ—¶é—´ï¼š%s",
            alert.Title, alert.Message, 
            alert.StartTime.Format("2006-01-02 15:04:05"))
    }
}

func (am *AlertManager) ResolveAlert(alertID string, reason string) error {
    am.mu.Lock()
    defer am.mu.Unlock()
    
    alert, exists := am.activeAlerts[alertID]
    if !exists {
        return fmt.Errorf("å‘Šè­¦ä¸å­˜åœ¨: %s", alertID)
    }
    
    now := time.Now()
    alert.Status = AlertStatusResolved
    alert.ResolvedTime = &now
    alert.LastUpdate = now
    
    if alert.Annotations == nil {
        alert.Annotations = make(map[string]string)
    }
    alert.Annotations["resolution_reason"] = reason
    
    // ä»æ´»è·ƒå‘Šè­¦ä¸­ç§»é™¤
    delete(am.activeAlerts, alertID)
    
    return nil
}

func (am *AlertManager) GetActiveAlerts() []*Alert {
    am.mu.RLock()
    defer am.mu.RUnlock()
    
    alerts := make([]*Alert, 0, len(am.activeAlerts))
    for _, alert := range am.activeAlerts {
        alerts = append(alerts, alert)
    }
    
    return alerts
}

func (am *AlertManager) GetAlertHistory(limit int) []*Alert {
    am.mu.RLock()
    defer am.mu.RUnlock()
    
    if limit <= 0 || limit > len(am.alertHistory) {
        limit = len(am.alertHistory)
    }
    
    start := len(am.alertHistory) - limit
    return am.alertHistory[start:]
}

// å‘Šè­¦é€šçŸ¥æ¥å£
type AlertNotifier interface {
    Send(notification *AlertNotification) error
}

type AlertNotification struct {
    Alert     *Alert
    Channel   string
    Message   string
    Timestamp time.Time
}

// é‚®ä»¶é€šçŸ¥å™¨
type EmailNotifier struct {
    smtpConfig *SMTPConfig
}

func (en *EmailNotifier) Send(notification *AlertNotification) error {
    // å®ç°é‚®ä»¶å‘é€é€»è¾‘
    return nil
}

// Slacké€šçŸ¥å™¨
type SlackNotifier struct {
    webhookURL string
}

func (sn *SlackNotifier) Send(notification *AlertNotification) error {
    // å®ç°Slacké€šçŸ¥é€»è¾‘
    return nil
}

// å¾®ä¿¡é€šçŸ¥å™¨
type WeChatNotifier struct {
    corpID     string
    corpSecret string
}

func (wn *WeChatNotifier) Send(notification *AlertNotification) error {
    // å®ç°å¾®ä¿¡é€šçŸ¥é€»è¾‘
    return nil
}
```

---

## ğŸ“Š æˆæœ¬åˆ†ææŠ¥å‘Š

### æ™ºèƒ½æˆæœ¬åˆ†æ

```go
// internal/cost/analyzer.go
package cost

import (
    "context"
    "fmt"
    "sort"
    "time"
    
    "github.com/shopspring/decimal"
)

type CostAnalyzer struct {
    storage        *CostStorage
    usageTracker   *UsageTracker
    config         *AnalyzerConfig
}

type CostReport struct {
    // åŸºç¡€ä¿¡æ¯
    ReportID       string          `json:"report_id"`
    Title          string          `json:"title"`
    Period         *ReportPeriod   `json:"period"`
    GeneratedAt    time.Time       `json:"generated_at"`
    
    // æ€»ä½“ç»Ÿè®¡
    Summary        *CostSummary    `json:"summary"`
    
    // è¯¦ç»†åˆ†æ
    TrendAnalysis  *TrendAnalysis  `json:"trend_analysis"`
    ModelAnalysis  *ModelAnalysis  `json:"model_analysis"`
    UserAnalysis   *UserAnalysis   `json:"user_analysis"`
    
    // æˆæœ¬ä¼˜åŒ–
    Optimization   *OptimizationAnalysis `json:"optimization"`
    
    // é¢„æµ‹å’Œå»ºè®®
    Forecast       *CostForecast   `json:"forecast"`
    Recommendations []string       `json:"recommendations"`
}

type CostSummary struct {
    TotalCost         decimal.Decimal `json:"total_cost"`
    TotalRequests     int64           `json:"total_requests"`
    TotalTokens       int64           `json:"total_tokens"`
    AvgCostPerRequest decimal.Decimal `json:"avg_cost_per_request"`
    AvgCostPerToken   decimal.Decimal `json:"avg_cost_per_token"`
    
    // åŒæ¯”æ•°æ®
    PreviousPeriodCost decimal.Decimal `json:"previous_period_cost"`
    CostChange        decimal.Decimal  `json:"cost_change"`
    CostChangePercent float64          `json:"cost_change_percent"`
    
    // é¢„ç®—å¯¹æ¯”
    BudgetAllocated   decimal.Decimal `json:"budget_allocated"`
    BudgetUsed        decimal.Decimal `json:"budget_used"`
    BudgetRemaining   decimal.Decimal `json:"budget_remaining"`
    BudgetUtilization float64         `json:"budget_utilization"`
}

type ModelAnalysis struct {
    ModelCosts     []*ModelCostBreakdown `json:"model_costs"`
    TopModels      []*ModelUsageRank     `json:"top_models"`
    CostEfficiency []*ModelEfficiency    `json:"cost_efficiency"`
}

type ModelCostBreakdown struct {
    Model           string          `json:"model"`
    Provider        string          `json:"provider"`
    TotalCost       decimal.Decimal `json:"total_cost"`
    Requests        int64           `json:"requests"`
    Tokens          int64           `json:"tokens"`
    AvgCostPerReq   decimal.Decimal `json:"avg_cost_per_request"`
    CostPercentage  float64         `json:"cost_percentage"`
}

type OptimizationAnalysis struct {
    PotentialSavings decimal.Decimal `json:"potential_savings"`
    OptimizationOps  []*OptimizationOpportunity `json:"optimization_opportunities"`
    CacheImpact      *CacheImpactAnalysis `json:"cache_impact"`
    RoutingImpact    *RoutingImpactAnalysis `json:"routing_impact"`
}

type OptimizationOpportunity struct {
    Type            string          `json:"type"`
    Description     string          `json:"description"`
    PotentialSaving decimal.Decimal `json:"potential_saving"`
    Confidence      float64         `json:"confidence"`
    Implementation  string          `json:"implementation"`
    Priority        string          `json:"priority"`
}

func NewCostAnalyzer(storage *CostStorage, tracker *UsageTracker) *CostAnalyzer {
    return &CostAnalyzer{
        storage:      storage,
        usageTracker: tracker,
    }
}

func (ca *CostAnalyzer) GenerateReport(
    ctx context.Context,
    period *ReportPeriod,
    scope *ReportScope) (*CostReport, error) {
    
    report := &CostReport{
        ReportID:    fmt.Sprintf("cost_report_%d", time.Now().Unix()),
        Title:       fmt.Sprintf("æˆæœ¬åˆ†ææŠ¥å‘Š - %s", period.Description),
        Period:      period,
        GeneratedAt: time.Now(),
    }
    
    // è·å–æ•°æ®
    data, err := ca.collectData(ctx, period, scope)
    if err != nil {
        return nil, err
    }
    
    // ç”Ÿæˆå„éƒ¨åˆ†åˆ†æ
    report.Summary = ca.generateSummary(data, period)
    report.TrendAnalysis = ca.analyzeTrend(data)
    report.ModelAnalysis = ca.analyzeModels(data)
    report.UserAnalysis = ca.analyzeUsers(data)
    report.Optimization = ca.analyzeOptimization(data)
    report.Forecast = ca.generateForecast(data, period)
    report.Recommendations = ca.generateRecommendations(report)
    
    return report, nil
}

func (ca *CostAnalyzer) generateSummary(data []*UsageRecord, period *ReportPeriod) *CostSummary {
    summary := &CostSummary{}
    
    // è®¡ç®—æ€»ä½“ç»Ÿè®¡
    for _, record := range data {
        summary.TotalCost = summary.TotalCost.Add(record.TotalCost)
        summary.TotalRequests++
        summary.TotalTokens += int64(record.TotalTokens)
    }
    
    // è®¡ç®—å¹³å‡å€¼
    if summary.TotalRequests > 0 {
        summary.AvgCostPerRequest = summary.TotalCost.Div(
            decimal.NewFromInt(summary.TotalRequests))
    }
    
    if summary.TotalTokens > 0 {
        summary.AvgCostPerToken = summary.TotalCost.Div(
            decimal.NewFromInt(summary.TotalTokens))
    }
    
    // è·å–å¯¹æ¯”æ•°æ®
    previousData := ca.getPreviousPeriodData(period)
    if len(previousData) > 0 {
        for _, record := range previousData {
            summary.PreviousPeriodCost = summary.PreviousPeriodCost.Add(record.TotalCost)
        }
        
        summary.CostChange = summary.TotalCost.Sub(summary.PreviousPeriodCost)
        if !summary.PreviousPeriodCost.IsZero() {
            summary.CostChangePercent = summary.CostChange.Div(
                summary.PreviousPeriodCost).InexactFloat64() * 100
        }
    }
    
    return summary
}

func (ca *CostAnalyzer) analyzeModels(data []*UsageRecord) *ModelAnalysis {
    // æŒ‰æ¨¡å‹ç»Ÿè®¡
    modelStats := make(map[string]*ModelCostBreakdown)
    totalCost := decimal.Zero
    
    for _, record := range data {
        model := record.Model
        if _, exists := modelStats[model]; !exists {
            modelStats[model] = &ModelCostBreakdown{
                Model:    model,
                Provider: record.Provider,
            }
        }
        
        stats := modelStats[model]
        stats.TotalCost = stats.TotalCost.Add(record.TotalCost)
        stats.Requests++
        stats.Tokens += int64(record.TotalTokens)
        
        totalCost = totalCost.Add(record.TotalCost)
    }
    
    // è½¬æ¢ä¸ºåˆ‡ç‰‡å¹¶è®¡ç®—ç™¾åˆ†æ¯”
    var modelCosts []*ModelCostBreakdown
    for _, stats := range modelStats {
        if stats.Requests > 0 {
            stats.AvgCostPerReq = stats.TotalCost.Div(
                decimal.NewFromInt(stats.Requests))
        }
        
        if !totalCost.IsZero() {
            stats.CostPercentage = stats.TotalCost.Div(totalCost).InexactFloat64() * 100
        }
        
        modelCosts = append(modelCosts, stats)
    }
    
    // æŒ‰æˆæœ¬æ’åº
    sort.Slice(modelCosts, func(i, j int) bool {
        return modelCosts[i].TotalCost.GreaterThan(modelCosts[j].TotalCost)
    })
    
    return &ModelAnalysis{
        ModelCosts: modelCosts,
        TopModels:  ca.getTopModels(modelCosts, 5),
        CostEfficiency: ca.calculateModelEfficiency(modelCosts),
    }
}

func (ca *CostAnalyzer) analyzeOptimization(data []*UsageRecord) *OptimizationAnalysis {
    optimization := &OptimizationAnalysis{
        OptimizationOps: make([]*OptimizationOpportunity, 0),
    }
    
    // åˆ†æç¼“å­˜ä¼˜åŒ–æœºä¼š
    cacheOpportunity := ca.analyzeCacheOptimization(data)
    if cacheOpportunity != nil {
        optimization.OptimizationOps = append(optimization.OptimizationOps, cacheOpportunity)
        optimization.PotentialSavings = optimization.PotentialSavings.Add(
            cacheOpportunity.PotentialSaving)
    }
    
    // åˆ†ææ¨¡å‹è·¯ç”±ä¼˜åŒ–
    routingOpportunity := ca.analyzeRoutingOptimization(data)
    if routingOpportunity != nil {
        optimization.OptimizationOps = append(optimization.OptimizationOps, routingOpportunity)
        optimization.PotentialSavings = optimization.PotentialSavings.Add(
            routingOpportunity.PotentialSaving)
    }
    
    // åˆ†æé¢„ç®—ä¼˜åŒ–
    budgetOpportunity := ca.analyzeBudgetOptimization(data)
    if budgetOpportunity != nil {
        optimization.OptimizationOps = append(optimization.OptimizationOps, budgetOpportunity)
    }
    
    return optimization
}

func (ca *CostAnalyzer) analyzeCacheOptimization(data []*UsageRecord) *OptimizationOpportunity {
    // è®¡ç®—é‡å¤æŸ¥è¯¢
    queryFreq := make(map[string]int)
    totalCost := decimal.Zero
    
    for _, record := range data {
        queryFreq[record.Query]++
        totalCost = totalCost.Add(record.TotalCost)
    }
    
    // æ‰¾å‡ºé‡å¤æŸ¥è¯¢çš„æˆæœ¬
    duplicateCost := decimal.Zero
    for query, freq := range queryFreq {
        if freq > 1 {
            // ä¼°ç®—è¿™äº›é‡å¤æŸ¥è¯¢çš„æˆæœ¬
            for _, record := range data {
                if record.Query == query {
                    duplicateCost = duplicateCost.Add(record.TotalCost)
                    break
                }
            }
            duplicateCost = duplicateCost.Mul(decimal.NewFromInt(int64(freq - 1)))
        }
    }
    
    if duplicateCost.GreaterThan(decimal.Zero) {
        // å‡è®¾ç¼“å­˜å¯ä»¥èŠ‚çœ80%çš„é‡å¤æŸ¥è¯¢æˆæœ¬
        potentialSaving := duplicateCost.Mul(decimal.NewFromFloat(0.8))
        
        return &OptimizationOpportunity{
            Type:            "cache_optimization",
            Description:     "é€šè¿‡æå‡ç¼“å­˜å‘½ä¸­ç‡å‡å°‘é‡å¤æŸ¥è¯¢æˆæœ¬",
            PotentialSaving: potentialSaving,
            Confidence:      0.8,
            Implementation:  "ä¼˜åŒ–ç¼“å­˜ç­–ç•¥ï¼Œå¢åŠ ç›¸ä¼¼æŸ¥è¯¢åŒ¹é…",
            Priority:        "high",
        }
    }
    
    return nil
}

func (ca *CostAnalyzer) generateRecommendations(report *CostReport) []string {
    var recommendations []string
    
    // åŸºäºæˆæœ¬è¶‹åŠ¿çš„å»ºè®®
    if report.TrendAnalysis.Direction == "increasing" && 
       report.TrendAnalysis.Strength > 0.5 {
        recommendations = append(recommendations,
            "æˆæœ¬å‘ˆæ˜æ˜¾ä¸Šå‡è¶‹åŠ¿ï¼Œå»ºè®®ç«‹å³æ£€æŸ¥æˆæœ¬æ§åˆ¶ç­–ç•¥")
    }
    
    // åŸºäºæ¨¡å‹ä½¿ç”¨çš„å»ºè®®
    if len(report.ModelAnalysis.ModelCosts) > 0 {
        topModel := report.ModelAnalysis.ModelCosts[0]
        if topModel.CostPercentage > 60 {
            recommendations = append(recommendations,
                fmt.Sprintf("æ¨¡å‹%så ç”¨æˆæœ¬è¿‡é«˜(%.1f%%)ï¼Œå»ºè®®è¯„ä¼°æ˜¯å¦å¯ç”¨æ›´ç»æµçš„æ›¿ä»£æ¨¡å‹",
                    topModel.Model, topModel.CostPercentage))
        }
    }
    
    // åŸºäºä¼˜åŒ–æœºä¼šçš„å»ºè®®
    for _, opp := range report.Optimization.OptimizationOps {
        if opp.Confidence > 0.7 && opp.Priority == "high" {
            recommendations = append(recommendations, opp.Implementation)
        }
    }
    
    // åŸºäºé¢„ç®—ä½¿ç”¨çš„å»ºè®®
    if report.Summary.BudgetUtilization > 0.9 {
        recommendations = append(recommendations,
            "é¢„ç®—ä½¿ç”¨ç‡è¿‡é«˜ï¼Œå»ºè®®å¢åŠ é¢„ç®—æˆ–ä¼˜åŒ–ä½¿ç”¨ç­–ç•¥")
    }
    
    return recommendations
}
```

---

## ğŸ› ï¸ é…ç½®å’Œéƒ¨ç½²

### æˆæœ¬æ§åˆ¶é…ç½®ç¤ºä¾‹

```yaml
# config/cost_config.yaml
cost_control:
  # é¢„ç®—é…ç½®
  budgets:
    user_daily: "5.00"
    department_weekly: "500.00" 
    company_monthly: "10000.00"
    
  # å‘Šè­¦é˜ˆå€¼
  alert_thresholds:
    warning: 0.8
    critical: 0.9
    emergency: 0.95
    
  # æ§åˆ¶ç­–ç•¥
  controls:
    enable_auto_limit: true
    enable_emergency_stop: true
    grace_period: "5m"
    cooldown_period: "1h"
    
  # æ¨¡å‹æˆæœ¬é…ç½®
  model_costs:
    gpt-4o-mini:
      input_cost_per_1k: "0.150"
      output_cost_per_1k: "0.600"
      provider: "openai"
      last_updated: "2025-01-01T00:00:00Z"
      
    claude-3.5-sonnet:
      input_cost_per_1k: "3.000"
      output_cost_per_1k: "15.000"
      provider: "anthropic"
      last_updated: "2025-01-01T00:00:00Z"
      
    deepseek-coder:
      input_cost_per_1k: "0.140"
      output_cost_per_1k: "0.280"
      provider: "deepseek"
      last_updated: "2025-01-01T00:00:00Z"
      
    ollama-llama3:
      input_cost_per_1k: "0.000"
      output_cost_per_1k: "0.000"
      provider: "ollama"
      last_updated: "2025-01-01T00:00:00Z"
      
# å‘Šè­¦é…ç½®
alerts:
  # é€šçŸ¥æ¸ é“
  notifiers:
    - type: "email"
      config:
        smtp_host: "smtp.company.com"
        smtp_port: 587
        from: "alerts@company.com"
        to: ["admin@company.com"]
        
    - type: "slack"
      config:
        webhook_url: "${SLACK_WEBHOOK_URL}"
        channel: "#cost-alerts"
        
    - type: "wechat"
      config:
        corp_id: "${WECHAT_CORP_ID}"
        corp_secret: "${WECHAT_CORP_SECRET}"
        
  # å‘Šè­¦è§„åˆ™
  rules:
    - id: "daily_cost_limit"
      name: "æ¯æ—¥æˆæœ¬é™åˆ¶"
      metric: "daily_cost"
      threshold: 100.0
      operator: ">"
      actions: ["notify", "throttle"]
      
    - id: "budget_warning"
      name: "é¢„ç®—è­¦å‘Š"
      metric: "budget_usage"
      threshold: 0.8
      operator: ">="
      actions: ["notify"]
      
# æ•°æ®å­˜å‚¨é…ç½®
storage:
  # PostgreSQLé…ç½®
  postgres:
    host: "localhost"
    port: 5432
    database: "chat2sql_cost"
    username: "${POSTGRES_USER}"
    password: "${POSTGRES_PASSWORD}"
    
  # æ•°æ®ä¿ç•™ç­–ç•¥
  retention:
    usage_records: "90d"    # ä½¿ç”¨è®°å½•ä¿ç•™90å¤©
    alerts: "30d"           # å‘Šè­¦è®°å½•ä¿ç•™30å¤©
    reports: "365d"         # æŠ¥å‘Šä¿ç•™1å¹´
```

### éƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# deploy/deploy_cost_control.sh

set -e

echo "ğŸ’° éƒ¨ç½²æˆæœ¬æ§åˆ¶ç³»ç»Ÿ..."

# 1. åˆ›å»ºæ•°æ®åº“
echo "ğŸ“Š åˆå§‹åŒ–æ•°æ®åº“..."
psql -h localhost -U postgres -c "CREATE DATABASE IF NOT EXISTS chat2sql_cost;"

# æ‰§è¡Œæ•°æ®åº“è¿ç§»
migrate -path migrations -database "postgres://postgres:password@localhost/chat2sql_cost?sslmode=disable" up

# 2. éƒ¨ç½²é…ç½®æ–‡ä»¶
echo "âš™ï¸ éƒ¨ç½²é…ç½®æ–‡ä»¶..."
cp config/cost_config.yaml /etc/chat2sql/

# 3. å¯åŠ¨æˆæœ¬æ§åˆ¶æœåŠ¡
echo "ğŸ”§ å¯åŠ¨æˆæœ¬æ§åˆ¶æœåŠ¡..."
./bin/cost-controller \
  --config=/etc/chat2sql/cost_config.yaml \
  --log-level=info \
  --metrics-port=9091

echo "âœ… æˆæœ¬æ§åˆ¶ç³»ç»Ÿéƒ¨ç½²å®Œæˆï¼"
echo "ğŸ’° æˆæœ¬API: http://localhost:8081/api/v1/cost"
echo "ğŸ“Š ç›‘æ§é¢æ¿: http://localhost:9091/metrics"
```

---

<div align="center">

**ğŸ’° æˆæœ¬æ§åˆ¶æˆåŠŸå…³é”®ï¼šå®æ—¶ç›‘æ§ + æ™ºèƒ½é¢„æµ‹ + è‡ªåŠ¨åŒ–æ§åˆ¶**

</div>