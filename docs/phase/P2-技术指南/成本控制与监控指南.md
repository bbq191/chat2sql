# 💰 成本控制与监控指南

<div align="center">

![Cost](https://img.shields.io/badge/Cost-Control-green.svg)
![Budget](https://img.shields.io/badge/Budget-Management-blue.svg)
![Savings](https://img.shields.io/badge/Savings->50%25-orange.svg)

**Chat2SQL P2阶段 - 智能成本控制与监控完整实现方案**

</div>

## 📋 概述

本文档专门针对Chat2SQL系统的成本控制与监控实现，提供从架构设计到代码实现的完整技术方案，实现实时成本追踪、预算管理和智能成本优化，确保AI调用成本的有效控制。

## 🎯 核心功能

### 成本控制能力
- ✅ **实时成本追踪**：Token使用量和成本的实时统计
- ✅ **多维预算管理**：用户/部门/公司级别的预算控制
- ✅ **成本预测模型**：基于历史数据的成本趋势预测
- ✅ **智能告警系统**：多级成本告警和自动化响应

### 成本优化指标
| 控制维度 | 节省目标 | 监控精度 | 响应时间 |
|---------|---------|---------|----------|
| **模型路由优化** | > 60% | 实时 | < 1s |
| **缓存命中提升** | > 30% | 实时 | < 100ms |
| **预算控制** | 100% | 实时 | < 500ms |

---

## 🏗️ 成本控制系统架构

### 📦 核心组件设计

```go
// internal/cost/controller.go
package cost

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/shopspring/decimal"
)

type CostController struct {
    // 核心组件
    usageTracker    *UsageTracker       // 使用量追踪
    budgetManager   *BudgetManager      // 预算管理
    costCalculator  *CostCalculator     // 成本计算
    predictor       *CostPredictor      // 成本预测
    
    // 告警系统
    alertManager    *AlertManager       // 告警管理
    notifier        *CostNotifier       // 通知系统
    
    // 存储
    storage         *CostStorage        // 成本数据存储
    cache           *CostCache          // 成本缓存
    
    // 配置
    config          *CostConfig         // 成本配置
    
    // 监控
    metrics         *CostMetrics        // 成本指标
    
    // 并发控制
    mu              sync.RWMutex
    stopCh          chan struct{}
}

type CostConfig struct {
    // 预算配置
    Budgets struct {
        UserDaily       decimal.Decimal `yaml:"user_daily"`       // $5.00
        DepartmentWeekly decimal.Decimal `yaml:"department_weekly"` // $500.00
        CompanyMonthly  decimal.Decimal `yaml:"company_monthly"`  // $10000.00
    } `yaml:"budgets"`
    
    // 告警阈值
    AlertThresholds struct {
        Warning       float64 `yaml:"warning"`        // 0.8 (80%)
        Critical      float64 `yaml:"critical"`       // 0.9 (90%)
        Emergency     float64 `yaml:"emergency"`      // 0.95 (95%)
    } `yaml:"alert_thresholds"`
    
    // 成本控制策略
    Controls struct {
        EnableAutoLimit    bool            `yaml:"enable_auto_limit"`     // true
        EnableEmergencyStop bool           `yaml:"enable_emergency_stop"` // true
        GracePeriod       time.Duration   `yaml:"grace_period"`          // 5m
        CooldownPeriod    time.Duration   `yaml:"cooldown_period"`       // 1h
    } `yaml:"controls"`
    
    // 模型成本配置
    ModelCosts map[string]ModelCostConfig `yaml:"model_costs"`
}

type ModelCostConfig struct {
    InputCostPer1K   decimal.Decimal `yaml:"input_cost_per_1k"`   // 输入token成本
    OutputCostPer1K  decimal.Decimal `yaml:"output_cost_per_1k"`  // 输出token成本
    Provider         string          `yaml:"provider"`            // 提供商
    Model            string          `yaml:"model"`               // 模型名称
    LastUpdated      time.Time       `yaml:"last_updated"`        // 最后更新时间
}

type UsageRecord struct {
    // 基础信息
    ID              string          `json:"id"`
    RequestID       string          `json:"request_id"`
    UserID          int64           `json:"user_id"`
    DepartmentID    int64           `json:"department_id"`
    
    // 模型信息
    Model           string          `json:"model"`
    Provider        string          `json:"provider"`
    
    // Token使用量
    InputTokens     int             `json:"input_tokens"`
    OutputTokens    int             `json:"output_tokens"`
    TotalTokens     int             `json:"total_tokens"`
    
    // 成本信息
    InputCost       decimal.Decimal `json:"input_cost"`
    OutputCost      decimal.Decimal `json:"output_cost"`
    TotalCost       decimal.Decimal `json:"total_cost"`
    
    // 时间信息
    Timestamp       time.Time       `json:"timestamp"`
    ResponseTime    time.Duration   `json:"response_time"`
    
    // 查询信息
    Query           string          `json:"query"`
    QueryComplexity string          `json:"query_complexity"`
    CacheHit        bool           `json:"cache_hit"`
    
    // 质量信息
    Success         bool           `json:"success"`
    Confidence      float64        `json:"confidence"`
    
    // 元数据
    Metadata        map[string]interface{} `json:"metadata"`
}
```

### 🔧 成本控制器初始化

```go
func NewCostController(config *CostConfig) (*CostController, error) {
    controller := &CostController{
        usageTracker:   NewUsageTracker(),
        budgetManager:  NewBudgetManager(config.Budgets),
        costCalculator: NewCostCalculator(config.ModelCosts),
        predictor:      NewCostPredictor(),
        alertManager:   NewAlertManager(config.AlertThresholds),
        notifier:       NewCostNotifier(),
        storage:        NewCostStorage(),
        cache:          NewCostCache(),
        config:        config,
        metrics:       NewCostMetrics(),
        stopCh:        make(chan struct{}),
    }
    
    // 启动后台任务
    go controller.startBackgroundTasks()
    
    return controller, nil
}

func (cc *CostController) startBackgroundTasks() {
    // 实时成本统计
    go cc.startRealTimeTracking()
    
    // 预算检查
    go cc.startBudgetMonitoring()
    
    // 成本预测
    go cc.startCostPrediction()
    
    // 告警检查
    go cc.startAlertMonitoring()
    
    // 数据清理
    go cc.startDataCleanup()
}

func (cc *CostController) RecordUsage(ctx context.Context, usage *UsageRecord) error {
    start := time.Now()
    defer func() {
        cc.metrics.RecordOperationDuration("record_usage", time.Since(start))
    }()
    
    // 1. 计算成本
    if err := cc.calculateCost(usage); err != nil {
        cc.metrics.RecordError("cost_calculation")
        return fmt.Errorf("成本计算失败: %w", err)
    }
    
    // 2. 记录使用量
    if err := cc.usageTracker.Track(usage); err != nil {
        cc.metrics.RecordError("usage_tracking")
        return fmt.Errorf("使用量追踪失败: %w", err)
    }
    
    // 3. 检查预算
    if err := cc.checkBudgetLimits(ctx, usage); err != nil {
        cc.metrics.RecordBudgetViolation(usage.UserID, usage.DepartmentID)
        return fmt.Errorf("预算检查失败: %w", err)
    }
    
    // 4. 更新统计
    cc.updateStatistics(usage)
    
    // 5. 异步存储
    go func() {
        if err := cc.storage.Store(context.Background(), usage); err != nil {
            log.Error("成本数据存储失败", zap.Error(err))
        }
    }()
    
    return nil
}

func (cc *CostController) calculateCost(usage *UsageRecord) error {
    modelConfig, exists := cc.config.ModelCosts[usage.Model]
    if !exists {
        return fmt.Errorf("模型成本配置不存在: %s", usage.Model)
    }
    
    // 计算输入成本
    usage.InputCost = modelConfig.InputCostPer1K.Mul(
        decimal.NewFromInt(int64(usage.InputTokens))).Div(decimal.NewFromInt(1000))
    
    // 计算输出成本
    usage.OutputCost = modelConfig.OutputCostPer1K.Mul(
        decimal.NewFromInt(int64(usage.OutputTokens))).Div(decimal.NewFromInt(1000))
    
    // 计算总成本
    usage.TotalCost = usage.InputCost.Add(usage.OutputCost)
    
    return nil
}
```

---

## 📊 实时使用量追踪

### 高性能使用量追踪器

```go
// internal/cost/usage_tracker.go
package cost

import (
    "sync"
    "time"
    
    "github.com/shopspring/decimal"
)

type UsageTracker struct {
    // 实时统计
    currentUsage    map[string]*UsageStats  // 按用户/部门的实时使用统计
    
    // 时间窗口统计
    hourlyUsage     *TimeWindowStats        // 按小时统计
    dailyUsage      *TimeWindowStats        // 按日统计
    monthlyUsage    *TimeWindowStats        // 按月统计
    
    // 并发控制
    mu              sync.RWMutex
    
    // 配置
    config          *TrackerConfig
}

type UsageStats struct {
    // 基础统计
    TotalRequests   int64           `json:"total_requests"`
    SuccessRequests int64           `json:"success_requests"`
    FailedRequests  int64           `json:"failed_requests"`
    
    // Token统计
    TotalTokens     int64           `json:"total_tokens"`
    InputTokens     int64           `json:"input_tokens"`
    OutputTokens    int64           `json:"output_tokens"`
    
    // 成本统计
    TotalCost       decimal.Decimal `json:"total_cost"`
    AvgCostPerRequest decimal.Decimal `json:"avg_cost_per_request"`
    
    // 模型使用统计
    ModelUsage      map[string]*ModelUsageStats `json:"model_usage"`
    
    // 时间统计
    FirstRequest    time.Time       `json:"first_request"`
    LastRequest     time.Time       `json:"last_request"`
    
    // 性能统计
    AvgResponseTime time.Duration   `json:"avg_response_time"`
    TotalResponseTime time.Duration `json:"total_response_time"`
}

type ModelUsageStats struct {
    Requests        int64           `json:"requests"`
    Tokens          int64           `json:"tokens"`
    Cost            decimal.Decimal `json:"cost"`
    AvgConfidence   float64         `json:"avg_confidence"`
    SuccessRate     float64         `json:"success_rate"`
}

type TimeWindowStats struct {
    windows         map[string]*UsageStats  // 时间窗口 -> 统计数据
    windowSize      time.Duration           // 窗口大小
    maxWindows      int                     // 最大窗口数
    mu              sync.RWMutex
}

func NewUsageTracker() *UsageTracker {
    return &UsageTracker{
        currentUsage:  make(map[string]*UsageStats),
        hourlyUsage:   NewTimeWindowStats(time.Hour, 48),      // 保持48小时
        dailyUsage:    NewTimeWindowStats(24*time.Hour, 30),   // 保持30天
        monthlyUsage:  NewTimeWindowStats(30*24*time.Hour, 12), // 保持12个月
    }
}

func (ut *UsageTracker) Track(usage *UsageRecord) error {
    ut.mu.Lock()
    defer ut.mu.Unlock()
    
    // 1. 更新用户统计
    userKey := fmt.Sprintf("user:%d", usage.UserID)
    ut.updateUsageStats(userKey, usage)
    
    // 2. 更新部门统计
    deptKey := fmt.Sprintf("dept:%d", usage.DepartmentID)
    ut.updateUsageStats(deptKey, usage)
    
    // 3. 更新全局统计
    ut.updateUsageStats("global", usage)
    
    // 4. 更新时间窗口统计
    ut.updateTimeWindowStats(usage)
    
    return nil
}

func (ut *UsageTracker) updateUsageStats(key string, usage *UsageRecord) {
    stats, exists := ut.currentUsage[key]
    if !exists {
        stats = &UsageStats{
            ModelUsage:   make(map[string]*ModelUsageStats),
            FirstRequest: usage.Timestamp,
        }
        ut.currentUsage[key] = stats
    }
    
    // 更新基础统计
    stats.TotalRequests++
    if usage.Success {
        stats.SuccessRequests++
    } else {
        stats.FailedRequests++
    }
    
    // 更新Token统计
    stats.TotalTokens += int64(usage.TotalTokens)
    stats.InputTokens += int64(usage.InputTokens)
    stats.OutputTokens += int64(usage.OutputTokens)
    
    // 更新成本统计
    stats.TotalCost = stats.TotalCost.Add(usage.TotalCost)
    stats.AvgCostPerRequest = stats.TotalCost.Div(decimal.NewFromInt(stats.TotalRequests))
    
    // 更新模型使用统计
    modelStats, exists := stats.ModelUsage[usage.Model]
    if !exists {
        modelStats = &ModelUsageStats{}
        stats.ModelUsage[usage.Model] = modelStats
    }
    
    modelStats.Requests++
    modelStats.Tokens += int64(usage.TotalTokens)
    modelStats.Cost = modelStats.Cost.Add(usage.TotalCost)
    
    // 更新平均信心度
    if usage.Success {
        oldConfidence := modelStats.AvgConfidence
        newCount := modelStats.Requests
        modelStats.AvgConfidence = (oldConfidence*float64(newCount-1) + usage.Confidence) / float64(newCount)
    }
    
    // 更新成功率
    successCount := int64(0)
    if usage.Success {
        successCount = 1
    }
    modelStats.SuccessRate = float64(successCount) / float64(modelStats.Requests)
    
    // 更新时间统计
    stats.LastRequest = usage.Timestamp
    
    // 更新性能统计
    stats.TotalResponseTime += usage.ResponseTime
    stats.AvgResponseTime = stats.TotalResponseTime / time.Duration(stats.TotalRequests)
}

func (ut *UsageTracker) updateTimeWindowStats(usage *UsageRecord) {
    // 更新小时统计
    hourKey := usage.Timestamp.Format("2006-01-02-15")
    ut.hourlyUsage.Update(hourKey, usage)
    
    // 更新日统计
    dayKey := usage.Timestamp.Format("2006-01-02")
    ut.dailyUsage.Update(dayKey, usage)
    
    // 更新月统计
    monthKey := usage.Timestamp.Format("2006-01")
    ut.monthlyUsage.Update(monthKey, usage)
}

func (ut *UsageTracker) GetUsageStats(key string) *UsageStats {
    ut.mu.RLock()
    defer ut.mu.RUnlock()
    
    if stats, exists := ut.currentUsage[key]; exists {
        // 返回副本避免并发问题
        return ut.copyUsageStats(stats)
    }
    
    return nil
}

func (ut *UsageTracker) GetUserUsage(userID int64) *UsageStats {
    key := fmt.Sprintf("user:%d", userID)
    return ut.GetUsageStats(key)
}

func (ut *UsageTracker) GetDepartmentUsage(deptID int64) *UsageStats {
    key := fmt.Sprintf("dept:%d", deptID)
    return ut.GetUsageStats(key)
}

func (ut *UsageTracker) GetGlobalUsage() *UsageStats {
    return ut.GetUsageStats("global")
}

func (ut *UsageTracker) GetTimeWindowUsage(window string, windowType string) []*UsageStats {
    ut.mu.RLock()
    defer ut.mu.RUnlock()
    
    var timeStats *TimeWindowStats
    switch windowType {
    case "hour":
        timeStats = ut.hourlyUsage
    case "day":
        timeStats = ut.dailyUsage
    case "month":
        timeStats = ut.monthlyUsage
    default:
        return nil
    }
    
    return timeStats.GetRecentStats(24) // 获取最近24个窗口
}

// 时间窗口统计实现
func NewTimeWindowStats(windowSize time.Duration, maxWindows int) *TimeWindowStats {
    return &TimeWindowStats{
        windows:    make(map[string]*UsageStats),
        windowSize: windowSize,
        maxWindows: maxWindows,
    }
}

func (tws *TimeWindowStats) Update(key string, usage *UsageRecord) {
    tws.mu.Lock()
    defer tws.mu.Unlock()
    
    stats, exists := tws.windows[key]
    if !exists {
        stats = &UsageStats{
            ModelUsage:   make(map[string]*ModelUsageStats),
            FirstRequest: usage.Timestamp,
        }
        tws.windows[key] = stats
    }
    
    // 更新统计 (复用updateUsageStats的逻辑)
    // ... (类似实现)
    
    // 清理旧窗口
    tws.cleanupOldWindows()
}

func (tws *TimeWindowStats) cleanupOldWindows() {
    if len(tws.windows) <= tws.maxWindows {
        return
    }
    
    // 获取所有窗口键并排序
    keys := make([]string, 0, len(tws.windows))
    for key := range tws.windows {
        keys = append(keys, key)
    }
    
    sort.Strings(keys)
    
    // 删除最旧的窗口
    deleteCount := len(keys) - tws.maxWindows
    for i := 0; i < deleteCount; i++ {
        delete(tws.windows, keys[i])
    }
}

func (tws *TimeWindowStats) GetRecentStats(count int) []*UsageStats {
    tws.mu.RLock()
    defer tws.mu.RUnlock()
    
    keys := make([]string, 0, len(tws.windows))
    for key := range tws.windows {
        keys = append(keys, key)
    }
    
    sort.Strings(keys)
    
    // 获取最新的count个窗口
    start := len(keys) - count
    if start < 0 {
        start = 0
    }
    
    result := make([]*UsageStats, 0, count)
    for i := start; i < len(keys); i++ {
        if stats, exists := tws.windows[keys[i]]; exists {
            result = append(result, stats)
        }
    }
    
    return result
}
```

---

## 💳 预算管理系统

### 多维度预算控制

```go
// internal/cost/budget_manager.go
package cost

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/shopspring/decimal"
)

type BudgetManager struct {
    // 预算配置
    budgets         map[string]*Budget      // 预算配置
    
    // 使用量追踪
    usageTracker    *UsageTracker          // 使用量追踪器
    
    // 告警管理
    alertManager    *AlertManager          // 告警管理器
    
    // 并发控制
    mu              sync.RWMutex
    
    // 配置
    config          *BudgetConfig
}

type Budget struct {
    // 基础信息
    ID              string          `json:"id"`
    Name            string          `json:"name"`
    Type            BudgetType      `json:"type"`           // user/department/company
    EntityID        int64           `json:"entity_id"`      // 实体ID
    
    // 预算配置
    Amount          decimal.Decimal `json:"amount"`         // 预算金额
    Period          BudgetPeriod    `json:"period"`         // 预算周期
    Currency        string          `json:"currency"`       // 货币单位
    
    // 使用情况
    Used            decimal.Decimal `json:"used"`           // 已使用金额
    Remaining       decimal.Decimal `json:"remaining"`      // 剩余金额
    UsagePercentage float64         `json:"usage_percentage"` // 使用百分比
    
    // 时间信息
    StartTime       time.Time       `json:"start_time"`     // 开始时间
    EndTime         time.Time       `json:"end_time"`       // 结束时间
    LastUpdated     time.Time       `json:"last_updated"`   // 最后更新时间
    
    // 告警配置
    AlertThresholds []float64       `json:"alert_thresholds"` // 告警阈值
    AlertEnabled    bool           `json:"alert_enabled"`    // 是否启用告警
    
    // 控制策略
    Controls        *BudgetControls `json:"controls"`       // 预算控制策略
    
    // 状态
    Status          BudgetStatus    `json:"status"`         // 预算状态
    
    // 元数据
    Metadata        map[string]interface{} `json:"metadata"`
}

type BudgetType string
type BudgetPeriod string
type BudgetStatus string

const (
    BudgetTypeUser       BudgetType = "user"
    BudgetTypeDepartment BudgetType = "department"
    BudgetTypeCompany    BudgetType = "company"
    
    BudgetPeriodDaily    BudgetPeriod = "daily"
    BudgetPeriodWeekly   BudgetPeriod = "weekly"
    BudgetPeriodMonthly  BudgetPeriod = "monthly"
    BudgetPeriodYearly   BudgetPeriod = "yearly"
    
    BudgetStatusActive   BudgetStatus = "active"
    BudgetStatusWarning  BudgetStatus = "warning"
    BudgetStatusCritical BudgetStatus = "critical"
    BudgetStatusExceeded BudgetStatus = "exceeded"
    BudgetStatusExpired  BudgetStatus = "expired"
)

type BudgetControls struct {
    // 限制策略
    EnableHardLimit     bool            `json:"enable_hard_limit"`     // 硬限制
    EnableSoftLimit     bool            `json:"enable_soft_limit"`     // 软限制
    SoftLimitThreshold  float64         `json:"soft_limit_threshold"`  // 软限制阈值
    
    // 自动控制
    EnableAutoThrottle  bool            `json:"enable_auto_throttle"`  // 自动限流
    ThrottleThreshold   float64         `json:"throttle_threshold"`    // 限流阈值
    ThrottleRate        float64         `json:"throttle_rate"`         // 限流比例
    
    // 紧急控制
    EnableEmergencyStop bool            `json:"enable_emergency_stop"` // 紧急停止
    EmergencyThreshold  float64         `json:"emergency_threshold"`   // 紧急停止阈值
    
    // 冷却期
    CooldownPeriod      time.Duration   `json:"cooldown_period"`       // 冷却期
    LastControlAction   time.Time       `json:"last_control_action"`   // 最后控制动作时间
}

func NewBudgetManager(config *BudgetConfig) *BudgetManager {
    return &BudgetManager{
        budgets:      make(map[string]*Budget),
        config:       config,
        usageTracker: NewUsageTracker(),
        alertManager: NewAlertManager(nil),
    }
}

func (bm *BudgetManager) CreateBudget(budget *Budget) error {
    bm.mu.Lock()
    defer bm.mu.Unlock()
    
    // 验证预算配置
    if err := bm.validateBudget(budget); err != nil {
        return fmt.Errorf("预算配置验证失败: %w", err)
    }
    
    // 设置预算时间范围
    if err := bm.setBudgetPeriod(budget); err != nil {
        return fmt.Errorf("设置预算周期失败: %w", err)
    }
    
    // 初始化预算状态
    budget.Used = decimal.Zero
    budget.Remaining = budget.Amount
    budget.UsagePercentage = 0.0
    budget.Status = BudgetStatusActive
    budget.LastUpdated = time.Now()
    
    // 存储预算
    bm.budgets[budget.ID] = budget
    
    return nil
}

func (bm *BudgetManager) CheckBudgetLimit(ctx context.Context, usage *UsageRecord) error {
    // 检查用户预算
    if err := bm.checkUserBudget(usage); err != nil {
        return err
    }
    
    // 检查部门预算
    if err := bm.checkDepartmentBudget(usage); err != nil {
        return err
    }
    
    // 检查公司预算
    if err := bm.checkCompanyBudget(usage); err != nil {
        return err
    }
    
    return nil
}

func (bm *BudgetManager) checkUserBudget(usage *UsageRecord) error {
    userBudgetID := fmt.Sprintf("user_%d_daily", usage.UserID)
    budget := bm.getBudget(userBudgetID)
    
    if budget == nil {
        // 如果没有用户预算，创建默认预算
        budget = bm.createDefaultUserBudget(usage.UserID)
    }
    
    return bm.validateUsageAgainstBudget(budget, usage.TotalCost)
}

func (bm *BudgetManager) checkDepartmentBudget(usage *UsageRecord) error {
    deptBudgetID := fmt.Sprintf("dept_%d_weekly", usage.DepartmentID)
    budget := bm.getBudget(deptBudgetID)
    
    if budget == nil {
        budget = bm.createDefaultDepartmentBudget(usage.DepartmentID)
    }
    
    return bm.validateUsageAgainstBudget(budget, usage.TotalCost)
}

func (bm *BudgetManager) validateUsageAgainstBudget(budget *Budget, cost decimal.Decimal) error {
    // 检查预算是否过期
    if time.Now().After(budget.EndTime) {
        return fmt.Errorf("预算已过期: %s", budget.ID)
    }
    
    // 计算使用后的总成本
    projectedUsed := budget.Used.Add(cost)
    projectedPercentage := projectedUsed.Div(budget.Amount).InexactFloat64()
    
    // 检查硬限制
    if budget.Controls != nil && budget.Controls.EnableHardLimit {
        if projectedPercentage >= 1.0 {
            return fmt.Errorf("超出硬预算限制: %s, 使用率: %.2f%%", 
                budget.ID, projectedPercentage*100)
        }
    }
    
    // 检查紧急停止
    if budget.Controls != nil && budget.Controls.EnableEmergencyStop {
        if projectedPercentage >= budget.Controls.EmergencyThreshold {
            return fmt.Errorf("触发紧急停止: %s, 使用率: %.2f%%", 
                budget.ID, projectedPercentage*100)
        }
    }
    
    // 检查限流
    if budget.Controls != nil && budget.Controls.EnableAutoThrottle {
        if projectedPercentage >= budget.Controls.ThrottleThreshold {
            // 检查冷却期
            if time.Since(budget.Controls.LastControlAction) < budget.Controls.CooldownPeriod {
                return fmt.Errorf("预算限流中，请稍后重试: %s", budget.ID)
            }
            
            // 应用限流
            return bm.applyThrottling(budget, cost)
        }
    }
    
    return nil
}

func (bm *BudgetManager) UpdateBudgetUsage(usage *UsageRecord) error {
    bm.mu.Lock()
    defer bm.mu.Unlock()
    
    // 更新用户预算
    userBudgetID := fmt.Sprintf("user_%d_daily", usage.UserID)
    if err := bm.updateSingleBudget(userBudgetID, usage.TotalCost); err != nil {
        return err
    }
    
    // 更新部门预算
    deptBudgetID := fmt.Sprintf("dept_%d_weekly", usage.DepartmentID)
    if err := bm.updateSingleBudget(deptBudgetID, usage.TotalCost); err != nil {
        return err
    }
    
    // 更新公司预算
    companyBudgetID := "company_monthly"
    if err := bm.updateSingleBudget(companyBudgetID, usage.TotalCost); err != nil {
        return err
    }
    
    return nil
}

func (bm *BudgetManager) updateSingleBudget(budgetID string, cost decimal.Decimal) error {
    budget, exists := bm.budgets[budgetID]
    if !exists {
        return fmt.Errorf("预算不存在: %s", budgetID)
    }
    
    // 更新使用量
    budget.Used = budget.Used.Add(cost)
    budget.Remaining = budget.Amount.Sub(budget.Used)
    budget.UsagePercentage = budget.Used.Div(budget.Amount).InexactFloat64()
    budget.LastUpdated = time.Now()
    
    // 更新预算状态
    bm.updateBudgetStatus(budget)
    
    // 检查告警条件
    if budget.AlertEnabled {
        bm.checkBudgetAlerts(budget)
    }
    
    return nil
}

func (bm *BudgetManager) updateBudgetStatus(budget *Budget) {
    percentage := budget.UsagePercentage
    
    switch {
    case percentage >= 1.0:
        budget.Status = BudgetStatusExceeded
    case percentage >= 0.9:
        budget.Status = BudgetStatusCritical
    case percentage >= 0.8:
        budget.Status = BudgetStatusWarning
    default:
        budget.Status = BudgetStatusActive
    }
}

func (bm *BudgetManager) checkBudgetAlerts(budget *Budget) {
    for _, threshold := range budget.AlertThresholds {
        if budget.UsagePercentage >= threshold {
            alert := &CostAlert{
                Type:        AlertTypeBudget,
                Level:       bm.getAlertLevel(threshold),
                BudgetID:    budget.ID,
                Message:     fmt.Sprintf("预算使用率达到%.1f%%", threshold*100),
                Threshold:   threshold,
                CurrentValue: budget.UsagePercentage,
                Timestamp:   time.Now(),
            }
            
            bm.alertManager.TriggerAlert(alert)
        }
    }
}

func (bm *BudgetManager) getBudget(budgetID string) *Budget {
    bm.mu.RLock()
    defer bm.mu.RUnlock()
    
    return bm.budgets[budgetID]
}

func (bm *BudgetManager) GetAllBudgets() map[string]*Budget {
    bm.mu.RLock()
    defer bm.mu.RUnlock()
    
    result := make(map[string]*Budget)
    for id, budget := range bm.budgets {
        result[id] = budget
    }
    
    return result
}

func (bm *BudgetManager) GetUserBudgets(userID int64) []*Budget {
    bm.mu.RLock()
    defer bm.mu.RUnlock()
    
    var result []*Budget
    for _, budget := range bm.budgets {
        if budget.Type == BudgetTypeUser && budget.EntityID == userID {
            result = append(result, budget)
        }
    }
    
    return result
}

func (bm *BudgetManager) createDefaultUserBudget(userID int64) *Budget {
    budget := &Budget{
        ID:       fmt.Sprintf("user_%d_daily", userID),
        Name:     fmt.Sprintf("用户%d日预算", userID),
        Type:     BudgetTypeUser,
        EntityID: userID,
        Amount:   decimal.NewFromFloat(5.0), // $5 daily
        Period:   BudgetPeriodDaily,
        Currency: "USD",
        AlertThresholds: []float64{0.8, 0.9, 0.95},
        AlertEnabled: true,
        Controls: &BudgetControls{
            EnableHardLimit:     true,
            EnableAutoThrottle:  true,
            ThrottleThreshold:   0.85,
            ThrottleRate:        0.5,
            EnableEmergencyStop: true,
            EmergencyThreshold:  0.95,
            CooldownPeriod:      5 * time.Minute,
        },
        Status: BudgetStatusActive,
    }
    
    bm.setBudgetPeriod(budget)
    bm.budgets[budget.ID] = budget
    
    return budget
}
```

---

## 📈 成本预测模型

### 智能成本预测

```go
// internal/cost/predictor.go
package cost

import (
    "context"
    "math"
    "sort"
    "time"
    
    "github.com/shopspring/decimal"
)

type CostPredictor struct {
    // 历史数据
    historicalData  []*CostDataPoint
    
    // 预测模型
    trendModel      *TrendModel
    seasonalModel   *SeasonalModel
    regressionModel *RegressionModel
    
    // 配置
    config          *PredictorConfig
    
    // 缓存
    predictionCache map[string]*PredictionResult
}

type CostDataPoint struct {
    Timestamp    time.Time       `json:"timestamp"`
    Cost         decimal.Decimal `json:"cost"`
    Requests     int64           `json:"requests"`
    Tokens       int64           `json:"tokens"`
    UserID       int64           `json:"user_id,omitempty"`
    DepartmentID int64           `json:"department_id,omitempty"`
    Model        string          `json:"model,omitempty"`
}

type PredictionResult struct {
    // 预测信息
    PredictedCost     decimal.Decimal `json:"predicted_cost"`
    Confidence        float64         `json:"confidence"`
    PredictionRange   *PredictionRange `json:"prediction_range"`
    
    // 趋势分析
    Trend             string          `json:"trend"`           // increasing/decreasing/stable
    TrendStrength     float64         `json:"trend_strength"`  // 0-1
    
    // 时间信息
    PredictionTime    time.Time       `json:"prediction_time"`
    PredictionPeriod  time.Duration   `json:"prediction_period"`
    
    // 因素分析
    CostFactors       []*CostFactor   `json:"cost_factors"`
    
    // 建议
    Recommendations   []string        `json:"recommendations"`
}

type PredictionRange struct {
    LowerBound  decimal.Decimal `json:"lower_bound"`
    UpperBound  decimal.Decimal `json:"upper_bound"`
    Probability float64         `json:"probability"`  // 置信概率
}

type CostFactor struct {
    Name        string  `json:"name"`
    Impact      float64 `json:"impact"`      // 影响程度 (-1 to 1)
    Confidence  float64 `json:"confidence"`  // 信心度 (0 to 1)
    Description string  `json:"description"`
}

func NewCostPredictor(config *PredictorConfig) *CostPredictor {
    return &CostPredictor{
        historicalData:  make([]*CostDataPoint, 0),
        trendModel:      NewTrendModel(),
        seasonalModel:   NewSeasonalModel(),
        regressionModel: NewRegressionModel(),
        config:         config,
        predictionCache: make(map[string]*PredictionResult),
    }
}

func (cp *CostPredictor) PredictCost(
    ctx context.Context,
    userID int64,
    period time.Duration) (*PredictionResult, error) {
    
    // 检查缓存
    cacheKey := fmt.Sprintf("user_%d_%s", userID, period.String())
    if cached := cp.predictionCache[cacheKey]; cached != nil {
        return cached, nil
    }
    
    // 获取历史数据
    historicalData := cp.getHistoricalData(userID, 30*24*time.Hour) // 30天历史
    if len(historicalData) < 7 { // 至少需要7个数据点
        return cp.generateDefaultPrediction(period), nil
    }
    
    // 执行预测
    result := &PredictionResult{
        PredictionTime:   time.Now(),
        PredictionPeriod: period,
        CostFactors:      make([]*CostFactor, 0),
        Recommendations:  make([]string, 0),
    }
    
    // 1. 趋势分析
    trend := cp.analyzeTrend(historicalData)
    result.Trend = trend.Direction
    result.TrendStrength = trend.Strength
    
    // 2. 季节性分析
    seasonal := cp.analyzeSeasonality(historicalData)
    
    // 3. 回归预测
    regression := cp.performRegression(historicalData, period)
    
    // 4. 组合预测
    result.PredictedCost = cp.combinePredictions(trend, seasonal, regression)
    
    // 5. 计算置信度和范围
    result.Confidence = cp.calculateConfidence(historicalData, result.PredictedCost)
    result.PredictionRange = cp.calculatePredictionRange(result.PredictedCost, result.Confidence)
    
    // 6. 分析成本因素
    result.CostFactors = cp.analyzeCostFactors(historicalData)
    
    // 7. 生成建议
    result.Recommendations = cp.generateRecommendations(result)
    
    // 缓存结果
    cp.predictionCache[cacheKey] = result
    
    return result, nil
}

func (cp *CostPredictor) analyzeTrend(data []*CostDataPoint) *TrendAnalysis {
    if len(data) < 2 {
        return &TrendAnalysis{Direction: "stable", Strength: 0.0}
    }
    
    // 计算线性回归斜率
    n := float64(len(data))
    sumX, sumY, sumXY, sumX2 := 0.0, 0.0, 0.0, 0.0
    
    for i, point := range data {
        x := float64(i)
        y := point.Cost.InexactFloat64()
        
        sumX += x
        sumY += y
        sumXY += x * y
        sumX2 += x * x
    }
    
    // 计算斜率
    slope := (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)
    
    // 判断趋势方向和强度
    direction := "stable"
    strength := math.Abs(slope)
    
    if slope > 0.01 {
        direction = "increasing"
    } else if slope < -0.01 {
        direction = "decreasing"
    }
    
    // 归一化强度值
    strength = math.Min(strength*100, 1.0)
    
    return &TrendAnalysis{
        Direction: direction,
        Strength:  strength,
        Slope:     slope,
    }
}

func (cp *CostPredictor) analyzeSeasonality(data []*CostDataPoint) *SeasonalAnalysis {
    // 分析周内模式
    weeklyPattern := make(map[int][]decimal.Decimal) // 星期 -> 成本列表
    
    // 分析小时模式
    hourlyPattern := make(map[int][]decimal.Decimal) // 小时 -> 成本列表
    
    for _, point := range data {
        weekday := int(point.Timestamp.Weekday())
        hour := point.Timestamp.Hour()
        
        weeklyPattern[weekday] = append(weeklyPattern[weekday], point.Cost)
        hourlyPattern[hour] = append(hourlyPattern[hour], point.Cost)
    }
    
    // 计算周内平均成本
    weeklyAvg := make(map[int]decimal.Decimal)
    for day, costs := range weeklyPattern {
        if len(costs) > 0 {
            sum := decimal.Zero
            for _, cost := range costs {
                sum = sum.Add(cost)
            }
            weeklyAvg[day] = sum.Div(decimal.NewFromInt(int64(len(costs))))
        }
    }
    
    // 计算小时平均成本
    hourlyAvg := make(map[int]decimal.Decimal)
    for hour, costs := range hourlyPattern {
        if len(costs) > 0 {
            sum := decimal.Zero
            for _, cost := range costs {
                sum = sum.Add(cost)
            }
            hourlyAvg[hour] = sum.Div(decimal.NewFromInt(int64(len(costs))))
        }
    }
    
    return &SeasonalAnalysis{
        WeeklyPattern: weeklyAvg,
        HourlyPattern: hourlyAvg,
        HasWeeklyPattern: cp.detectPattern(weeklyPattern),
        HasHourlyPattern: cp.detectPattern(hourlyPattern),
    }
}

func (cp *CostPredictor) performRegression(data []*CostDataPoint, period time.Duration) *RegressionResult {
    if len(data) < 3 {
        return &RegressionResult{PredictedValue: decimal.Zero, Accuracy: 0.0}
    }
    
    // 使用最近的数据点进行线性回归
    recentData := data
    if len(data) > 14 { // 只使用最近14天的数据
        recentData = data[len(data)-14:]
    }
    
    // 计算平均日成本
    dailyCosts := cp.aggregateByDay(recentData)
    
    if len(dailyCosts) < 2 {
        return &RegressionResult{PredictedValue: decimal.Zero, Accuracy: 0.0}
    }
    
    // 线性回归预测
    n := float64(len(dailyCosts))
    days := period.Hours() / 24 // 预测天数
    
    // 计算回归系数
    sumX, sumY, sumXY, sumX2 := 0.0, 0.0, 0.0, 0.0
    for i, cost := range dailyCosts {
        x := float64(i)
        y := cost.InexactFloat64()
        
        sumX += x
        sumY += y
        sumXY += x * y
        sumX2 += x * x
    }
    
    slope := (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)
    intercept := (sumY - slope*sumX) / n
    
    // 预测值
    predictedDaily := slope*n + intercept
    predictedTotal := predictedDaily * days
    
    // 计算准确度（基于历史拟合度）
    accuracy := cp.calculateRegressionAccuracy(dailyCosts, slope, intercept)
    
    return &RegressionResult{
        PredictedValue: decimal.NewFromFloat(math.Max(predictedTotal, 0)),
        Accuracy:      accuracy,
        Slope:         slope,
        Intercept:     intercept,
    }
}

func (cp *CostPredictor) combinePredictions(
    trend *TrendAnalysis,
    seasonal *SeasonalAnalysis,
    regression *RegressionResult) decimal.Decimal {
    
    // 基础预测值来自回归
    basePrediction := regression.PredictedValue
    
    // 趋势调整
    trendAdjustment := 1.0
    if trend.Direction == "increasing" {
        trendAdjustment = 1.0 + trend.Strength*0.2 // 最大20%增长调整
    } else if trend.Direction == "decreasing" {
        trendAdjustment = 1.0 - trend.Strength*0.2 // 最大20%下降调整
    }
    
    // 应用调整
    adjustedPrediction := basePrediction.Mul(decimal.NewFromFloat(trendAdjustment))
    
    return adjustedPrediction
}

func (cp *CostPredictor) calculateConfidence(
    data []*CostDataPoint,
    prediction decimal.Decimal) float64 {
    
    if len(data) < 3 {
        return 0.5 // 低置信度
    }
    
    // 计算历史数据的变异系数
    costs := make([]float64, len(data))
    sum := 0.0
    
    for i, point := range data {
        cost := point.Cost.InexactFloat64()
        costs[i] = cost
        sum += cost
    }
    
    mean := sum / float64(len(costs))
    
    // 计算标准差
    variance := 0.0
    for _, cost := range costs {
        variance += math.Pow(cost-mean, 2)
    }
    stdDev := math.Sqrt(variance / float64(len(costs)))
    
    // 变异系数
    cv := stdDev / mean
    
    // 置信度与变异系数成反比
    confidence := 1.0 / (1.0 + cv)
    
    // 数据量调整
    dataQualityFactor := math.Min(float64(len(data))/30.0, 1.0) // 30天为满分
    
    return confidence * dataQualityFactor
}

func (cp *CostPredictor) generateRecommendations(result *PredictionResult) []string {
    var recommendations []string
    
    // 基于趋势的建议
    if result.Trend == "increasing" && result.TrendStrength > 0.5 {
        recommendations = append(recommendations, 
            "成本呈上升趋势，建议优化模型选择策略或增加缓存使用")
    }
    
    // 基于预测成本的建议
    if result.Confidence > 0.8 {
        recommendations = append(recommendations,
            "预测置信度较高，建议按预测结果制定预算计划")
    } else {
        recommendations = append(recommendations,
            "预测不确定性较大，建议增加监控频率并准备应急预算")
    }
    
    // 基于成本因素的建议
    for _, factor := range result.CostFactors {
        if factor.Impact > 0.3 && factor.Confidence > 0.7 {
            recommendations = append(recommendations,
                fmt.Sprintf("关注%s对成本的影响，考虑相应优化措施", factor.Name))
        }
    }
    
    return recommendations
}
```

---

## 🚨 告警系统

### 智能成本告警

```go
// internal/cost/alert_manager.go
package cost

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type AlertManager struct {
    // 告警规则
    rules           map[string]*AlertRule
    
    // 告警状态
    activeAlerts    map[string]*Alert
    alertHistory    []*Alert
    
    // 通知器
    notifiers       []AlertNotifier
    
    // 配置
    config          *AlertConfig
    
    // 并发控制
    mu              sync.RWMutex
}

type AlertRule struct {
    ID              string          `json:"id"`
    Name            string          `json:"name"`
    Type            AlertType       `json:"type"`
    Condition       *AlertCondition `json:"condition"`
    Actions         []AlertAction   `json:"actions"`
    Enabled         bool           `json:"enabled"`
    Cooldown        time.Duration  `json:"cooldown"`
    LastTriggered   time.Time      `json:"last_triggered"`
}

type AlertCondition struct {
    Metric          string          `json:"metric"`          // cost_per_hour, budget_usage, etc.
    Operator        string          `json:"operator"`        // >, <, >=, <=, ==
    Threshold       float64         `json:"threshold"`       // 阈值
    Duration        time.Duration   `json:"duration"`        // 持续时间
    Aggregation     string          `json:"aggregation"`     // sum, avg, max, min
}

type AlertAction struct {
    Type            string                 `json:"type"`            // notify, throttle, stop
    Parameters      map[string]interface{} `json:"parameters"`
}

type Alert struct {
    ID              string          `json:"id"`
    RuleID          string          `json:"rule_id"`
    Type            AlertType       `json:"type"`
    Level           AlertLevel      `json:"level"`
    Title           string          `json:"title"`
    Message         string          `json:"message"`
    
    // 上下文信息
    EntityType      string          `json:"entity_type"`     // user, department, company
    EntityID        int64           `json:"entity_id"`
    
    // 告警数据
    CurrentValue    float64         `json:"current_value"`
    ThresholdValue  float64         `json:"threshold_value"`
    
    // 时间信息
    StartTime       time.Time       `json:"start_time"`
    LastUpdate      time.Time       `json:"last_update"`
    ResolvedTime    *time.Time      `json:"resolved_time,omitempty"`
    
    // 状态
    Status          AlertStatus     `json:"status"`
    
    // 元数据
    Labels          map[string]string      `json:"labels"`
    Annotations     map[string]string      `json:"annotations"`
}

type AlertType string
type AlertLevel string  
type AlertStatus string

const (
    AlertTypeCost      AlertType = "cost"
    AlertTypeBudget    AlertType = "budget"
    AlertTypeUsage     AlertType = "usage"
    AlertTypeQuota     AlertType = "quota"
    
    AlertLevelInfo     AlertLevel = "info"
    AlertLevelWarning  AlertLevel = "warning"
    AlertLevelCritical AlertLevel = "critical"
    AlertLevelEmergency AlertLevel = "emergency"
    
    AlertStatusFiring   AlertStatus = "firing"
    AlertStatusResolved AlertStatus = "resolved"
    AlertStatusSilenced AlertStatus = "silenced"
)

func NewAlertManager(config *AlertConfig) *AlertManager {
    am := &AlertManager{
        rules:        make(map[string]*AlertRule),
        activeAlerts: make(map[string]*Alert),
        alertHistory: make([]*Alert, 0),
        config:       config,
        notifiers:    make([]AlertNotifier, 0),
    }
    
    // 加载默认告警规则
    am.loadDefaultRules()
    
    // 启动告警检查
    go am.startAlertMonitoring()
    
    return am
}

func (am *AlertManager) loadDefaultRules() {
    // 高成本告警规则
    am.AddRule(&AlertRule{
        ID:   "high_hourly_cost",
        Name: "小时成本过高",
        Type: AlertTypeCost,
        Condition: &AlertCondition{
            Metric:      "cost_per_hour",
            Operator:    ">",
            Threshold:   10.0, // $10/hour
            Duration:    5 * time.Minute,
            Aggregation: "sum",
        },
        Actions: []AlertAction{
            {Type: "notify", Parameters: map[string]interface{}{"channel": "cost-alerts"}},
            {Type: "throttle", Parameters: map[string]interface{}{"rate": 0.5}},
        },
        Enabled:  true,
        Cooldown: 15 * time.Minute,
    })
    
    // 预算告警规则
    am.AddRule(&AlertRule{
        ID:   "budget_warning",
        Name: "预算使用警告",
        Type: AlertTypeBudget,
        Condition: &AlertCondition{
            Metric:      "budget_usage_percentage",
            Operator:    ">=",
            Threshold:   80.0, // 80%
            Duration:    1 * time.Minute,
            Aggregation: "max",
        },
        Actions: []AlertAction{
            {Type: "notify", Parameters: map[string]interface{}{"channel": "budget-alerts"}},
        },
        Enabled:  true,
        Cooldown: 30 * time.Minute,
    })
    
    // 紧急预算告警
    am.AddRule(&AlertRule{
        ID:   "budget_critical",
        Name: "预算临界警告", 
        Type: AlertTypeBudget,
        Condition: &AlertCondition{
            Metric:      "budget_usage_percentage",
            Operator:    ">=",
            Threshold:   95.0, // 95%
            Duration:    30 * time.Second,
            Aggregation: "max",
        },
        Actions: []AlertAction{
            {Type: "notify", Parameters: map[string]interface{}{"channel": "emergency-alerts"}},
            {Type: "stop", Parameters: map[string]interface{}{"grace_period": "5m"}},
        },
        Enabled:  true,
        Cooldown: 5 * time.Minute,
    })
}

func (am *AlertManager) TriggerAlert(alert *Alert) error {
    am.mu.Lock()
    defer am.mu.Unlock()
    
    // 检查是否已存在相同告警
    existingAlert := am.findExistingAlert(alert)
    if existingAlert != nil {
        // 更新现有告警
        existingAlert.LastUpdate = time.Now()
        existingAlert.CurrentValue = alert.CurrentValue
        return nil
    }
    
    // 创建新告警
    alert.ID = fmt.Sprintf("%s_%d", alert.Type, time.Now().UnixNano())
    alert.StartTime = time.Now()
    alert.LastUpdate = time.Now()
    alert.Status = AlertStatusFiring
    
    // 存储告警
    am.activeAlerts[alert.ID] = alert
    am.alertHistory = append(am.alertHistory, alert)
    
    // 执行告警动作
    go am.executeAlertActions(alert)
    
    return nil
}

func (am *AlertManager) executeAlertActions(alert *Alert) {
    // 查找对应的规则
    rule := am.findRuleByType(alert.Type)
    if rule == nil {
        return
    }
    
    // 检查冷却期
    if time.Since(rule.LastTriggered) < rule.Cooldown {
        return
    }
    
    // 更新触发时间
    rule.LastTriggered = time.Now()
    
    // 执行动作
    for _, action := range rule.Actions {
        switch action.Type {
        case "notify":
            am.sendNotification(alert, action.Parameters)
        case "throttle":
            am.applyThrottling(alert, action.Parameters)
        case "stop":
            am.applyEmergencyStop(alert, action.Parameters)
        }
    }
}

func (am *AlertManager) sendNotification(alert *Alert, params map[string]interface{}) {
    for _, notifier := range am.notifiers {
        notification := &AlertNotification{
            Alert:     alert,
            Channel:   params["channel"].(string),
            Message:   am.formatAlertMessage(alert),
            Timestamp: time.Now(),
        }
        
        if err := notifier.Send(notification); err != nil {
            log.Error("告警通知发送失败", 
                zap.String("alert_id", alert.ID),
                zap.Error(err))
        }
    }
}

func (am *AlertManager) formatAlertMessage(alert *Alert) string {
    switch alert.Type {
    case AlertTypeCost:
        return fmt.Sprintf("🚨 成本告警：%s\n当前值：$%.2f\n阈值：$%.2f\n时间：%s",
            alert.Title, alert.CurrentValue, alert.ThresholdValue, 
            alert.StartTime.Format("2006-01-02 15:04:05"))
            
    case AlertTypeBudget:
        return fmt.Sprintf("💰 预算告警：%s\n使用率：%.1f%%\n阈值：%.1f%%\n时间：%s",
            alert.Title, alert.CurrentValue, alert.ThresholdValue,
            alert.StartTime.Format("2006-01-02 15:04:05"))
            
    default:
        return fmt.Sprintf("📢 系统告警：%s\n详情：%s\n时间：%s",
            alert.Title, alert.Message, 
            alert.StartTime.Format("2006-01-02 15:04:05"))
    }
}

func (am *AlertManager) ResolveAlert(alertID string, reason string) error {
    am.mu.Lock()
    defer am.mu.Unlock()
    
    alert, exists := am.activeAlerts[alertID]
    if !exists {
        return fmt.Errorf("告警不存在: %s", alertID)
    }
    
    now := time.Now()
    alert.Status = AlertStatusResolved
    alert.ResolvedTime = &now
    alert.LastUpdate = now
    
    if alert.Annotations == nil {
        alert.Annotations = make(map[string]string)
    }
    alert.Annotations["resolution_reason"] = reason
    
    // 从活跃告警中移除
    delete(am.activeAlerts, alertID)
    
    return nil
}

func (am *AlertManager) GetActiveAlerts() []*Alert {
    am.mu.RLock()
    defer am.mu.RUnlock()
    
    alerts := make([]*Alert, 0, len(am.activeAlerts))
    for _, alert := range am.activeAlerts {
        alerts = append(alerts, alert)
    }
    
    return alerts
}

func (am *AlertManager) GetAlertHistory(limit int) []*Alert {
    am.mu.RLock()
    defer am.mu.RUnlock()
    
    if limit <= 0 || limit > len(am.alertHistory) {
        limit = len(am.alertHistory)
    }
    
    start := len(am.alertHistory) - limit
    return am.alertHistory[start:]
}

// 告警通知接口
type AlertNotifier interface {
    Send(notification *AlertNotification) error
}

type AlertNotification struct {
    Alert     *Alert
    Channel   string
    Message   string
    Timestamp time.Time
}

// 邮件通知器
type EmailNotifier struct {
    smtpConfig *SMTPConfig
}

func (en *EmailNotifier) Send(notification *AlertNotification) error {
    // 实现邮件发送逻辑
    return nil
}

// Slack通知器
type SlackNotifier struct {
    webhookURL string
}

func (sn *SlackNotifier) Send(notification *AlertNotification) error {
    // 实现Slack通知逻辑
    return nil
}

// 微信通知器
type WeChatNotifier struct {
    corpID     string
    corpSecret string
}

func (wn *WeChatNotifier) Send(notification *AlertNotification) error {
    // 实现微信通知逻辑
    return nil
}
```

---

## 📊 成本分析报告

### 智能成本分析

```go
// internal/cost/analyzer.go
package cost

import (
    "context"
    "fmt"
    "sort"
    "time"
    
    "github.com/shopspring/decimal"
)

type CostAnalyzer struct {
    storage        *CostStorage
    usageTracker   *UsageTracker
    config         *AnalyzerConfig
}

type CostReport struct {
    // 基础信息
    ReportID       string          `json:"report_id"`
    Title          string          `json:"title"`
    Period         *ReportPeriod   `json:"period"`
    GeneratedAt    time.Time       `json:"generated_at"`
    
    // 总体统计
    Summary        *CostSummary    `json:"summary"`
    
    // 详细分析
    TrendAnalysis  *TrendAnalysis  `json:"trend_analysis"`
    ModelAnalysis  *ModelAnalysis  `json:"model_analysis"`
    UserAnalysis   *UserAnalysis   `json:"user_analysis"`
    
    // 成本优化
    Optimization   *OptimizationAnalysis `json:"optimization"`
    
    // 预测和建议
    Forecast       *CostForecast   `json:"forecast"`
    Recommendations []string       `json:"recommendations"`
}

type CostSummary struct {
    TotalCost         decimal.Decimal `json:"total_cost"`
    TotalRequests     int64           `json:"total_requests"`
    TotalTokens       int64           `json:"total_tokens"`
    AvgCostPerRequest decimal.Decimal `json:"avg_cost_per_request"`
    AvgCostPerToken   decimal.Decimal `json:"avg_cost_per_token"`
    
    // 同比数据
    PreviousPeriodCost decimal.Decimal `json:"previous_period_cost"`
    CostChange        decimal.Decimal  `json:"cost_change"`
    CostChangePercent float64          `json:"cost_change_percent"`
    
    // 预算对比
    BudgetAllocated   decimal.Decimal `json:"budget_allocated"`
    BudgetUsed        decimal.Decimal `json:"budget_used"`
    BudgetRemaining   decimal.Decimal `json:"budget_remaining"`
    BudgetUtilization float64         `json:"budget_utilization"`
}

type ModelAnalysis struct {
    ModelCosts     []*ModelCostBreakdown `json:"model_costs"`
    TopModels      []*ModelUsageRank     `json:"top_models"`
    CostEfficiency []*ModelEfficiency    `json:"cost_efficiency"`
}

type ModelCostBreakdown struct {
    Model           string          `json:"model"`
    Provider        string          `json:"provider"`
    TotalCost       decimal.Decimal `json:"total_cost"`
    Requests        int64           `json:"requests"`
    Tokens          int64           `json:"tokens"`
    AvgCostPerReq   decimal.Decimal `json:"avg_cost_per_request"`
    CostPercentage  float64         `json:"cost_percentage"`
}

type OptimizationAnalysis struct {
    PotentialSavings decimal.Decimal `json:"potential_savings"`
    OptimizationOps  []*OptimizationOpportunity `json:"optimization_opportunities"`
    CacheImpact      *CacheImpactAnalysis `json:"cache_impact"`
    RoutingImpact    *RoutingImpactAnalysis `json:"routing_impact"`
}

type OptimizationOpportunity struct {
    Type            string          `json:"type"`
    Description     string          `json:"description"`
    PotentialSaving decimal.Decimal `json:"potential_saving"`
    Confidence      float64         `json:"confidence"`
    Implementation  string          `json:"implementation"`
    Priority        string          `json:"priority"`
}

func NewCostAnalyzer(storage *CostStorage, tracker *UsageTracker) *CostAnalyzer {
    return &CostAnalyzer{
        storage:      storage,
        usageTracker: tracker,
    }
}

func (ca *CostAnalyzer) GenerateReport(
    ctx context.Context,
    period *ReportPeriod,
    scope *ReportScope) (*CostReport, error) {
    
    report := &CostReport{
        ReportID:    fmt.Sprintf("cost_report_%d", time.Now().Unix()),
        Title:       fmt.Sprintf("成本分析报告 - %s", period.Description),
        Period:      period,
        GeneratedAt: time.Now(),
    }
    
    // 获取数据
    data, err := ca.collectData(ctx, period, scope)
    if err != nil {
        return nil, err
    }
    
    // 生成各部分分析
    report.Summary = ca.generateSummary(data, period)
    report.TrendAnalysis = ca.analyzeTrend(data)
    report.ModelAnalysis = ca.analyzeModels(data)
    report.UserAnalysis = ca.analyzeUsers(data)
    report.Optimization = ca.analyzeOptimization(data)
    report.Forecast = ca.generateForecast(data, period)
    report.Recommendations = ca.generateRecommendations(report)
    
    return report, nil
}

func (ca *CostAnalyzer) generateSummary(data []*UsageRecord, period *ReportPeriod) *CostSummary {
    summary := &CostSummary{}
    
    // 计算总体统计
    for _, record := range data {
        summary.TotalCost = summary.TotalCost.Add(record.TotalCost)
        summary.TotalRequests++
        summary.TotalTokens += int64(record.TotalTokens)
    }
    
    // 计算平均值
    if summary.TotalRequests > 0 {
        summary.AvgCostPerRequest = summary.TotalCost.Div(
            decimal.NewFromInt(summary.TotalRequests))
    }
    
    if summary.TotalTokens > 0 {
        summary.AvgCostPerToken = summary.TotalCost.Div(
            decimal.NewFromInt(summary.TotalTokens))
    }
    
    // 获取对比数据
    previousData := ca.getPreviousPeriodData(period)
    if len(previousData) > 0 {
        for _, record := range previousData {
            summary.PreviousPeriodCost = summary.PreviousPeriodCost.Add(record.TotalCost)
        }
        
        summary.CostChange = summary.TotalCost.Sub(summary.PreviousPeriodCost)
        if !summary.PreviousPeriodCost.IsZero() {
            summary.CostChangePercent = summary.CostChange.Div(
                summary.PreviousPeriodCost).InexactFloat64() * 100
        }
    }
    
    return summary
}

func (ca *CostAnalyzer) analyzeModels(data []*UsageRecord) *ModelAnalysis {
    // 按模型统计
    modelStats := make(map[string]*ModelCostBreakdown)
    totalCost := decimal.Zero
    
    for _, record := range data {
        model := record.Model
        if _, exists := modelStats[model]; !exists {
            modelStats[model] = &ModelCostBreakdown{
                Model:    model,
                Provider: record.Provider,
            }
        }
        
        stats := modelStats[model]
        stats.TotalCost = stats.TotalCost.Add(record.TotalCost)
        stats.Requests++
        stats.Tokens += int64(record.TotalTokens)
        
        totalCost = totalCost.Add(record.TotalCost)
    }
    
    // 转换为切片并计算百分比
    var modelCosts []*ModelCostBreakdown
    for _, stats := range modelStats {
        if stats.Requests > 0 {
            stats.AvgCostPerReq = stats.TotalCost.Div(
                decimal.NewFromInt(stats.Requests))
        }
        
        if !totalCost.IsZero() {
            stats.CostPercentage = stats.TotalCost.Div(totalCost).InexactFloat64() * 100
        }
        
        modelCosts = append(modelCosts, stats)
    }
    
    // 按成本排序
    sort.Slice(modelCosts, func(i, j int) bool {
        return modelCosts[i].TotalCost.GreaterThan(modelCosts[j].TotalCost)
    })
    
    return &ModelAnalysis{
        ModelCosts: modelCosts,
        TopModels:  ca.getTopModels(modelCosts, 5),
        CostEfficiency: ca.calculateModelEfficiency(modelCosts),
    }
}

func (ca *CostAnalyzer) analyzeOptimization(data []*UsageRecord) *OptimizationAnalysis {
    optimization := &OptimizationAnalysis{
        OptimizationOps: make([]*OptimizationOpportunity, 0),
    }
    
    // 分析缓存优化机会
    cacheOpportunity := ca.analyzeCacheOptimization(data)
    if cacheOpportunity != nil {
        optimization.OptimizationOps = append(optimization.OptimizationOps, cacheOpportunity)
        optimization.PotentialSavings = optimization.PotentialSavings.Add(
            cacheOpportunity.PotentialSaving)
    }
    
    // 分析模型路由优化
    routingOpportunity := ca.analyzeRoutingOptimization(data)
    if routingOpportunity != nil {
        optimization.OptimizationOps = append(optimization.OptimizationOps, routingOpportunity)
        optimization.PotentialSavings = optimization.PotentialSavings.Add(
            routingOpportunity.PotentialSaving)
    }
    
    // 分析预算优化
    budgetOpportunity := ca.analyzeBudgetOptimization(data)
    if budgetOpportunity != nil {
        optimization.OptimizationOps = append(optimization.OptimizationOps, budgetOpportunity)
    }
    
    return optimization
}

func (ca *CostAnalyzer) analyzeCacheOptimization(data []*UsageRecord) *OptimizationOpportunity {
    // 计算重复查询
    queryFreq := make(map[string]int)
    totalCost := decimal.Zero
    
    for _, record := range data {
        queryFreq[record.Query]++
        totalCost = totalCost.Add(record.TotalCost)
    }
    
    // 找出重复查询的成本
    duplicateCost := decimal.Zero
    for query, freq := range queryFreq {
        if freq > 1 {
            // 估算这些重复查询的成本
            for _, record := range data {
                if record.Query == query {
                    duplicateCost = duplicateCost.Add(record.TotalCost)
                    break
                }
            }
            duplicateCost = duplicateCost.Mul(decimal.NewFromInt(int64(freq - 1)))
        }
    }
    
    if duplicateCost.GreaterThan(decimal.Zero) {
        // 假设缓存可以节省80%的重复查询成本
        potentialSaving := duplicateCost.Mul(decimal.NewFromFloat(0.8))
        
        return &OptimizationOpportunity{
            Type:            "cache_optimization",
            Description:     "通过提升缓存命中率减少重复查询成本",
            PotentialSaving: potentialSaving,
            Confidence:      0.8,
            Implementation:  "优化缓存策略，增加相似查询匹配",
            Priority:        "high",
        }
    }
    
    return nil
}

func (ca *CostAnalyzer) generateRecommendations(report *CostReport) []string {
    var recommendations []string
    
    // 基于成本趋势的建议
    if report.TrendAnalysis.Direction == "increasing" && 
       report.TrendAnalysis.Strength > 0.5 {
        recommendations = append(recommendations,
            "成本呈明显上升趋势，建议立即检查成本控制策略")
    }
    
    // 基于模型使用的建议
    if len(report.ModelAnalysis.ModelCosts) > 0 {
        topModel := report.ModelAnalysis.ModelCosts[0]
        if topModel.CostPercentage > 60 {
            recommendations = append(recommendations,
                fmt.Sprintf("模型%s占用成本过高(%.1f%%)，建议评估是否可用更经济的替代模型",
                    topModel.Model, topModel.CostPercentage))
        }
    }
    
    // 基于优化机会的建议
    for _, opp := range report.Optimization.OptimizationOps {
        if opp.Confidence > 0.7 && opp.Priority == "high" {
            recommendations = append(recommendations, opp.Implementation)
        }
    }
    
    // 基于预算使用的建议
    if report.Summary.BudgetUtilization > 0.9 {
        recommendations = append(recommendations,
            "预算使用率过高，建议增加预算或优化使用策略")
    }
    
    return recommendations
}
```

---

## 🛠️ 配置和部署

### 成本控制配置示例

```yaml
# config/cost_config.yaml
cost_control:
  # 预算配置
  budgets:
    user_daily: "5.00"
    department_weekly: "500.00" 
    company_monthly: "10000.00"
    
  # 告警阈值
  alert_thresholds:
    warning: 0.8
    critical: 0.9
    emergency: 0.95
    
  # 控制策略
  controls:
    enable_auto_limit: true
    enable_emergency_stop: true
    grace_period: "5m"
    cooldown_period: "1h"
    
  # 模型成本配置
  model_costs:
    gpt-4o-mini:
      input_cost_per_1k: "0.150"
      output_cost_per_1k: "0.600"
      provider: "openai"
      last_updated: "2025-01-01T00:00:00Z"
      
    claude-3.5-sonnet:
      input_cost_per_1k: "3.000"
      output_cost_per_1k: "15.000"
      provider: "anthropic"
      last_updated: "2025-01-01T00:00:00Z"
      
    deepseek-coder:
      input_cost_per_1k: "0.140"
      output_cost_per_1k: "0.280"
      provider: "deepseek"
      last_updated: "2025-01-01T00:00:00Z"
      
    ollama-llama3:
      input_cost_per_1k: "0.000"
      output_cost_per_1k: "0.000"
      provider: "ollama"
      last_updated: "2025-01-01T00:00:00Z"
      
# 告警配置
alerts:
  # 通知渠道
  notifiers:
    - type: "email"
      config:
        smtp_host: "smtp.company.com"
        smtp_port: 587
        from: "alerts@company.com"
        to: ["admin@company.com"]
        
    - type: "slack"
      config:
        webhook_url: "${SLACK_WEBHOOK_URL}"
        channel: "#cost-alerts"
        
    - type: "wechat"
      config:
        corp_id: "${WECHAT_CORP_ID}"
        corp_secret: "${WECHAT_CORP_SECRET}"
        
  # 告警规则
  rules:
    - id: "daily_cost_limit"
      name: "每日成本限制"
      metric: "daily_cost"
      threshold: 100.0
      operator: ">"
      actions: ["notify", "throttle"]
      
    - id: "budget_warning"
      name: "预算警告"
      metric: "budget_usage"
      threshold: 0.8
      operator: ">="
      actions: ["notify"]
      
# 数据存储配置
storage:
  # PostgreSQL配置
  postgres:
    host: "localhost"
    port: 5432
    database: "chat2sql_cost"
    username: "${POSTGRES_USER}"
    password: "${POSTGRES_PASSWORD}"
    
  # 数据保留策略
  retention:
    usage_records: "90d"    # 使用记录保留90天
    alerts: "30d"           # 告警记录保留30天
    reports: "365d"         # 报告保留1年
```

### 部署脚本

```bash
#!/bin/bash
# deploy/deploy_cost_control.sh

set -e

echo "💰 部署成本控制系统..."

# 1. 创建数据库
echo "📊 初始化数据库..."
psql -h localhost -U postgres -c "CREATE DATABASE IF NOT EXISTS chat2sql_cost;"

# 执行数据库迁移
migrate -path migrations -database "postgres://postgres:password@localhost/chat2sql_cost?sslmode=disable" up

# 2. 部署配置文件
echo "⚙️ 部署配置文件..."
cp config/cost_config.yaml /etc/chat2sql/

# 3. 启动成本控制服务
echo "🔧 启动成本控制服务..."
./bin/cost-controller \
  --config=/etc/chat2sql/cost_config.yaml \
  --log-level=info \
  --metrics-port=9091

echo "✅ 成本控制系统部署完成！"
echo "💰 成本API: http://localhost:8081/api/v1/cost"
echo "📊 监控面板: http://localhost:9091/metrics"
```

---

<div align="center">

**💰 成本控制成功关键：实时监控 + 智能预测 + 自动化控制**

</div>