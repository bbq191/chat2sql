# ğŸ” å‘é‡æœç´¢å¼•æ“å®ç°æŒ‡å—

<div align="center">

![Vector Search](https://img.shields.io/badge/Vector_Search-Semantic_Engine-blue.svg)
![Similarity](https://img.shields.io/badge/Similarity-Cosine-green.svg)
![Performance](https://img.shields.io/badge/Performance-<100ms-orange.svg)

**Chat2SQL P3é˜¶æ®µ - è¯­ä¹‰æœç´¢å¼•æ“å®Œæ•´å®ç°æ–¹æ¡ˆ**

</div>

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸“é—¨é’ˆå¯¹Chat2SQLç³»ç»Ÿçš„å‘é‡æœç´¢å¼•æ“å®ç°ï¼Œæä¾›ä»æ¶æ„è®¾è®¡åˆ°ä»£ç å®ç°çš„å®Œæ•´æŠ€æœ¯æ–¹æ¡ˆï¼Œå®ç°é«˜æ€§èƒ½çš„è¯­ä¹‰ç›¸ä¼¼åº¦æœç´¢èƒ½åŠ›ã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### è¯­ä¹‰æœç´¢èƒ½åŠ›
- âœ… **Schemaè¯­ä¹‰åŒ¹é…**ï¼šåŸºäºå‘é‡ç›¸ä¼¼åº¦çš„æ•°æ®åº“ç»“æ„åŒ¹é…
- âœ… **æŸ¥è¯¢å†å²æ£€ç´¢**ï¼šç›¸ä¼¼æŸ¥è¯¢æ¨¡å¼è¯†åˆ«å’Œæ¨è
- âœ… **ä¸Šä¸‹æ–‡å¢å¼º**ï¼šæ™ºèƒ½ä¸šåŠ¡ä¸Šä¸‹æ–‡æ¨ç†
- âœ… **å¤šæ¨¡æ€æœç´¢**ï¼šæ”¯æŒæ–‡æœ¬ã€ç»“æ„åŒ–æ•°æ®çš„æ··åˆæœç´¢

### æ€§èƒ½æŒ‡æ ‡
| æœç´¢ç±»å‹ | å“åº”æ—¶é—´ | å‡†ç¡®ç‡ | å¹¶å‘èƒ½åŠ› |
|---------|---------|--------|----------|
| **SchemaåŒ¹é…** | < 50ms | > 90% | 100 QPS |
| **æŸ¥è¯¢æ£€ç´¢** | < 80ms | > 85% | 80 QPS |
| **ä¸Šä¸‹æ–‡æœç´¢** | < 100ms | > 80% | 50 QPS |

---

## ğŸ—ï¸ æœç´¢å¼•æ“æ¶æ„

### ğŸ“¦ æ ¸å¿ƒç»„ä»¶è®¾è®¡

```go
// internal/vector/search_engine.go
package vector

import (
    "context"
    "fmt"
    "sort"
    "sync"
    "time"
    
    "github.com/qdrant/go-client/qdrant"
)

type VectorSearchEngine struct {
    // æ ¸å¿ƒæœåŠ¡
    qdrantService    *QdrantService
    embeddingService *EmbeddingService
    
    // ç¼“å­˜å±‚
    searchCache      *SearchCache
    embeddingCache   *EmbeddingCache
    
    // é…ç½®å’Œç›‘æ§
    config          *SearchConfig
    metrics         *SearchMetrics
    
    // å¹¶å‘æ§åˆ¶
    semaphore       chan struct{}
    mu              sync.RWMutex
}

type SearchConfig struct {
    // æœç´¢é…ç½®
    MaxResults      int     `yaml:"max_results"`       // 20
    MinSimilarity   float32 `yaml:"min_similarity"`    // 0.7
    SearchTimeout   time.Duration `yaml:"search_timeout"` // 5s
    
    // å¹¶å‘é…ç½®
    MaxConcurrent   int `yaml:"max_concurrent"`  // 10
    BatchSize       int `yaml:"batch_size"`      // 100
    
    // ç¼“å­˜é…ç½®
    CacheEnabled    bool          `yaml:"cache_enabled"`  // true
    CacheTTL        time.Duration `yaml:"cache_ttl"`      // 1h
    
    // æœç´¢ç­–ç•¥
    UseHybridSearch bool    `yaml:"use_hybrid_search"` // true
    WeightVector    float32 `yaml:"weight_vector"`     // 0.7
    WeightKeyword   float32 `yaml:"weight_keyword"`    // 0.3
}
```

### ğŸ”§ æœç´¢å¼•æ“åˆå§‹åŒ–

```go
func NewVectorSearchEngine(
    qdrantService *QdrantService,
    embeddingService *EmbeddingService,
    config *SearchConfig) (*VectorSearchEngine, error) {
    
    engine := &VectorSearchEngine{
        qdrantService:    qdrantService,
        embeddingService: embeddingService,
        config:          config,
        metrics:         NewSearchMetrics(),
        semaphore:       make(chan struct{}, config.MaxConcurrent),
        searchCache:     NewSearchCache(config.CacheTTL),
        embeddingCache:  NewEmbeddingCache(config.CacheTTL),
    }
    
    // é¢„çƒ­ç¼“å­˜
    if err := engine.warmupCache(); err != nil {
        log.Warn("æœç´¢å¼•æ“ç¼“å­˜é¢„çƒ­å¤±è´¥", zap.Error(err))
    }
    
    return engine, nil
}

func (vse *VectorSearchEngine) warmupCache() error {
    // é¢„åŠ è½½å¸¸ç”¨Schemaå‘é‡
    commonSchemas := []string{
        "ç”¨æˆ·è¡¨", "è®¢å•è¡¨", "å•†å“è¡¨", "ç”¨æˆ·ä¿¡æ¯", "è®¢å•ä¿¡æ¯",
    }
    
    for _, schema := range commonSchemas {
        _, err := vse.embeddingService.EmbedQuery(context.Background(), schema)
        if err != nil {
            log.Warn("Schemaå‘é‡é¢„çƒ­å¤±è´¥", zap.String("schema", schema), zap.Error(err))
        }
    }
    
    return nil
}
```

---

## ğŸ—ƒï¸ Schemaè¯­ä¹‰æœç´¢

### Schemaå‘é‡åŒ¹é…å®ç°

```go
func (vse *VectorSearchEngine) SearchSimilarSchemas(
    ctx context.Context,
    query string,
    connectionID int64,
    limit int) (*SchemaSearchResult, error) {
    
    start := time.Now()
    defer func() {
        vse.metrics.RecordSearchDuration("schema", time.Since(start))
    }()
    
    // 1. æ£€æŸ¥ç¼“å­˜
    cacheKey := fmt.Sprintf("schema:%d:%s:%d", connectionID, query, limit)
    if cached := vse.searchCache.Get(cacheKey); cached != nil {
        vse.metrics.RecordCacheHit("schema")
        return cached.(*SchemaSearchResult), nil
    }
    vse.metrics.RecordCacheMiss("schema")
    
    // 2. ç”ŸæˆæŸ¥è¯¢å‘é‡
    queryVector, err := vse.embeddingService.EmbedQuery(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢å‘é‡åŒ–å¤±è´¥: %w", err)
    }
    
    // 3. æ„å»ºæœç´¢è¯·æ±‚
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.qdrantService.config.Collections.SchemaCollection,
        Vector:         queryVector,
        Limit:          uint64(limit),
        WithPayload:    qdrant.NewWithPayload(true),
        ScoreThreshold: &vse.config.MinSimilarity,
        Filter: vse.buildSchemaFilter(connectionID),
    }
    
    // 4. æ‰§è¡Œå‘é‡æœç´¢
    searchResult, err := vse.qdrantService.client.Search(ctx, searchReq)
    if err != nil {
        vse.metrics.RecordSearchError("schema")
        return nil, fmt.Errorf("å‘é‡æœç´¢å¤±è´¥: %w", err)
    }
    
    // 5. è½¬æ¢æœç´¢ç»“æœ
    result := vse.convertSchemaSearchResult(searchResult, query)
    
    // 6. ç¼“å­˜ç»“æœ
    vse.searchCache.Set(cacheKey, result)
    
    vse.metrics.RecordSearchSuccess("schema", len(result.Matches))
    return result, nil
}

func (vse *VectorSearchEngine) buildSchemaFilter(connectionID int64) *qdrant.Filter {
    return &qdrant.Filter{
        Must: []*qdrant.Condition{
            {
                ConditionOneOf: &qdrant.Condition_Field{
                    Field: &qdrant.FieldCondition{
                        Key: "connection_id",
                        Match: &qdrant.Match{
                            MatchValue: &qdrant.Match_Integer{
                                Integer: connectionID,
                            },
                        },
                    },
                },
            },
            {
                ConditionOneOf: &qdrant.Condition_Field{
                    Field: &qdrant.FieldCondition{
                        Key: "is_active",
                        Match: &qdrant.Match{
                            MatchValue: &qdrant.Match_Bool{
                                Bool: true,
                            },
                        },
                    },
                },
            },
        },
    }
}

func (vse *VectorSearchEngine) convertSchemaSearchResult(
    searchResult *qdrant.SearchResponse,
    originalQuery string) *SchemaSearchResult {
    
    var matches []*SchemaMatch
    
    for _, hit := range searchResult.GetResult() {
        match := &SchemaMatch{
            TableName:     hit.Payload["table_name"].GetStringValue(),
            SchemaName:    hit.Payload["schema_name"].GetStringValue(),
            Description:   hit.Payload["description"].GetStringValue(),
            Similarity:    hit.Score,
            Confidence:    vse.calculateConfidence(hit.Score),
            Columns:       vse.parseColumns(hit.Payload["columns"]),
            Metadata: &SchemaMetadata{
                ConnectionID: hit.Payload["connection_id"].GetIntegerValue(),
                TableID:     hit.Payload["table_id"].GetIntegerValue(),
                CreatedAt:   vse.parseTimestamp(hit.Payload["created_at"]),
                UpdatedAt:   vse.parseTimestamp(hit.Payload["updated_at"]),
            },
        }
        
        // å¢å¼ºåŒ¹é…ä¿¡æ¯
        match.MatchReasons = vse.analyzeMatchReasons(originalQuery, match)
        match.RelevanceScore = vse.calculateRelevanceScore(match)
        
        matches = append(matches, match)
    }
    
    // æŒ‰ç›¸å…³æ€§æ’åº
    sort.Slice(matches, func(i, j int) bool {
        return matches[i].RelevanceScore > matches[j].RelevanceScore
    })
    
    return &SchemaSearchResult{
        Query:         originalQuery,
        Matches:       matches,
        TotalMatches:  len(matches),
        SearchTime:    time.Now(),
        ProcessingTime: searchResult.Time,
    }
}
```

### æ™ºèƒ½åŒ¹é…åˆ†æ

```go
func (vse *VectorSearchEngine) analyzeMatchReasons(
    query string, 
    match *SchemaMatch) []string {
    
    var reasons []string
    queryLower := strings.ToLower(query)
    
    // è¡¨ååŒ¹é…
    if strings.Contains(queryLower, strings.ToLower(match.TableName)) {
        reasons = append(reasons, "è¡¨åç›´æ¥åŒ¹é…")
    }
    
    // æè¿°åŒ¹é…
    if match.Description != "" && 
       vse.calculateTextSimilarity(queryLower, strings.ToLower(match.Description)) > 0.6 {
        reasons = append(reasons, "æè¿°è¯­ä¹‰åŒ¹é…")
    }
    
    // å­—æ®µåŒ¹é…
    for _, column := range match.Columns {
        if strings.Contains(queryLower, strings.ToLower(column.Name)) {
            reasons = append(reasons, fmt.Sprintf("å­—æ®µåŒ¹é…: %s", column.Name))
        }
        if column.Comment != "" && 
           strings.Contains(queryLower, strings.ToLower(column.Comment)) {
            reasons = append(reasons, fmt.Sprintf("å­—æ®µæ³¨é‡ŠåŒ¹é…: %s", column.Name))
        }
    }
    
    // ä¸šåŠ¡é¢†åŸŸåŒ¹é…
    domainKeywords := vse.extractDomainKeywords(queryLower)
    tableDomain := vse.inferTableDomain(match.TableName)
    for _, keyword := range domainKeywords {
        if strings.Contains(tableDomain, keyword) {
            reasons = append(reasons, fmt.Sprintf("ä¸šåŠ¡é¢†åŸŸåŒ¹é…: %s", keyword))
        }
    }
    
    if len(reasons) == 0 {
        reasons = append(reasons, "å‘é‡è¯­ä¹‰ç›¸ä¼¼")
    }
    
    return reasons
}

func (vse *VectorSearchEngine) calculateRelevanceScore(match *SchemaMatch) float64 {
    score := float64(match.Similarity) * 0.6 // å‘é‡ç›¸ä¼¼åº¦æƒé‡60%
    
    // è¡¨åæƒé‡ 20%
    if len(match.MatchReasons) > 0 {
        for _, reason := range match.MatchReasons {
            if strings.Contains(reason, "è¡¨åç›´æ¥åŒ¹é…") {
                score += 0.2
                break
            }
        }
    }
    
    // å­—æ®µåŒ¹é…æƒé‡ 15%
    fieldMatchCount := 0
    for _, reason := range match.MatchReasons {
        if strings.Contains(reason, "å­—æ®µåŒ¹é…") {
            fieldMatchCount++
        }
    }
    if fieldMatchCount > 0 {
        score += 0.15 * math.Min(float64(fieldMatchCount)/5.0, 1.0)
    }
    
    // ä¸šåŠ¡é¢†åŸŸæƒé‡ 5%
    for _, reason := range match.MatchReasons {
        if strings.Contains(reason, "ä¸šåŠ¡é¢†åŸŸåŒ¹é…") {
            score += 0.05
            break
        }
    }
    
    return math.Min(score, 1.0)
}
```

---

## ğŸ“š æŸ¥è¯¢å†å²æœç´¢

### å†å²æŸ¥è¯¢æ£€ç´¢å®ç°

```go
func (vse *VectorSearchEngine) SearchSimilarQueries(
    ctx context.Context,
    query string,
    userID int64,
    limit int) (*QuerySearchResult, error) {
    
    start := time.Now()
    defer func() {
        vse.metrics.RecordSearchDuration("query", time.Since(start))
    }()
    
    // 1. æ£€æŸ¥ç¼“å­˜
    cacheKey := fmt.Sprintf("query:%d:%s:%d", userID, query, limit)
    if cached := vse.searchCache.Get(cacheKey); cached != nil {
        vse.metrics.RecordCacheHit("query")
        return cached.(*QuerySearchResult), nil
    }
    
    // 2. ç”ŸæˆæŸ¥è¯¢å‘é‡
    queryVector, err := vse.embeddingService.EmbedQuery(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢å‘é‡åŒ–å¤±è´¥: %w", err)
    }
    
    // 3. å¤šç­–ç•¥æœç´¢
    personalResults, err := vse.searchPersonalQueries(ctx, queryVector, userID, limit/2)
    if err != nil {
        return nil, err
    }
    
    globalResults, err := vse.searchGlobalQueries(ctx, queryVector, limit/2)
    if err != nil {
        return nil, err
    }
    
    // 4. åˆå¹¶å’Œæ’åºç»“æœ
    result := vse.mergeQueryResults(personalResults, globalResults, query)
    
    // 5. ç¼“å­˜ç»“æœ
    vse.searchCache.Set(cacheKey, result)
    
    vse.metrics.RecordSearchSuccess("query", len(result.Matches))
    return result, nil
}

func (vse *VectorSearchEngine) searchPersonalQueries(
    ctx context.Context,
    queryVector []float32,
    userID int64,
    limit int) ([]*QueryMatch, error) {
    
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.qdrantService.config.Collections.QueryCollection,
        Vector:         queryVector,
        Limit:          uint64(limit),
        WithPayload:    qdrant.NewWithPayload(true),
        ScoreThreshold: &[]float32{0.8}[0], // ä¸ªäººæŸ¥è¯¢è¦æ±‚æ›´é«˜ç›¸ä¼¼åº¦
        Filter: &qdrant.Filter{
            Must: []*qdrant.Condition{
                {
                    ConditionOneOf: &qdrant.Condition_Field{
                        Field: &qdrant.FieldCondition{
                            Key: "user_id",
                            Match: &qdrant.Match{
                                MatchValue: &qdrant.Match_Integer{
                                    Integer: userID,
                                },
                            },
                        },
                    },
                },
            },
        },
    }
    
    searchResult, err := vse.qdrantService.client.Search(ctx, searchReq)
    if err != nil {
        return nil, err
    }
    
    return vse.convertQueryMatches(searchResult, "personal"), nil
}

func (vse *VectorSearchEngine) searchGlobalQueries(
    ctx context.Context,
    queryVector []float32,
    limit int) ([]*QueryMatch, error) {
    
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.qdrantService.config.Collections.QueryCollection,
        Vector:         queryVector,
        Limit:          uint64(limit),
        WithPayload:    qdrant.NewWithPayload(true),
        ScoreThreshold: &vse.config.MinSimilarity,
        Filter: &qdrant.Filter{
            Must: []*qdrant.Condition{
                {
                    ConditionOneOf: &qdrant.Condition_Field{
                        Field: &qdrant.FieldCondition{
                            Key: "success_rate",
                            Range: &qdrant.Range{
                                Gte: &[]float64{0.8}[0], // æˆåŠŸç‡ >= 80%
                            },
                        },
                    },
                },
                {
                    ConditionOneOf: &qdrant.Condition_Field{
                        Field: &qdrant.FieldCondition{
                            Key: "usage_count",
                            Range: &qdrant.Range{
                                Gte: &[]float64{5}[0], // ä½¿ç”¨æ¬¡æ•° >= 5
                            },
                        },
                    },
                },
            },
        },
    }
    
    searchResult, err := vse.qdrantService.client.Search(ctx, searchReq)
    if err != nil {
        return nil, err
    }
    
    return vse.convertQueryMatches(searchResult, "global"), nil
}

func (vse *VectorSearchEngine) convertQueryMatches(
    searchResult *qdrant.SearchResponse, 
    source string) []*QueryMatch {
    
    var matches []*QueryMatch
    
    for _, hit := range searchResult.GetResult() {
        match := &QueryMatch{
            OriginalQuery:  hit.Payload["original_query"].GetStringValue(),
            GeneratedSQL:   hit.Payload["generated_sql"].GetStringValue(),
            Similarity:     hit.Score,
            UsageCount:     int(hit.Payload["usage_count"].GetIntegerValue()),
            SuccessRate:    float64(hit.Payload["success_rate"].GetDoubleValue()),
            Source:         source,
            LastUsed:       vse.parseTimestamp(hit.Payload["last_used"]),
            
            // è®¡ç®—ä¿¡ä»»åº¦
            TrustScore: vse.calculateTrustScore(
                float64(hit.Score),
                int(hit.Payload["usage_count"].GetIntegerValue()),
                float64(hit.Payload["success_rate"].GetDoubleValue()),
            ),
        }
        
        matches = append(matches, match)
    }
    
    return matches
}

func (vse *VectorSearchEngine) calculateTrustScore(
    similarity float64,
    usageCount int,
    successRate float64) float64 {
    
    // ä¿¡ä»»åº¦ = ç›¸ä¼¼åº¦ * ä½¿ç”¨é¢‘ç‡å› å­ * æˆåŠŸç‡
    usageFactor := math.Min(float64(usageCount)/100.0, 1.0) // ä½¿ç”¨æ¬¡æ•°å½’ä¸€åŒ–
    return similarity * (0.3 + 0.7*usageFactor) * successRate
}
```

---

## ğŸ§  æ··åˆæœç´¢å¼•æ“

### å‘é‡+å…³é”®è¯æ··åˆæœç´¢

```go
func (vse *VectorSearchEngine) HybridSearch(
    ctx context.Context,
    query string,
    searchType SearchType,
    options *SearchOptions) (*HybridSearchResult, error) {
    
    var wg sync.WaitGroup
    var vectorResults interface{}
    var keywordResults interface{}
    var vectorErr, keywordErr error
    
    // å¹¶è¡Œæ‰§è¡Œå‘é‡æœç´¢å’Œå…³é”®è¯æœç´¢
    wg.Add(2)
    
    // å‘é‡æœç´¢
    go func() {
        defer wg.Done()
        vectorResults, vectorErr = vse.performVectorSearch(ctx, query, searchType, options)
    }()
    
    // å…³é”®è¯æœç´¢
    go func() {
        defer wg.Done()
        keywordResults, keywordErr = vse.performKeywordSearch(ctx, query, searchType, options)
    }()
    
    wg.Wait()
    
    if vectorErr != nil && keywordErr != nil {
        return nil, fmt.Errorf("å‘é‡æœç´¢å’Œå…³é”®è¯æœç´¢éƒ½å¤±è´¥: vector=%v, keyword=%v", vectorErr, keywordErr)
    }
    
    // èåˆç»“æœ
    result := vse.fuseSearchResults(vectorResults, keywordResults, options)
    
    return result, nil
}

func (vse *VectorSearchEngine) performKeywordSearch(
    ctx context.Context,
    query string,
    searchType SearchType,
    options *SearchOptions) (interface{}, error) {
    
    // æå–å…³é”®è¯
    keywords := vse.extractKeywords(query)
    
    // æ„å»ºå…³é”®è¯è¿‡æ»¤å™¨
    filter := vse.buildKeywordFilter(keywords, searchType, options)
    
    // æ‰§è¡ŒåŸºäºè¿‡æ»¤å™¨çš„æœç´¢
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.getCollectionName(searchType),
        Vector:         make([]float32, vse.config.VectorSize), // é›¶å‘é‡
        Limit:          uint64(options.Limit),
        WithPayload:    qdrant.NewWithPayload(true),
        Filter:         filter,
    }
    
    return vse.qdrantService.client.Search(ctx, searchReq)
}

func (vse *VectorSearchEngine) extractKeywords(query string) []string {
    // ç®€å•çš„å…³é”®è¯æå–ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„NLPå·¥å…·
    words := strings.Fields(strings.ToLower(query))
    
    // è¿‡æ»¤åœç”¨è¯
    stopWords := map[string]bool{
        "çš„": true, "æ˜¯": true, "åœ¨": true, "æœ‰": true, "å’Œ": true,
        "æˆ–": true, "ä½†": true, "ä»": true, "åˆ°": true, "ä¸": true,
    }
    
    var keywords []string
    for _, word := range words {
        if !stopWords[word] && len(word) > 1 {
            keywords = append(keywords, word)
        }
    }
    
    return keywords
}

func (vse *VectorSearchEngine) buildKeywordFilter(
    keywords []string,
    searchType SearchType,
    options *SearchOptions) *qdrant.Filter {
    
    var conditions []*qdrant.Condition
    
    // å…³é”®è¯åŒ¹é…æ¡ä»¶
    for _, keyword := range keywords {
        conditions = append(conditions, &qdrant.Condition{
            ConditionOneOf: &qdrant.Condition_Field{
                Field: &qdrant.FieldCondition{
                    Key: "searchable_text",
                    Match: &qdrant.Match{
                        MatchValue: &qdrant.Match_Text{
                            Text: keyword,
                        },
                    },
                },
            },
        })
    }
    
    return &qdrant.Filter{
        Should: conditions, // ORæ¡ä»¶
    }
}

func (vse *VectorSearchEngine) fuseSearchResults(
    vectorResults, keywordResults interface{},
    options *SearchOptions) *HybridSearchResult {
    
    // ç»“æœèåˆç®—æ³•
    vectorWeight := vse.config.WeightVector
    keywordWeight := vse.config.WeightKeyword
    
    fusedMatches := make(map[string]*FusedMatch)
    
    // å¤„ç†å‘é‡æœç´¢ç»“æœ
    if vectorResults != nil {
        vse.processVectorResults(vectorResults, vectorWeight, fusedMatches)
    }
    
    // å¤„ç†å…³é”®è¯æœç´¢ç»“æœ  
    if keywordResults != nil {
        vse.processKeywordResults(keywordResults, keywordWeight, fusedMatches)
    }
    
    // è½¬æ¢ä¸ºæ’åºåˆ—è¡¨
    var finalMatches []*FusedMatch
    for _, match := range fusedMatches {
        finalMatches = append(finalMatches, match)
    }
    
    // æŒ‰èåˆåˆ†æ•°æ’åº
    sort.Slice(finalMatches, func(i, j int) bool {
        return finalMatches[i].FusedScore > finalMatches[j].FusedScore
    })
    
    // é™åˆ¶ç»“æœæ•°é‡
    if len(finalMatches) > options.Limit {
        finalMatches = finalMatches[:options.Limit]
    }
    
    return &HybridSearchResult{
        Matches:     finalMatches,
        TotalCount:  len(finalMatches),
        SearchTime:  time.Now(),
        FusionStrategy: fmt.Sprintf("vector:%.2f+keyword:%.2f", vectorWeight, keywordWeight),
    }
}
```

---

## ğŸ“Š æœç´¢ç»“æœä¼˜åŒ–

### æ™ºèƒ½æ’åºç®—æ³•

```go
type ResultRanker struct {
    config *RankingConfig
}

type RankingConfig struct {
    // æ’åºæƒé‡
    SimilarityWeight   float64 `yaml:"similarity_weight"`    // 0.4
    FreshnessWeight    float64 `yaml:"freshness_weight"`     // 0.2
    PopularityWeight   float64 `yaml:"popularity_weight"`    // 0.2
    RelevanceWeight    float64 `yaml:"relevance_weight"`     // 0.2
    
    // æ—¶é—´è¡°å‡
    TimeDecayFactor    float64 `yaml:"time_decay_factor"`    // 0.1
    MaxAgeHours        int     `yaml:"max_age_hours"`        // 168 (7å¤©)
}

func (rr *ResultRanker) RankSearchResults(results []*SearchMatch) []*SearchMatch {
    now := time.Now()
    
    for _, result := range results {
        // è®¡ç®—ç»¼åˆåˆ†æ•°
        result.RankingScore = rr.calculateRankingScore(result, now)
    }
    
    // æ’åº
    sort.Slice(results, func(i, j int) bool {
        return results[i].RankingScore > results[j].RankingScore
    })
    
    return results
}

func (rr *ResultRanker) calculateRankingScore(match *SearchMatch, now time.Time) float64 {
    // ç›¸ä¼¼åº¦åˆ†æ•°
    similarityScore := float64(match.Similarity)
    
    // æ–°é²œåº¦åˆ†æ•° (æ—¶é—´è¡°å‡)
    ageHours := now.Sub(match.LastUsed).Hours()
    freshnessScore := math.Exp(-rr.config.TimeDecayFactor * ageHours / float64(rr.config.MaxAgeHours))
    
    // æµè¡Œåº¦åˆ†æ•° (ä½¿ç”¨æ¬¡æ•°å½’ä¸€åŒ–)
    popularityScore := math.Min(float64(match.UsageCount)/100.0, 1.0)
    
    // ç›¸å…³æ€§åˆ†æ•° (åŸºäºåŒ¹é…åŸå› )
    relevanceScore := rr.calculateRelevanceScore(match)
    
    // åŠ æƒæ±‚å’Œ
    finalScore := similarityScore*rr.config.SimilarityWeight +
                  freshnessScore*rr.config.FreshnessWeight +
                  popularityScore*rr.config.PopularityWeight +
                  relevanceScore*rr.config.RelevanceWeight
    
    return finalScore
}

func (rr *ResultRanker) calculateRelevanceScore(match *SearchMatch) float64 {
    score := 0.5 // åŸºç¡€åˆ†æ•°
    
    // åŸºäºåŒ¹é…åŸå› è°ƒæ•´
    for _, reason := range match.MatchReasons {
        switch {
        case strings.Contains(reason, "ç›´æ¥åŒ¹é…"):
            score += 0.3
        case strings.Contains(reason, "è¯­ä¹‰åŒ¹é…"):
            score += 0.2
        case strings.Contains(reason, "å­—æ®µåŒ¹é…"):
            score += 0.15
        case strings.Contains(reason, "ä¸šåŠ¡é¢†åŸŸ"):
            score += 0.1
        }
    }
    
    return math.Min(score, 1.0)
}
```

### æœç´¢ç»“æœèšåˆ

```go
func (vse *VectorSearchEngine) AggregateSearchResults(
    results []*SearchMatch,
    aggregationType AggregationType) *AggregatedResult {
    
    switch aggregationType {
    case AggregateByTable:
        return vse.aggregateByTable(results)
    case AggregateByDomain:
        return vse.aggregateByDomain(results)
    case AggregateByConfidence:
        return vse.aggregateByConfidence(results)
    default:
        return vse.defaultAggregation(results)
    }
}

func (vse *VectorSearchEngine) aggregateByTable(results []*SearchMatch) *AggregatedResult {
    tableGroups := make(map[string][]*SearchMatch)
    
    for _, result := range results {
        tableName := result.TableName
        tableGroups[tableName] = append(tableGroups[tableName], result)
    }
    
    var aggregates []*TableAggregate
    for tableName, matches := range tableGroups {
        // è®¡ç®—è¡¨çº§åˆ«ç»Ÿè®¡
        avgSimilarity := vse.calculateAverageSimilarity(matches)
        maxSimilarity := vse.calculateMaxSimilarity(matches)
        totalUsage := vse.calculateTotalUsage(matches)
        
        aggregate := &TableAggregate{
            TableName:       tableName,
            MatchCount:      len(matches),
            AvgSimilarity:   avgSimilarity,
            MaxSimilarity:   maxSimilarity,
            TotalUsage:      totalUsage,
            BestMatch:       matches[0], // å·²ç»æŒ‰åˆ†æ•°æ’åº
            AllMatches:      matches,
        }
        
        aggregates = append(aggregates, aggregate)
    }
    
    // æŒ‰åŒ¹é…è´¨é‡æ’åº
    sort.Slice(aggregates, func(i, j int) bool {
        return aggregates[i].MaxSimilarity > aggregates[j].MaxSimilarity
    })
    
    return &AggregatedResult{
        Type:        AggregateByTable,
        TableGroups: aggregates,
        Summary: &AggregationSummary{
            TotalTables:    len(aggregates),
            TotalMatches:   len(results),
            AvgConfidence:  vse.calculateOverallConfidence(results),
        },
    }
}
```

---

## ğŸ” æœç´¢åˆ†æå·¥å…·

### æœç´¢è´¨é‡è¯„ä¼°

```go
type SearchQualityAnalyzer struct {
    searchEngine *VectorSearchEngine
    testDataset  []*TestQuery
}

type TestQuery struct {
    Query           string   `json:"query"`
    ExpectedTables  []string `json:"expected_tables"`
    ExpectedSQL     string   `json:"expected_sql"`
    MinSimilarity   float32  `json:"min_similarity"`
    Domain          string   `json:"domain"`
}

func (sqa *SearchQualityAnalyzer) RunQualityAssessment() *QualityReport {
    var totalQueries int
    var successfulQueries int
    var totalPrecision float64
    var totalRecall float64
    
    results := make([]*QueryEvaluation, 0, len(sqa.testDataset))
    
    for _, testQuery := range sqa.testDataset {
        eval := sqa.evaluateQuery(testQuery)
        results = append(results, eval)
        
        totalQueries++
        if eval.Success {
            successfulQueries++
        }
        totalPrecision += eval.Precision
        totalRecall += eval.Recall
    }
    
    return &QualityReport{
        TotalQueries:     totalQueries,
        SuccessfulQueries: successfulQueries,
        SuccessRate:      float64(successfulQueries) / float64(totalQueries),
        AvgPrecision:     totalPrecision / float64(totalQueries),
        AvgRecall:        totalRecall / float64(totalQueries),
        Evaluations:      results,
    }
}

func (sqa *SearchQualityAnalyzer) evaluateQuery(testQuery *TestQuery) *QueryEvaluation {
    // æ‰§è¡Œæœç´¢
    results, err := sqa.searchEngine.SearchSimilarSchemas(
        context.Background(),
        testQuery.Query,
        1, // æµ‹è¯•è¿æ¥ID
        10,
    )
    
    if err != nil {
        return &QueryEvaluation{
            Query:   testQuery.Query,
            Success: false,
            Error:   err.Error(),
        }
    }
    
    // è®¡ç®—ç²¾ç¡®ç‡å’Œå¬å›ç‡
    foundTables := make(map[string]bool)
    for _, match := range results.Matches {
        foundTables[match.TableName] = true
    }
    
    // è®¡ç®—TPã€FPã€FN
    tp := 0 // True Positive
    fp := 0 // False Positive  
    fn := 0 // False Negative
    
    expectedSet := make(map[string]bool)
    for _, table := range testQuery.ExpectedTables {
        expectedSet[table] = true
    }
    
    // è®¡ç®—TPå’ŒFP
    for table := range foundTables {
        if expectedSet[table] {
            tp++
        } else {
            fp++
        }
    }
    
    // è®¡ç®—FN
    for table := range expectedSet {
        if !foundTables[table] {
            fn++
        }
    }
    
    // è®¡ç®—æŒ‡æ ‡
    precision := float64(tp) / float64(tp+fp)
    recall := float64(tp) / float64(tp+fn)
    
    if tp+fp == 0 {
        precision = 0
    }
    if tp+fn == 0 {
        recall = 0
    }
    
    return &QueryEvaluation{
        Query:      testQuery.Query,
        Success:    len(results.Matches) > 0,
        Precision:  precision,
        Recall:     recall,
        F1Score:    2 * precision * recall / (precision + recall),
        FoundTables: extractTableNames(results.Matches),
        ExpectedTables: testQuery.ExpectedTables,
    }
}
```

### æœç´¢æ€§èƒ½ç›‘æ§

```go
type SearchPerformanceMonitor struct {
    metrics  *SearchMetrics
    reporter *PerformanceReporter
}

func (spm *SearchPerformanceMonitor) StartMonitoring() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            spm.collectAndReportMetrics()
        }
    }
}

func (spm *SearchPerformanceMonitor) collectAndReportMetrics() {
    report := &PerformanceReport{
        Timestamp: time.Now(),
        
        // æœç´¢æ€§èƒ½æŒ‡æ ‡
        SchemaSearchQPS:    spm.metrics.GetQPS("schema"),
        QuerySearchQPS:     spm.metrics.GetQPS("query"),
        AvgResponseTime:    spm.metrics.GetAvgResponseTime(),
        P95ResponseTime:    spm.metrics.GetP95ResponseTime(),
        
        // ç¼“å­˜æ€§èƒ½
        CacheHitRate:       spm.metrics.GetCacheHitRate(),
        CacheMissRate:      spm.metrics.GetCacheMissRate(),
        
        // é”™è¯¯ç‡
        ErrorRate:          spm.metrics.GetErrorRate(),
        
        // èµ„æºä½¿ç”¨
        MemoryUsage:        spm.getMemoryUsage(),
        CPUUsage:          spm.getCPUUsage(),
    }
    
    spm.reporter.SendReport(report)
}
```

---

## ğŸ› ï¸ è°ƒä¼˜å»ºè®®

### 1. å‘é‡ç›¸ä¼¼åº¦é˜ˆå€¼è°ƒä¼˜

```yaml
# config/search_optimization.yaml
similarity_thresholds:
  schema_search:
    high_precision: 0.85    # é«˜ç²¾åº¦æ¨¡å¼
    balanced: 0.75          # å¹³è¡¡æ¨¡å¼  
    high_recall: 0.65       # é«˜å¬å›æ¨¡å¼
  
  query_search:
    personal: 0.80          # ä¸ªäººæŸ¥è¯¢
    global: 0.70            # å…¨å±€æŸ¥è¯¢
    
adaptive_threshold:
  enabled: true
  min_threshold: 0.6
  max_threshold: 0.9
  adjustment_step: 0.05
```

### 2. æ€§èƒ½ä¼˜åŒ–é…ç½®

```yaml
# config/performance_tuning.yaml
search_optimization:
  # å¹¶å‘æ§åˆ¶
  max_concurrent_searches: 20
  search_timeout: "10s"
  
  # æ‰¹å¤„ç†ä¼˜åŒ–
  batch_size: 100
  max_batch_wait: "100ms"
  
  # ç¼“å­˜ç­–ç•¥
  cache_strategy: "write_through"
  cache_size: 10000
  cache_ttl: "1h"
  
  # é¢„å–ç­–ç•¥
  prefetch_enabled: true
  prefetch_ratio: 0.1
```

---

<div align="center">

**ğŸ” å‘é‡æœç´¢å¼•æ“æˆåŠŸå…³é”®ï¼šç²¾ç¡®åŒ¹é… + æ™ºèƒ½æ’åº + æ€§èƒ½ä¼˜åŒ–**

</div>