# 🔎 向量搜索引擎实现指南

<div align="center">

![Vector Search](https://img.shields.io/badge/Vector_Search-Semantic_Engine-blue.svg)
![Similarity](https://img.shields.io/badge/Similarity-Cosine-green.svg)
![Performance](https://img.shields.io/badge/Performance-<100ms-orange.svg)

**Chat2SQL P3阶段 - 语义搜索引擎完整实现方案**

</div>

## 📋 概述

本文档专门针对Chat2SQL系统的向量搜索引擎实现，提供从架构设计到代码实现的完整技术方案，实现高性能的语义相似度搜索能力。

## 🎯 核心功能

### 语义搜索能力
- ✅ **Schema语义匹配**：基于向量相似度的数据库结构匹配
- ✅ **查询历史检索**：相似查询模式识别和推荐
- ✅ **上下文增强**：智能业务上下文推理
- ✅ **多模态搜索**：支持文本、结构化数据的混合搜索

### 性能指标
| 搜索类型 | 响应时间 | 准确率 | 并发能力 |
|---------|---------|--------|----------|
| **Schema匹配** | < 50ms | > 90% | 100 QPS |
| **查询检索** | < 80ms | > 85% | 80 QPS |
| **上下文搜索** | < 100ms | > 80% | 50 QPS |

---

## 🏗️ 搜索引擎架构

### 📦 核心组件设计

```go
// internal/vector/search_engine.go
package vector

import (
    "context"
    "fmt"
    "sort"
    "sync"
    "time"
    
    "github.com/qdrant/go-client/qdrant"
)

type VectorSearchEngine struct {
    // 核心服务
    qdrantService    *QdrantService
    embeddingService *EmbeddingService
    
    // 缓存层
    searchCache      *SearchCache
    embeddingCache   *EmbeddingCache
    
    // 配置和监控
    config          *SearchConfig
    metrics         *SearchMetrics
    
    // 并发控制
    semaphore       chan struct{}
    mu              sync.RWMutex
}

type SearchConfig struct {
    // 搜索配置
    MaxResults      int     `yaml:"max_results"`       // 20
    MinSimilarity   float32 `yaml:"min_similarity"`    // 0.7
    SearchTimeout   time.Duration `yaml:"search_timeout"` // 5s
    
    // 并发配置
    MaxConcurrent   int `yaml:"max_concurrent"`  // 10
    BatchSize       int `yaml:"batch_size"`      // 100
    
    // 缓存配置
    CacheEnabled    bool          `yaml:"cache_enabled"`  // true
    CacheTTL        time.Duration `yaml:"cache_ttl"`      // 1h
    
    // 搜索策略
    UseHybridSearch bool    `yaml:"use_hybrid_search"` // true
    WeightVector    float32 `yaml:"weight_vector"`     // 0.7
    WeightKeyword   float32 `yaml:"weight_keyword"`    // 0.3
}
```

### 🔧 搜索引擎初始化

```go
func NewVectorSearchEngine(
    qdrantService *QdrantService,
    embeddingService *EmbeddingService,
    config *SearchConfig) (*VectorSearchEngine, error) {
    
    engine := &VectorSearchEngine{
        qdrantService:    qdrantService,
        embeddingService: embeddingService,
        config:          config,
        metrics:         NewSearchMetrics(),
        semaphore:       make(chan struct{}, config.MaxConcurrent),
        searchCache:     NewSearchCache(config.CacheTTL),
        embeddingCache:  NewEmbeddingCache(config.CacheTTL),
    }
    
    // 预热缓存
    if err := engine.warmupCache(); err != nil {
        log.Warn("搜索引擎缓存预热失败", zap.Error(err))
    }
    
    return engine, nil
}

func (vse *VectorSearchEngine) warmupCache() error {
    // 预加载常用Schema向量
    commonSchemas := []string{
        "用户表", "订单表", "商品表", "用户信息", "订单信息",
    }
    
    for _, schema := range commonSchemas {
        _, err := vse.embeddingService.EmbedQuery(context.Background(), schema)
        if err != nil {
            log.Warn("Schema向量预热失败", zap.String("schema", schema), zap.Error(err))
        }
    }
    
    return nil
}
```

---

## 🗃️ Schema语义搜索

### Schema向量匹配实现

```go
func (vse *VectorSearchEngine) SearchSimilarSchemas(
    ctx context.Context,
    query string,
    connectionID int64,
    limit int) (*SchemaSearchResult, error) {
    
    start := time.Now()
    defer func() {
        vse.metrics.RecordSearchDuration("schema", time.Since(start))
    }()
    
    // 1. 检查缓存
    cacheKey := fmt.Sprintf("schema:%d:%s:%d", connectionID, query, limit)
    if cached := vse.searchCache.Get(cacheKey); cached != nil {
        vse.metrics.RecordCacheHit("schema")
        return cached.(*SchemaSearchResult), nil
    }
    vse.metrics.RecordCacheMiss("schema")
    
    // 2. 生成查询向量
    queryVector, err := vse.embeddingService.EmbedQuery(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("查询向量化失败: %w", err)
    }
    
    // 3. 构建搜索请求
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.qdrantService.config.Collections.SchemaCollection,
        Vector:         queryVector,
        Limit:          uint64(limit),
        WithPayload:    qdrant.NewWithPayload(true),
        ScoreThreshold: &vse.config.MinSimilarity,
        Filter: vse.buildSchemaFilter(connectionID),
    }
    
    // 4. 执行向量搜索
    searchResult, err := vse.qdrantService.client.Search(ctx, searchReq)
    if err != nil {
        vse.metrics.RecordSearchError("schema")
        return nil, fmt.Errorf("向量搜索失败: %w", err)
    }
    
    // 5. 转换搜索结果
    result := vse.convertSchemaSearchResult(searchResult, query)
    
    // 6. 缓存结果
    vse.searchCache.Set(cacheKey, result)
    
    vse.metrics.RecordSearchSuccess("schema", len(result.Matches))
    return result, nil
}

func (vse *VectorSearchEngine) buildSchemaFilter(connectionID int64) *qdrant.Filter {
    return &qdrant.Filter{
        Must: []*qdrant.Condition{
            {
                ConditionOneOf: &qdrant.Condition_Field{
                    Field: &qdrant.FieldCondition{
                        Key: "connection_id",
                        Match: &qdrant.Match{
                            MatchValue: &qdrant.Match_Integer{
                                Integer: connectionID,
                            },
                        },
                    },
                },
            },
            {
                ConditionOneOf: &qdrant.Condition_Field{
                    Field: &qdrant.FieldCondition{
                        Key: "is_active",
                        Match: &qdrant.Match{
                            MatchValue: &qdrant.Match_Bool{
                                Bool: true,
                            },
                        },
                    },
                },
            },
        },
    }
}

func (vse *VectorSearchEngine) convertSchemaSearchResult(
    searchResult *qdrant.SearchResponse,
    originalQuery string) *SchemaSearchResult {
    
    var matches []*SchemaMatch
    
    for _, hit := range searchResult.GetResult() {
        match := &SchemaMatch{
            TableName:     hit.Payload["table_name"].GetStringValue(),
            SchemaName:    hit.Payload["schema_name"].GetStringValue(),
            Description:   hit.Payload["description"].GetStringValue(),
            Similarity:    hit.Score,
            Confidence:    vse.calculateConfidence(hit.Score),
            Columns:       vse.parseColumns(hit.Payload["columns"]),
            Metadata: &SchemaMetadata{
                ConnectionID: hit.Payload["connection_id"].GetIntegerValue(),
                TableID:     hit.Payload["table_id"].GetIntegerValue(),
                CreatedAt:   vse.parseTimestamp(hit.Payload["created_at"]),
                UpdatedAt:   vse.parseTimestamp(hit.Payload["updated_at"]),
            },
        }
        
        // 增强匹配信息
        match.MatchReasons = vse.analyzeMatchReasons(originalQuery, match)
        match.RelevanceScore = vse.calculateRelevanceScore(match)
        
        matches = append(matches, match)
    }
    
    // 按相关性排序
    sort.Slice(matches, func(i, j int) bool {
        return matches[i].RelevanceScore > matches[j].RelevanceScore
    })
    
    return &SchemaSearchResult{
        Query:         originalQuery,
        Matches:       matches,
        TotalMatches:  len(matches),
        SearchTime:    time.Now(),
        ProcessingTime: searchResult.Time,
    }
}
```

### 智能匹配分析

```go
func (vse *VectorSearchEngine) analyzeMatchReasons(
    query string, 
    match *SchemaMatch) []string {
    
    var reasons []string
    queryLower := strings.ToLower(query)
    
    // 表名匹配
    if strings.Contains(queryLower, strings.ToLower(match.TableName)) {
        reasons = append(reasons, "表名直接匹配")
    }
    
    // 描述匹配
    if match.Description != "" && 
       vse.calculateTextSimilarity(queryLower, strings.ToLower(match.Description)) > 0.6 {
        reasons = append(reasons, "描述语义匹配")
    }
    
    // 字段匹配
    for _, column := range match.Columns {
        if strings.Contains(queryLower, strings.ToLower(column.Name)) {
            reasons = append(reasons, fmt.Sprintf("字段匹配: %s", column.Name))
        }
        if column.Comment != "" && 
           strings.Contains(queryLower, strings.ToLower(column.Comment)) {
            reasons = append(reasons, fmt.Sprintf("字段注释匹配: %s", column.Name))
        }
    }
    
    // 业务领域匹配
    domainKeywords := vse.extractDomainKeywords(queryLower)
    tableDomain := vse.inferTableDomain(match.TableName)
    for _, keyword := range domainKeywords {
        if strings.Contains(tableDomain, keyword) {
            reasons = append(reasons, fmt.Sprintf("业务领域匹配: %s", keyword))
        }
    }
    
    if len(reasons) == 0 {
        reasons = append(reasons, "向量语义相似")
    }
    
    return reasons
}

func (vse *VectorSearchEngine) calculateRelevanceScore(match *SchemaMatch) float64 {
    score := float64(match.Similarity) * 0.6 // 向量相似度权重60%
    
    // 表名权重 20%
    if len(match.MatchReasons) > 0 {
        for _, reason := range match.MatchReasons {
            if strings.Contains(reason, "表名直接匹配") {
                score += 0.2
                break
            }
        }
    }
    
    // 字段匹配权重 15%
    fieldMatchCount := 0
    for _, reason := range match.MatchReasons {
        if strings.Contains(reason, "字段匹配") {
            fieldMatchCount++
        }
    }
    if fieldMatchCount > 0 {
        score += 0.15 * math.Min(float64(fieldMatchCount)/5.0, 1.0)
    }
    
    // 业务领域权重 5%
    for _, reason := range match.MatchReasons {
        if strings.Contains(reason, "业务领域匹配") {
            score += 0.05
            break
        }
    }
    
    return math.Min(score, 1.0)
}
```

---

## 📚 查询历史搜索

### 历史查询检索实现

```go
func (vse *VectorSearchEngine) SearchSimilarQueries(
    ctx context.Context,
    query string,
    userID int64,
    limit int) (*QuerySearchResult, error) {
    
    start := time.Now()
    defer func() {
        vse.metrics.RecordSearchDuration("query", time.Since(start))
    }()
    
    // 1. 检查缓存
    cacheKey := fmt.Sprintf("query:%d:%s:%d", userID, query, limit)
    if cached := vse.searchCache.Get(cacheKey); cached != nil {
        vse.metrics.RecordCacheHit("query")
        return cached.(*QuerySearchResult), nil
    }
    
    // 2. 生成查询向量
    queryVector, err := vse.embeddingService.EmbedQuery(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("查询向量化失败: %w", err)
    }
    
    // 3. 多策略搜索
    personalResults, err := vse.searchPersonalQueries(ctx, queryVector, userID, limit/2)
    if err != nil {
        return nil, err
    }
    
    globalResults, err := vse.searchGlobalQueries(ctx, queryVector, limit/2)
    if err != nil {
        return nil, err
    }
    
    // 4. 合并和排序结果
    result := vse.mergeQueryResults(personalResults, globalResults, query)
    
    // 5. 缓存结果
    vse.searchCache.Set(cacheKey, result)
    
    vse.metrics.RecordSearchSuccess("query", len(result.Matches))
    return result, nil
}

func (vse *VectorSearchEngine) searchPersonalQueries(
    ctx context.Context,
    queryVector []float32,
    userID int64,
    limit int) ([]*QueryMatch, error) {
    
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.qdrantService.config.Collections.QueryCollection,
        Vector:         queryVector,
        Limit:          uint64(limit),
        WithPayload:    qdrant.NewWithPayload(true),
        ScoreThreshold: &[]float32{0.8}[0], // 个人查询要求更高相似度
        Filter: &qdrant.Filter{
            Must: []*qdrant.Condition{
                {
                    ConditionOneOf: &qdrant.Condition_Field{
                        Field: &qdrant.FieldCondition{
                            Key: "user_id",
                            Match: &qdrant.Match{
                                MatchValue: &qdrant.Match_Integer{
                                    Integer: userID,
                                },
                            },
                        },
                    },
                },
            },
        },
    }
    
    searchResult, err := vse.qdrantService.client.Search(ctx, searchReq)
    if err != nil {
        return nil, err
    }
    
    return vse.convertQueryMatches(searchResult, "personal"), nil
}

func (vse *VectorSearchEngine) searchGlobalQueries(
    ctx context.Context,
    queryVector []float32,
    limit int) ([]*QueryMatch, error) {
    
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.qdrantService.config.Collections.QueryCollection,
        Vector:         queryVector,
        Limit:          uint64(limit),
        WithPayload:    qdrant.NewWithPayload(true),
        ScoreThreshold: &vse.config.MinSimilarity,
        Filter: &qdrant.Filter{
            Must: []*qdrant.Condition{
                {
                    ConditionOneOf: &qdrant.Condition_Field{
                        Field: &qdrant.FieldCondition{
                            Key: "success_rate",
                            Range: &qdrant.Range{
                                Gte: &[]float64{0.8}[0], // 成功率 >= 80%
                            },
                        },
                    },
                },
                {
                    ConditionOneOf: &qdrant.Condition_Field{
                        Field: &qdrant.FieldCondition{
                            Key: "usage_count",
                            Range: &qdrant.Range{
                                Gte: &[]float64{5}[0], // 使用次数 >= 5
                            },
                        },
                    },
                },
            },
        },
    }
    
    searchResult, err := vse.qdrantService.client.Search(ctx, searchReq)
    if err != nil {
        return nil, err
    }
    
    return vse.convertQueryMatches(searchResult, "global"), nil
}

func (vse *VectorSearchEngine) convertQueryMatches(
    searchResult *qdrant.SearchResponse, 
    source string) []*QueryMatch {
    
    var matches []*QueryMatch
    
    for _, hit := range searchResult.GetResult() {
        match := &QueryMatch{
            OriginalQuery:  hit.Payload["original_query"].GetStringValue(),
            GeneratedSQL:   hit.Payload["generated_sql"].GetStringValue(),
            Similarity:     hit.Score,
            UsageCount:     int(hit.Payload["usage_count"].GetIntegerValue()),
            SuccessRate:    float64(hit.Payload["success_rate"].GetDoubleValue()),
            Source:         source,
            LastUsed:       vse.parseTimestamp(hit.Payload["last_used"]),
            
            // 计算信任度
            TrustScore: vse.calculateTrustScore(
                float64(hit.Score),
                int(hit.Payload["usage_count"].GetIntegerValue()),
                float64(hit.Payload["success_rate"].GetDoubleValue()),
            ),
        }
        
        matches = append(matches, match)
    }
    
    return matches
}

func (vse *VectorSearchEngine) calculateTrustScore(
    similarity float64,
    usageCount int,
    successRate float64) float64 {
    
    // 信任度 = 相似度 * 使用频率因子 * 成功率
    usageFactor := math.Min(float64(usageCount)/100.0, 1.0) // 使用次数归一化
    return similarity * (0.3 + 0.7*usageFactor) * successRate
}
```

---

## 🧠 混合搜索引擎

### 向量+关键词混合搜索

```go
func (vse *VectorSearchEngine) HybridSearch(
    ctx context.Context,
    query string,
    searchType SearchType,
    options *SearchOptions) (*HybridSearchResult, error) {
    
    var wg sync.WaitGroup
    var vectorResults interface{}
    var keywordResults interface{}
    var vectorErr, keywordErr error
    
    // 并行执行向量搜索和关键词搜索
    wg.Add(2)
    
    // 向量搜索
    go func() {
        defer wg.Done()
        vectorResults, vectorErr = vse.performVectorSearch(ctx, query, searchType, options)
    }()
    
    // 关键词搜索
    go func() {
        defer wg.Done()
        keywordResults, keywordErr = vse.performKeywordSearch(ctx, query, searchType, options)
    }()
    
    wg.Wait()
    
    if vectorErr != nil && keywordErr != nil {
        return nil, fmt.Errorf("向量搜索和关键词搜索都失败: vector=%v, keyword=%v", vectorErr, keywordErr)
    }
    
    // 融合结果
    result := vse.fuseSearchResults(vectorResults, keywordResults, options)
    
    return result, nil
}

func (vse *VectorSearchEngine) performKeywordSearch(
    ctx context.Context,
    query string,
    searchType SearchType,
    options *SearchOptions) (interface{}, error) {
    
    // 提取关键词
    keywords := vse.extractKeywords(query)
    
    // 构建关键词过滤器
    filter := vse.buildKeywordFilter(keywords, searchType, options)
    
    // 执行基于过滤器的搜索
    searchReq := &qdrant.SearchPoints{
        CollectionName: vse.getCollectionName(searchType),
        Vector:         make([]float32, vse.config.VectorSize), // 零向量
        Limit:          uint64(options.Limit),
        WithPayload:    qdrant.NewWithPayload(true),
        Filter:         filter,
    }
    
    return vse.qdrantService.client.Search(ctx, searchReq)
}

func (vse *VectorSearchEngine) extractKeywords(query string) []string {
    // 简单的关键词提取，实际项目中可以使用更复杂的NLP工具
    words := strings.Fields(strings.ToLower(query))
    
    // 过滤停用词
    stopWords := map[string]bool{
        "的": true, "是": true, "在": true, "有": true, "和": true,
        "或": true, "但": true, "从": true, "到": true, "与": true,
    }
    
    var keywords []string
    for _, word := range words {
        if !stopWords[word] && len(word) > 1 {
            keywords = append(keywords, word)
        }
    }
    
    return keywords
}

func (vse *VectorSearchEngine) buildKeywordFilter(
    keywords []string,
    searchType SearchType,
    options *SearchOptions) *qdrant.Filter {
    
    var conditions []*qdrant.Condition
    
    // 关键词匹配条件
    for _, keyword := range keywords {
        conditions = append(conditions, &qdrant.Condition{
            ConditionOneOf: &qdrant.Condition_Field{
                Field: &qdrant.FieldCondition{
                    Key: "searchable_text",
                    Match: &qdrant.Match{
                        MatchValue: &qdrant.Match_Text{
                            Text: keyword,
                        },
                    },
                },
            },
        })
    }
    
    return &qdrant.Filter{
        Should: conditions, // OR条件
    }
}

func (vse *VectorSearchEngine) fuseSearchResults(
    vectorResults, keywordResults interface{},
    options *SearchOptions) *HybridSearchResult {
    
    // 结果融合算法
    vectorWeight := vse.config.WeightVector
    keywordWeight := vse.config.WeightKeyword
    
    fusedMatches := make(map[string]*FusedMatch)
    
    // 处理向量搜索结果
    if vectorResults != nil {
        vse.processVectorResults(vectorResults, vectorWeight, fusedMatches)
    }
    
    // 处理关键词搜索结果  
    if keywordResults != nil {
        vse.processKeywordResults(keywordResults, keywordWeight, fusedMatches)
    }
    
    // 转换为排序列表
    var finalMatches []*FusedMatch
    for _, match := range fusedMatches {
        finalMatches = append(finalMatches, match)
    }
    
    // 按融合分数排序
    sort.Slice(finalMatches, func(i, j int) bool {
        return finalMatches[i].FusedScore > finalMatches[j].FusedScore
    })
    
    // 限制结果数量
    if len(finalMatches) > options.Limit {
        finalMatches = finalMatches[:options.Limit]
    }
    
    return &HybridSearchResult{
        Matches:     finalMatches,
        TotalCount:  len(finalMatches),
        SearchTime:  time.Now(),
        FusionStrategy: fmt.Sprintf("vector:%.2f+keyword:%.2f", vectorWeight, keywordWeight),
    }
}
```

---

## 📊 搜索结果优化

### 智能排序算法

```go
type ResultRanker struct {
    config *RankingConfig
}

type RankingConfig struct {
    // 排序权重
    SimilarityWeight   float64 `yaml:"similarity_weight"`    // 0.4
    FreshnessWeight    float64 `yaml:"freshness_weight"`     // 0.2
    PopularityWeight   float64 `yaml:"popularity_weight"`    // 0.2
    RelevanceWeight    float64 `yaml:"relevance_weight"`     // 0.2
    
    // 时间衰减
    TimeDecayFactor    float64 `yaml:"time_decay_factor"`    // 0.1
    MaxAgeHours        int     `yaml:"max_age_hours"`        // 168 (7天)
}

func (rr *ResultRanker) RankSearchResults(results []*SearchMatch) []*SearchMatch {
    now := time.Now()
    
    for _, result := range results {
        // 计算综合分数
        result.RankingScore = rr.calculateRankingScore(result, now)
    }
    
    // 排序
    sort.Slice(results, func(i, j int) bool {
        return results[i].RankingScore > results[j].RankingScore
    })
    
    return results
}

func (rr *ResultRanker) calculateRankingScore(match *SearchMatch, now time.Time) float64 {
    // 相似度分数
    similarityScore := float64(match.Similarity)
    
    // 新鲜度分数 (时间衰减)
    ageHours := now.Sub(match.LastUsed).Hours()
    freshnessScore := math.Exp(-rr.config.TimeDecayFactor * ageHours / float64(rr.config.MaxAgeHours))
    
    // 流行度分数 (使用次数归一化)
    popularityScore := math.Min(float64(match.UsageCount)/100.0, 1.0)
    
    // 相关性分数 (基于匹配原因)
    relevanceScore := rr.calculateRelevanceScore(match)
    
    // 加权求和
    finalScore := similarityScore*rr.config.SimilarityWeight +
                  freshnessScore*rr.config.FreshnessWeight +
                  popularityScore*rr.config.PopularityWeight +
                  relevanceScore*rr.config.RelevanceWeight
    
    return finalScore
}

func (rr *ResultRanker) calculateRelevanceScore(match *SearchMatch) float64 {
    score := 0.5 // 基础分数
    
    // 基于匹配原因调整
    for _, reason := range match.MatchReasons {
        switch {
        case strings.Contains(reason, "直接匹配"):
            score += 0.3
        case strings.Contains(reason, "语义匹配"):
            score += 0.2
        case strings.Contains(reason, "字段匹配"):
            score += 0.15
        case strings.Contains(reason, "业务领域"):
            score += 0.1
        }
    }
    
    return math.Min(score, 1.0)
}
```

### 搜索结果聚合

```go
func (vse *VectorSearchEngine) AggregateSearchResults(
    results []*SearchMatch,
    aggregationType AggregationType) *AggregatedResult {
    
    switch aggregationType {
    case AggregateByTable:
        return vse.aggregateByTable(results)
    case AggregateByDomain:
        return vse.aggregateByDomain(results)
    case AggregateByConfidence:
        return vse.aggregateByConfidence(results)
    default:
        return vse.defaultAggregation(results)
    }
}

func (vse *VectorSearchEngine) aggregateByTable(results []*SearchMatch) *AggregatedResult {
    tableGroups := make(map[string][]*SearchMatch)
    
    for _, result := range results {
        tableName := result.TableName
        tableGroups[tableName] = append(tableGroups[tableName], result)
    }
    
    var aggregates []*TableAggregate
    for tableName, matches := range tableGroups {
        // 计算表级别统计
        avgSimilarity := vse.calculateAverageSimilarity(matches)
        maxSimilarity := vse.calculateMaxSimilarity(matches)
        totalUsage := vse.calculateTotalUsage(matches)
        
        aggregate := &TableAggregate{
            TableName:       tableName,
            MatchCount:      len(matches),
            AvgSimilarity:   avgSimilarity,
            MaxSimilarity:   maxSimilarity,
            TotalUsage:      totalUsage,
            BestMatch:       matches[0], // 已经按分数排序
            AllMatches:      matches,
        }
        
        aggregates = append(aggregates, aggregate)
    }
    
    // 按匹配质量排序
    sort.Slice(aggregates, func(i, j int) bool {
        return aggregates[i].MaxSimilarity > aggregates[j].MaxSimilarity
    })
    
    return &AggregatedResult{
        Type:        AggregateByTable,
        TableGroups: aggregates,
        Summary: &AggregationSummary{
            TotalTables:    len(aggregates),
            TotalMatches:   len(results),
            AvgConfidence:  vse.calculateOverallConfidence(results),
        },
    }
}
```

---

## 🔍 搜索分析工具

### 搜索质量评估

```go
type SearchQualityAnalyzer struct {
    searchEngine *VectorSearchEngine
    testDataset  []*TestQuery
}

type TestQuery struct {
    Query           string   `json:"query"`
    ExpectedTables  []string `json:"expected_tables"`
    ExpectedSQL     string   `json:"expected_sql"`
    MinSimilarity   float32  `json:"min_similarity"`
    Domain          string   `json:"domain"`
}

func (sqa *SearchQualityAnalyzer) RunQualityAssessment() *QualityReport {
    var totalQueries int
    var successfulQueries int
    var totalPrecision float64
    var totalRecall float64
    
    results := make([]*QueryEvaluation, 0, len(sqa.testDataset))
    
    for _, testQuery := range sqa.testDataset {
        eval := sqa.evaluateQuery(testQuery)
        results = append(results, eval)
        
        totalQueries++
        if eval.Success {
            successfulQueries++
        }
        totalPrecision += eval.Precision
        totalRecall += eval.Recall
    }
    
    return &QualityReport{
        TotalQueries:     totalQueries,
        SuccessfulQueries: successfulQueries,
        SuccessRate:      float64(successfulQueries) / float64(totalQueries),
        AvgPrecision:     totalPrecision / float64(totalQueries),
        AvgRecall:        totalRecall / float64(totalQueries),
        Evaluations:      results,
    }
}

func (sqa *SearchQualityAnalyzer) evaluateQuery(testQuery *TestQuery) *QueryEvaluation {
    // 执行搜索
    results, err := sqa.searchEngine.SearchSimilarSchemas(
        context.Background(),
        testQuery.Query,
        1, // 测试连接ID
        10,
    )
    
    if err != nil {
        return &QueryEvaluation{
            Query:   testQuery.Query,
            Success: false,
            Error:   err.Error(),
        }
    }
    
    // 计算精确率和召回率
    foundTables := make(map[string]bool)
    for _, match := range results.Matches {
        foundTables[match.TableName] = true
    }
    
    // 计算TP、FP、FN
    tp := 0 // True Positive
    fp := 0 // False Positive  
    fn := 0 // False Negative
    
    expectedSet := make(map[string]bool)
    for _, table := range testQuery.ExpectedTables {
        expectedSet[table] = true
    }
    
    // 计算TP和FP
    for table := range foundTables {
        if expectedSet[table] {
            tp++
        } else {
            fp++
        }
    }
    
    // 计算FN
    for table := range expectedSet {
        if !foundTables[table] {
            fn++
        }
    }
    
    // 计算指标
    precision := float64(tp) / float64(tp+fp)
    recall := float64(tp) / float64(tp+fn)
    
    if tp+fp == 0 {
        precision = 0
    }
    if tp+fn == 0 {
        recall = 0
    }
    
    return &QueryEvaluation{
        Query:      testQuery.Query,
        Success:    len(results.Matches) > 0,
        Precision:  precision,
        Recall:     recall,
        F1Score:    2 * precision * recall / (precision + recall),
        FoundTables: extractTableNames(results.Matches),
        ExpectedTables: testQuery.ExpectedTables,
    }
}
```

### 搜索性能监控

```go
type SearchPerformanceMonitor struct {
    metrics  *SearchMetrics
    reporter *PerformanceReporter
}

func (spm *SearchPerformanceMonitor) StartMonitoring() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            spm.collectAndReportMetrics()
        }
    }
}

func (spm *SearchPerformanceMonitor) collectAndReportMetrics() {
    report := &PerformanceReport{
        Timestamp: time.Now(),
        
        // 搜索性能指标
        SchemaSearchQPS:    spm.metrics.GetQPS("schema"),
        QuerySearchQPS:     spm.metrics.GetQPS("query"),
        AvgResponseTime:    spm.metrics.GetAvgResponseTime(),
        P95ResponseTime:    spm.metrics.GetP95ResponseTime(),
        
        // 缓存性能
        CacheHitRate:       spm.metrics.GetCacheHitRate(),
        CacheMissRate:      spm.metrics.GetCacheMissRate(),
        
        // 错误率
        ErrorRate:          spm.metrics.GetErrorRate(),
        
        // 资源使用
        MemoryUsage:        spm.getMemoryUsage(),
        CPUUsage:          spm.getCPUUsage(),
    }
    
    spm.reporter.SendReport(report)
}
```

---

## 🛠️ 调优建议

### 1. 向量相似度阈值调优

```yaml
# config/search_optimization.yaml
similarity_thresholds:
  schema_search:
    high_precision: 0.85    # 高精度模式
    balanced: 0.75          # 平衡模式  
    high_recall: 0.65       # 高召回模式
  
  query_search:
    personal: 0.80          # 个人查询
    global: 0.70            # 全局查询
    
adaptive_threshold:
  enabled: true
  min_threshold: 0.6
  max_threshold: 0.9
  adjustment_step: 0.05
```

### 2. 性能优化配置

```yaml
# config/performance_tuning.yaml
search_optimization:
  # 并发控制
  max_concurrent_searches: 20
  search_timeout: "10s"
  
  # 批处理优化
  batch_size: 100
  max_batch_wait: "100ms"
  
  # 缓存策略
  cache_strategy: "write_through"
  cache_size: 10000
  cache_ttl: "1h"
  
  # 预取策略
  prefetch_enabled: true
  prefetch_ratio: 0.1
```

---

<div align="center">

**🔎 向量搜索引擎成功关键：精确匹配 + 智能排序 + 性能优化**

</div>