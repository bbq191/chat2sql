# 🎯 语义相似度匹配最佳实践

<div align="center">

![Semantic Similarity](https://img.shields.io/badge/Semantic_Similarity-Best_Practices-blue.svg)
![Accuracy](https://img.shields.io/badge/Accuracy-90%25+-green.svg)
![Algorithm](https://img.shields.io/badge/Algorithm-Cosine_Similarity-orange.svg)

**Chat2SQL P3阶段 - 语义相似度匹配算法优化与最佳实践指南**

</div>

## 📋 概述

本文档专门针对Chat2SQL系统中语义相似度匹配的算法选择、参数调优、准确率提升和A/B测试策略，提供科学的相似度匹配解决方案。

## 🎯 匹配目标

### 核心指标
- ✅ **匹配准确率**：Schema匹配 > 90%，查询匹配 > 85%
- ✅ **召回率**：相关结果发现率 > 95%
- ✅ **精确率**：无关结果过滤率 > 90%
- ✅ **响应时间**：相似度计算 < 10ms

### 业务场景
| 匹配场景 | 相似度阈值 | 准确率要求 | 应用策略 |
|---------|-----------|----------|----------|
| **Schema精确匹配** | > 0.85 | > 95% | 高精度策略 |
| **查询历史检索** | > 0.75 | > 85% | 平衡策略 |
| **上下文推荐** | > 0.65 | > 80% | 高召回策略 |

---

## 🧮 相似度算法实现

### 📊 多算法支持架构

```go
// internal/similarity/similarity_engine.go
package similarity

import (
    "math"
    "sort"
)

type SimilarityEngine struct {
    config    *SimilarityConfig
    metrics   *SimilarityMetrics
    algorithms map[AlgorithmType]SimilarityAlgorithm
}

type SimilarityConfig struct {
    // 默认算法
    DefaultAlgorithm AlgorithmType `yaml:"default_algorithm"` // "cosine"
    
    // 算法特定配置
    Cosine struct {
        NormalizationEnabled bool `yaml:"normalization_enabled"` // true
    } `yaml:"cosine"`
    
    Euclidean struct {
        MaxDistance float64 `yaml:"max_distance"` // 2.0
    } `yaml:"euclidean"`
    
    Dot struct {
        NormalizationRequired bool `yaml:"normalization_required"` // true
    } `yaml:"dot"`
    
    // 混合算法
    Hybrid struct {
        Enabled     bool            `yaml:"enabled"`      // false
        Weights     map[string]float64 `yaml:"weights"`   // {"cosine": 0.7, "jaccard": 0.3}
        Aggregation string          `yaml:"aggregation"`  // "weighted_average"
    } `yaml:"hybrid"`
}

type AlgorithmType string

const (
    CosineSimilarity     AlgorithmType = "cosine"
    EuclideanSimilarity  AlgorithmType = "euclidean"
    DotProductSimilarity AlgorithmType = "dot_product"
    JaccardSimilarity    AlgorithmType = "jaccard"
    HybridSimilarity     AlgorithmType = "hybrid"
)

type SimilarityAlgorithm interface {
    Calculate(vec1, vec2 []float32) (float64, error)
    Name() string
    RequiresNormalization() bool
}
```

### 🔢 余弦相似度实现

```go
// internal/similarity/cosine.go
type CosineSimilarityAlgorithm struct {
    config *SimilarityConfig
}

func NewCosineSimilarityAlgorithm(config *SimilarityConfig) *CosineSimilarityAlgorithm {
    return &CosineSimilarityAlgorithm{config: config}
}

func (csa *CosineSimilarityAlgorithm) Calculate(vec1, vec2 []float32) (float64, error) {
    if len(vec1) != len(vec2) {
        return 0, fmt.Errorf("向量维度不匹配: %d vs %d", len(vec1), len(vec2))
    }
    
    if len(vec1) == 0 {
        return 0, fmt.Errorf("向量为空")
    }
    
    // 计算点积和模长
    var dotProduct, norm1, norm2 float64
    
    for i := 0; i < len(vec1); i++ {
        v1, v2 := float64(vec1[i]), float64(vec2[i])
        dotProduct += v1 * v2
        norm1 += v1 * v1
        norm2 += v2 * v2
    }
    
    // 处理零向量
    if norm1 == 0 || norm2 == 0 {
        return 0, nil
    }
    
    // 计算余弦相似度
    similarity := dotProduct / (math.Sqrt(norm1) * math.Sqrt(norm2))
    
    // 确保结果在[0,1]范围内
    similarity = math.Max(0, math.Min(1, similarity))
    
    return similarity, nil
}

func (csa *CosineSimilarityAlgorithm) Name() string {
    return "cosine"
}

func (csa *CosineSimilarityAlgorithm) RequiresNormalization() bool {
    return false // 余弦相似度本身就是归一化的
}

// 批量计算优化版本
func (csa *CosineSimilarityAlgorithm) BatchCalculate(
    queryVec []float32,
    candidateVecs [][]float32) ([]float64, error) {
    
    if len(candidateVecs) == 0 {
        return nil, nil
    }
    
    results := make([]float64, len(candidateVecs))
    
    // 预计算查询向量的模长
    var queryNorm float64
    for _, v := range queryVec {
        queryNorm += float64(v) * float64(v)
    }
    queryNorm = math.Sqrt(queryNorm)
    
    if queryNorm == 0 {
        return results, nil // 全部返回0
    }
    
    // 并行计算相似度
    for i, candidateVec := range candidateVecs {
        if len(candidateVec) != len(queryVec) {
            results[i] = 0
            continue
        }
        
        var dotProduct, candidateNorm float64
        for j := 0; j < len(queryVec); j++ {
            qv, cv := float64(queryVec[j]), float64(candidateVec[j])
            dotProduct += qv * cv
            candidateNorm += cv * cv
        }
        
        candidateNorm = math.Sqrt(candidateNorm)
        if candidateNorm == 0 {
            results[i] = 0
        } else {
            similarity := dotProduct / (queryNorm * candidateNorm)
            results[i] = math.Max(0, math.Min(1, similarity))
        }
    }
    
    return results, nil
}
```

### 🔄 混合相似度算法

```go
// internal/similarity/hybrid.go
type HybridSimilarityAlgorithm struct {
    config     *SimilarityConfig
    algorithms map[string]SimilarityAlgorithm
    weights    map[string]float64
}

func NewHybridSimilarityAlgorithm(
    config *SimilarityConfig,
    algorithms map[string]SimilarityAlgorithm) *HybridSimilarityAlgorithm {
    
    return &HybridSimilarityAlgorithm{
        config:     config,
        algorithms: algorithms,
        weights:    config.Hybrid.Weights,
    }
}

func (hsa *HybridSimilarityAlgorithm) Calculate(vec1, vec2 []float32) (float64, error) {
    var weightedSum float64
    var totalWeight float64
    
    for algName, algorithm := range hsa.algorithms {
        weight, exists := hsa.weights[algName]
        if !exists {
            continue
        }
        
        similarity, err := algorithm.Calculate(vec1, vec2)
        if err != nil {
            // 记录错误但继续计算其他算法
            log.Warn("混合算法计算失败", 
                zap.String("algorithm", algName), 
                zap.Error(err))
            continue
        }
        
        weightedSum += similarity * weight
        totalWeight += weight
    }
    
    if totalWeight == 0 {
        return 0, fmt.Errorf("没有有效的相似度算法")
    }
    
    return weightedSum / totalWeight, nil
}

func (hsa *HybridSimilarityAlgorithm) CalculateWithDetails(
    vec1, vec2 []float32) (*DetailedSimilarity, error) {
    
    details := &DetailedSimilarity{
        AlgorithmResults: make(map[string]float64),
    }
    
    var weightedSum float64
    var totalWeight float64
    
    for algName, algorithm := range hsa.algorithms {
        weight, exists := hsa.weights[algName]
        if !exists {
            continue
        }
        
        similarity, err := algorithm.Calculate(vec1, vec2)
        if err != nil {
            details.Errors = append(details.Errors, 
                fmt.Sprintf("%s: %v", algName, err))
            continue
        }
        
        details.AlgorithmResults[algName] = similarity
        weightedSum += similarity * weight
        totalWeight += weight
    }
    
    if totalWeight == 0 {
        return details, fmt.Errorf("没有有效的相似度算法")
    }
    
    details.FinalSimilarity = weightedSum / totalWeight
    details.UsedAlgorithms = len(details.AlgorithmResults)
    
    return details, nil
}

type DetailedSimilarity struct {
    FinalSimilarity   float64             `json:"final_similarity"`
    AlgorithmResults  map[string]float64  `json:"algorithm_results"`
    UsedAlgorithms    int                 `json:"used_algorithms"`
    Errors           []string             `json:"errors,omitempty"`
}
```

---

## 📈 阈值动态调优

### 🎛️ 自适应阈值调整

```go
// internal/similarity/adaptive_threshold.go
type AdaptiveThresholdManager struct {
    config         *AdaptiveConfig
    metrics        *ThresholdMetrics
    thresholds     map[string]*ThresholdState
    evaluator      *ThresholdEvaluator
    mu             sync.RWMutex
}

type AdaptiveConfig struct {
    // 基础配置
    Enabled              bool    `yaml:"enabled"`               // true
    EvaluationInterval   time.Duration `yaml:"evaluation_interval"` // 1h
    MinSamples          int     `yaml:"min_samples"`           // 100
    
    // 调整策略
    AdjustmentStep      float64 `yaml:"adjustment_step"`       // 0.05
    MaxAdjustment       float64 `yaml:"max_adjustment"`        // 0.2
    StabilityThreshold  float64 `yaml:"stability_threshold"`   // 0.02
    
    // 目标指标
    TargetPrecision     float64 `yaml:"target_precision"`      // 0.9
    TargetRecall        float64 `yaml:"target_recall"`         // 0.85
    TargetF1Score       float64 `yaml:"target_f1_score"`       // 0.875
}

type ThresholdState struct {
    CurrentThreshold  float64   `json:"current_threshold"`
    OriginalThreshold float64   `json:"original_threshold"`
    LastAdjustment    time.Time `json:"last_adjustment"`
    AdjustmentHistory []ThresholdAdjustment `json:"adjustment_history"`
    Performance       *ThresholdPerformance `json:"performance"`
    StabilityCounter  int       `json:"stability_counter"`
}

type ThresholdAdjustment struct {
    Timestamp        time.Time `json:"timestamp"`
    OldThreshold     float64   `json:"old_threshold"`
    NewThreshold     float64   `json:"new_threshold"`
    Reason           string    `json:"reason"`
    PerformanceDelta *PerformanceDelta `json:"performance_delta"`
}

func NewAdaptiveThresholdManager(config *AdaptiveConfig) *AdaptiveThresholdManager {
    return &AdaptiveThresholdManager{
        config:     config,
        metrics:    NewThresholdMetrics(),
        thresholds: make(map[string]*ThresholdState),
        evaluator:  NewThresholdEvaluator(),
    }
}

func (atm *AdaptiveThresholdManager) StartAdaptation() {
    if !atm.config.Enabled {
        return
    }
    
    ticker := time.NewTicker(atm.config.EvaluationInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            atm.evaluateAndAdjustThresholds()
        }
    }
}

func (atm *AdaptiveThresholdManager) evaluateAndAdjustThresholds() {
    atm.mu.Lock()
    defer atm.mu.Unlock()
    
    for searchType, state := range atm.thresholds {
        // 收集性能数据
        performance, err := atm.evaluator.EvaluateThreshold(searchType, state.CurrentThreshold)
        if err != nil {
            log.Error("阈值评估失败", 
                zap.String("search_type", searchType), 
                zap.Error(err))
            continue
        }
        
        // 检查是否需要调整
        adjustment := atm.calculateAdjustment(performance)
        if adjustment == 0 {
            state.StabilityCounter++
            continue
        }
        
        // 应用调整
        oldThreshold := state.CurrentThreshold
        newThreshold := atm.applyAdjustment(state.CurrentThreshold, adjustment)
        
        // 验证调整的有效性
        if atm.validateAdjustment(oldThreshold, newThreshold, performance) {
            atm.recordThresholdAdjustment(state, oldThreshold, newThreshold, adjustment, performance)
            state.CurrentThreshold = newThreshold
            state.StabilityCounter = 0
            
            log.Info("阈值调整", 
                zap.String("search_type", searchType),
                zap.Float64("old_threshold", oldThreshold),
                zap.Float64("new_threshold", newThreshold),
                zap.Float64("adjustment", adjustment))
        }
    }
}

func (atm *AdaptiveThresholdManager) calculateAdjustment(performance *ThresholdPerformance) float64 {
    // 计算当前性能与目标的差距
    precisionGap := performance.Precision - atm.config.TargetPrecision
    recallGap := performance.Recall - atm.config.TargetRecall
    f1Gap := performance.F1Score - atm.config.TargetF1Score
    
    // 权重分配
    const (
        precisionWeight = 0.4
        recallWeight    = 0.4
        f1Weight        = 0.2
    )
    
    // 计算综合调整信号
    adjustmentSignal := precisionWeight*precisionGap + 
                       recallWeight*recallGap + 
                       f1Weight*f1Gap
    
    // 决定调整方向和大小
    var adjustment float64
    
    if math.Abs(adjustmentSignal) < atm.config.StabilityThreshold {
        // 性能稳定，不需要调整
        return 0
    }
    
    if adjustmentSignal > 0 {
        // 性能超过目标，可以适当降低阈值以提高召回率
        adjustment = -atm.config.AdjustmentStep
    } else {
        // 性能低于目标，需要提高阈值以提高精确率
        adjustment = atm.config.AdjustmentStep
    }
    
    // 限制调整幅度
    if math.Abs(adjustment) > atm.config.MaxAdjustment {
        if adjustment > 0 {
            adjustment = atm.config.MaxAdjustment
        } else {
            adjustment = -atm.config.MaxAdjustment
        }
    }
    
    return adjustment
}

func (atm *AdaptiveThresholdManager) applyAdjustment(currentThreshold, adjustment float64) float64 {
    newThreshold := currentThreshold + adjustment
    
    // 确保阈值在合理范围内
    const (
        minThreshold = 0.1
        maxThreshold = 0.95
    )
    
    if newThreshold < minThreshold {
        newThreshold = minThreshold
    } else if newThreshold > maxThreshold {
        newThreshold = maxThreshold
    }
    
    return newThreshold
}
```

### 📊 A/B测试框架

```go
// internal/similarity/ab_testing.go
type ABTestingFramework struct {
    config       *ABTestConfig
    experiments  map[string]*Experiment
    splitter     *TrafficSplitter
    analyzer     *ResultAnalyzer
    mu           sync.RWMutex
}

type ABTestConfig struct {
    Enabled              bool          `yaml:"enabled"`               // true
    DefaultTrafficSplit  float64       `yaml:"default_traffic_split"` // 0.5
    MinSampleSize        int           `yaml:"min_sample_size"`       // 1000
    TestDuration         time.Duration `yaml:"test_duration"`         // 168h (7天)
    SignificanceLevel    float64       `yaml:"significance_level"`    // 0.05
}

type Experiment struct {
    ID               string           `json:"id"`
    Name             string           `json:"name"`
    Description      string           `json:"description"`
    Status           ExperimentStatus `json:"status"`
    StartTime        time.Time        `json:"start_time"`
    EndTime          time.Time        `json:"end_time"`
    
    // 实验配置
    ControlGroup     *ExperimentGroup `json:"control_group"`
    TreatmentGroups  []*ExperimentGroup `json:"treatment_groups"`
    TrafficSplit     map[string]float64 `json:"traffic_split"`
    
    // 结果统计
    Results          *ExperimentResults `json:"results"`
    
    // 元数据
    CreatedBy        string    `json:"created_by"`
    UpdatedAt        time.Time `json:"updated_at"`
}

type ExperimentGroup struct {
    Name             string                 `json:"name"`
    SimilarityConfig *SimilarityConfig      `json:"similarity_config"`
    ThresholdConfig  map[string]float64     `json:"threshold_config"`
    Participants     int                    `json:"participants"`
    Metrics          *GroupMetrics          `json:"metrics"`
}

type ExperimentResults struct {
    SampleSize       map[string]int         `json:"sample_size"`
    Metrics          map[string]*GroupMetrics `json:"metrics"`
    StatisticalTests map[string]*StatTest   `json:"statistical_tests"`
    Winner           string                 `json:"winner"`
    Confidence       float64               `json:"confidence"`
    Summary          string                `json:"summary"`
}

func (abt *ABTestingFramework) CreateExperiment(config *ExperimentConfig) (*Experiment, error) {
    abt.mu.Lock()
    defer abt.mu.Unlock()
    
    experiment := &Experiment{
        ID:          generateExperimentID(),
        Name:        config.Name,
        Description: config.Description,
        Status:      ExperimentStatusPending,
        CreatedBy:   config.CreatedBy,
        UpdatedAt:   time.Now(),
        
        ControlGroup:    config.ControlGroup,
        TreatmentGroups: config.TreatmentGroups,
        TrafficSplit:    config.TrafficSplit,
    }
    
    // 验证实验配置
    if err := abt.validateExperiment(experiment); err != nil {
        return nil, err
    }
    
    abt.experiments[experiment.ID] = experiment
    
    log.Info("A/B测试实验创建", 
        zap.String("experiment_id", experiment.ID),
        zap.String("name", experiment.Name))
    
    return experiment, nil
}

func (abt *ABTestingFramework) StartExperiment(experimentID string) error {
    abt.mu.Lock()
    defer abt.mu.Unlock()
    
    experiment, exists := abt.experiments[experimentID]
    if !exists {
        return fmt.Errorf("实验不存在: %s", experimentID)
    }
    
    experiment.Status = ExperimentStatusRunning
    experiment.StartTime = time.Now()
    experiment.EndTime = experiment.StartTime.Add(abt.config.TestDuration)
    
    // 配置流量分配
    abt.splitter.ConfigureExperiment(experiment)
    
    log.Info("A/B测试实验启动", 
        zap.String("experiment_id", experimentID),
        zap.Time("end_time", experiment.EndTime))
    
    return nil
}

func (abt *ABTestingFramework) GetAssignedGroup(
    experimentID string, 
    userID int64) (*ExperimentGroup, error) {
    
    experiment, exists := abt.experiments[experimentID]
    if !exists {
        return nil, fmt.Errorf("实验不存在: %s", experimentID)
    }
    
    if experiment.Status != ExperimentStatusRunning {
        return experiment.ControlGroup, nil // 默认使用对照组
    }
    
    // 根据用户ID进行分组
    groupName := abt.splitter.AssignGroup(experimentID, userID)
    
    if groupName == experiment.ControlGroup.Name {
        return experiment.ControlGroup, nil
    }
    
    for _, group := range experiment.TreatmentGroups {
        if group.Name == groupName {
            return group, nil
        }
    }
    
    return experiment.ControlGroup, nil // 默认返回对照组
}

func (abt *ABTestingFramework) RecordExperimentResult(
    experimentID string,
    groupName string,
    result *SearchResult) error {
    
    experiment, exists := abt.experiments[experimentID]
    if !exists || experiment.Status != ExperimentStatusRunning {
        return nil // 忽略不存在或未运行的实验
    }
    
    // 更新对应组的指标
    var targetGroup *ExperimentGroup
    if experiment.ControlGroup.Name == groupName {
        targetGroup = experiment.ControlGroup
    } else {
        for _, group := range experiment.TreatmentGroups {
            if group.Name == groupName {
                targetGroup = group
                break
            }
        }
    }
    
    if targetGroup == nil {
        return fmt.Errorf("实验组不存在: %s", groupName)
    }
    
    // 更新指标
    targetGroup.Participants++
    abt.updateGroupMetrics(targetGroup, result)
    
    return nil
}

func (abt *ABTestingFramework) AnalyzeExperiment(experimentID string) (*ExperimentResults, error) {
    experiment, exists := abt.experiments[experimentID]
    if !exists {
        return nil, fmt.Errorf("实验不存在: %s", experimentID)
    }
    
    // 检查样本量是否足够
    totalSamples := experiment.ControlGroup.Participants
    for _, group := range experiment.TreatmentGroups {
        totalSamples += group.Participants
    }
    
    if totalSamples < abt.config.MinSampleSize {
        return nil, fmt.Errorf("样本量不足: %d < %d", totalSamples, abt.config.MinSampleSize)
    }
    
    // 执行统计分析
    results := &ExperimentResults{
        SampleSize: make(map[string]int),
        Metrics:    make(map[string]*GroupMetrics),
        StatisticalTests: make(map[string]*StatTest),
    }
    
    // 收集各组数据
    results.SampleSize[experiment.ControlGroup.Name] = experiment.ControlGroup.Participants
    results.Metrics[experiment.ControlGroup.Name] = experiment.ControlGroup.Metrics
    
    for _, group := range experiment.TreatmentGroups {
        results.SampleSize[group.Name] = group.Participants
        results.Metrics[group.Name] = group.Metrics
        
        // 执行统计检验
        statTest := abt.analyzer.PerformTTest(
            experiment.ControlGroup.Metrics,
            group.Metrics,
            abt.config.SignificanceLevel,
        )
        results.StatisticalTests[group.Name] = statTest
    }
    
    // 确定获胜者
    winner, confidence := abt.determineWinner(results)
    results.Winner = winner
    results.Confidence = confidence
    results.Summary = abt.generateResultSummary(results)
    
    experiment.Results = results
    
    return results, nil
}
```

---

## 📏 相似度评估体系

### 🎯 评估指标定义

```go
// internal/similarity/evaluation.go
type SimilarityEvaluator struct {
    groundTruth  map[string]*GroundTruthDataset
    metrics      *EvaluationMetrics
    testSuite    []*EvaluationCase
}

type GroundTruthDataset struct {
    Name        string                    `json:"name"`
    Description string                    `json:"description"`
    TestCases   []*GroundTruthCase       `json:"test_cases"`
    CreatedAt   time.Time                `json:"created_at"`
    UpdatedAt   time.Time                `json:"updated_at"`
}

type GroundTruthCase struct {
    ID              string    `json:"id"`
    Query           string    `json:"query"`
    RelevantItems   []string  `json:"relevant_items"`
    IrrelevantItems []string  `json:"irrelevant_items"`
    ExpectedRanking []string  `json:"expected_ranking"`
    Difficulty      int       `json:"difficulty"`  // 1-5
    Domain          string    `json:"domain"`
    Tags            []string  `json:"tags"`
}

type EvaluationMetrics struct {
    // 基础指标
    Precision    float64 `json:"precision"`
    Recall       float64 `json:"recall"`
    F1Score      float64 `json:"f1_score"`
    
    // 排序指标
    MAP          float64 `json:"map"`          // Mean Average Precision
    NDCG         float64 `json:"ndcg"`         // Normalized Discounted Cumulative Gain
    MRR          float64 `json:"mrr"`          // Mean Reciprocal Rank
    
    // 阈值相关指标
    OptimalThreshold float64 `json:"optimal_threshold"`
    ThresholdPrecision map[string]float64 `json:"threshold_precision"`
    ThresholdRecall    map[string]float64 `json:"threshold_recall"`
    
    // 性能指标
    AvgLatency   time.Duration `json:"avg_latency"`
    Throughput   float64       `json:"throughput"`
}

func (se *SimilarityEvaluator) RunComprehensiveEvaluation(
    algorithm SimilarityAlgorithm,
    thresholds []float64) (*ComprehensiveEvaluation, error) {
    
    evaluation := &ComprehensiveEvaluation{
        Algorithm:     algorithm.Name(),
        StartTime:     time.Now(),
        TestCases:     len(se.testSuite),
        Thresholds:    thresholds,
    }
    
    // 对每个阈值进行评估
    for _, threshold := range thresholds {
        thresholdResult := se.evaluateThreshold(algorithm, threshold)
        evaluation.ThresholdResults[fmt.Sprintf("%.2f", threshold)] = thresholdResult
    }
    
    // 找到最优阈值
    optimalThreshold, optimalMetrics := se.findOptimalThreshold(evaluation.ThresholdResults)
    evaluation.OptimalThreshold = optimalThreshold
    evaluation.OptimalMetrics = optimalMetrics
    
    // 生成评估报告
    evaluation.Report = se.generateEvaluationReport(evaluation)
    evaluation.EndTime = time.Now()
    evaluation.Duration = evaluation.EndTime.Sub(evaluation.StartTime)
    
    return evaluation, nil
}

func (se *SimilarityEvaluator) evaluateThreshold(
    algorithm SimilarityAlgorithm,
    threshold float64) *ThresholdEvaluation {
    
    var tp, fp, fn, tn int
    var totalQueries int
    var avgPrecisions []float64
    var reciprocalRanks []float64
    var ndcgScores []float64
    
    for _, testCase := range se.testSuite {
        result := se.evaluateSingleCase(algorithm, threshold, testCase)
        
        tp += result.TruePositive
        fp += result.FalsePositive
        fn += result.FalseNegative
        tn += result.TrueNegative
        totalQueries++
        
        if result.AveragePrecision > 0 {
            avgPrecisions = append(avgPrecisions, result.AveragePrecision)
        }
        if result.ReciprocalRank > 0 {
            reciprocalRanks = append(reciprocalRanks, result.ReciprocalRank)
        }
        if result.NDCG > 0 {
            ndcgScores = append(ndcgScores, result.NDCG)
        }
    }
    
    // 计算基础指标
    precision := float64(tp) / float64(tp+fp)
    recall := float64(tp) / float64(tp+fn)
    f1Score := 2 * precision * recall / (precision + recall)
    
    if tp+fp == 0 {
        precision = 0
    }
    if tp+fn == 0 {
        recall = 0
    }
    if precision+recall == 0 {
        f1Score = 0
    }
    
    // 计算高级指标
    mapScore := se.calculateMean(avgPrecisions)
    mrrScore := se.calculateMean(reciprocalRanks)
    ndcgScore := se.calculateMean(ndcgScores)
    
    return &ThresholdEvaluation{
        Threshold:    threshold,
        Precision:    precision,
        Recall:       recall,
        F1Score:      f1Score,
        MAP:          mapScore,
        MRR:          mrrScore,
        NDCG:         ndcgScore,
        TotalQueries: totalQueries,
        TruePositive: tp,
        FalsePositive: fp,
        FalseNegative: fn,
        TrueNegative: tn,
    }
}

func (se *SimilarityEvaluator) evaluateSingleCase(
    algorithm SimilarityAlgorithm,
    threshold float64,
    testCase *GroundTruthCase) *SingleCaseResult {
    
    result := &SingleCaseResult{
        CaseID: testCase.ID,
        Query:  testCase.Query,
    }
    
    // 模拟搜索过程（这里需要实际的搜索逻辑）
    searchResults := se.simulateSearch(algorithm, threshold, testCase)
    
    // 计算混淆矩阵
    relevantSet := make(map[string]bool)
    for _, item := range testCase.RelevantItems {
        relevantSet[item] = true
    }
    
    var retrievedRelevant []string
    var retrievedIrrelevant []string
    
    for _, item := range searchResults {
        if relevantSet[item.ID] {
            result.TruePositive++
            retrievedRelevant = append(retrievedRelevant, item.ID)
        } else {
            result.FalsePositive++
            retrievedIrrelevant = append(retrievedIrrelevant, item.ID)
        }
    }
    
    // 计算遗漏的相关项
    retrievedSet := make(map[string]bool)
    for _, item := range searchResults {
        retrievedSet[item.ID] = true
    }
    
    for _, relevantItem := range testCase.RelevantItems {
        if !retrievedSet[relevantItem] {
            result.FalseNegative++
        }
    }
    
    // 计算Average Precision
    result.AveragePrecision = se.calculateAveragePrecision(searchResults, relevantSet)
    
    // 计算Reciprocal Rank
    result.ReciprocalRank = se.calculateReciprocalRank(searchResults, relevantSet)
    
    // 计算NDCG
    result.NDCG = se.calculateNDCG(searchResults, testCase.ExpectedRanking)
    
    return result
}

func (se *SimilarityEvaluator) calculateAveragePrecision(
    results []*SearchResultItem,
    relevantSet map[string]bool) float64 {
    
    var precisionSum float64
    var relevantCount int
    
    for i, item := range results {
        if relevantSet[item.ID] {
            relevantCount++
            precision := float64(relevantCount) / float64(i+1)
            precisionSum += precision
        }
    }
    
    if relevantCount == 0 {
        return 0
    }
    
    return precisionSum / float64(len(relevantSet))
}

func (se *SimilarityEvaluator) calculateReciprocalRank(
    results []*SearchResultItem,
    relevantSet map[string]bool) float64 {
    
    for i, item := range results {
        if relevantSet[item.ID] {
            return 1.0 / float64(i+1)
        }
    }
    
    return 0
}

func (se *SimilarityEvaluator) calculateNDCG(
    results []*SearchResultItem,
    expectedRanking []string) float64 {
    
    if len(expectedRanking) == 0 {
        return 0
    }
    
    // 创建理想排序的相关性分数
    idealRelevance := make(map[string]float64)
    for i, item := range expectedRanking {
        idealRelevance[item] = float64(len(expectedRanking) - i)
    }
    
    // 计算DCG
    var dcg float64
    for i, item := range results {
        relevance := idealRelevance[item.ID]
        dcg += relevance / math.Log2(float64(i+2))
    }
    
    // 计算IDCG
    var idcg float64
    sortedRelevance := make([]float64, 0, len(idealRelevance))
    for _, relevance := range idealRelevance {
        sortedRelevance = append(sortedRelevance, relevance)
    }
    sort.Float64s(sortedRelevance)
    
    // 反转排序以获得降序
    for i := len(sortedRelevance)/2 - 1; i >= 0; i-- {
        opp := len(sortedRelevance) - 1 - i
        sortedRelevance[i], sortedRelevance[opp] = sortedRelevance[opp], sortedRelevance[i]
    }
    
    for i, relevance := range sortedRelevance {
        idcg += relevance / math.Log2(float64(i+2))
    }
    
    if idcg == 0 {
        return 0
    }
    
    return dcg / idcg
}
```

---

## 🎪 在线评估系统

### 📊 实时质量监控

```go
// internal/similarity/online_evaluation.go
type OnlineEvaluationSystem struct {
    config          *OnlineConfig
    feedbackStore   *FeedbackStore
    metrics         *OnlineMetrics
    alertManager    *AlertManager
    qualityTracker  *QualityTracker
}

type OnlineConfig struct {
    // 评估窗口
    EvaluationWindow time.Duration `yaml:"evaluation_window"` // 1h
    SlidingWindow    time.Duration `yaml:"sliding_window"`    // 15m
    
    // 质量阈值
    MinPrecision     float64 `yaml:"min_precision"`     // 0.85
    MinRecall        float64 `yaml:"min_recall"`        // 0.80
    MinF1Score       float64 `yaml:"min_f1_score"`      // 0.82
    
    // 告警配置
    AlertThreshold   float64 `yaml:"alert_threshold"`   // 0.05 (下降5%)
    AlertCooldown    time.Duration `yaml:"alert_cooldown"` // 30m
}

type UserFeedback struct {
    QueryID      string    `json:"query_id"`
    UserID       int64     `json:"user_id"`
    Query        string    `json:"query"`
    Results      []string  `json:"results"`
    Ratings      map[string]int `json:"ratings"`  // result_id -> rating (1-5)
    IsRelevant   map[string]bool `json:"is_relevant"`
    Timestamp    time.Time `json:"timestamp"`
    Source       string    `json:"source"`  // "explicit", "implicit"
}

func (oes *OnlineEvaluationSystem) ProcessUserFeedback(feedback *UserFeedback) {
    // 存储反馈数据
    oes.feedbackStore.Store(feedback)
    
    // 更新实时指标
    oes.updateRealTimeMetrics(feedback)
    
    // 检查质量阈值
    oes.checkQualityThresholds()
    
    // 记录用户行为模式
    oes.recordUserBehavior(feedback)
}

func (oes *OnlineEvaluationSystem) updateRealTimeMetrics(feedback *UserFeedback) {
    window := oes.config.SlidingWindow
    
    // 计算当前窗口的指标
    windowFeedbacks := oes.feedbackStore.GetRecentFeedbacks(window)
    
    var tp, fp, fn int
    for _, fb := range windowFeedbacks {
        for resultID, isRelevant := range fb.IsRelevant {
            if oes.wasResultReturned(fb.QueryID, resultID) {
                if isRelevant {
                    tp++
                } else {
                    fp++
                }
            } else if isRelevant {
                fn++
            }
        }
    }
    
    // 计算指标
    precision := float64(tp) / float64(tp+fp)
    recall := float64(tp) / float64(tp+fn)
    f1Score := 2 * precision * recall / (precision + recall)
    
    if tp+fp == 0 {
        precision = 0
    }
    if tp+fn == 0 {
        recall = 0
    }
    if precision+recall == 0 {
        f1Score = 0
    }
    
    // 更新指标
    oes.metrics.UpdatePrecision(precision)
    oes.metrics.UpdateRecall(recall)
    oes.metrics.UpdateF1Score(f1Score)
}

func (oes *OnlineEvaluationSystem) checkQualityThresholds() {
    currentMetrics := oes.metrics.GetCurrentMetrics()
    
    alerts := make([]*QualityAlert, 0)
    
    // 检查精确率
    if currentMetrics.Precision < oes.config.MinPrecision {
        alerts = append(alerts, &QualityAlert{
            Type:        "precision_degradation",
            Severity:    "high",
            Current:     currentMetrics.Precision,
            Threshold:   oes.config.MinPrecision,
            Description: fmt.Sprintf("精确率降至 %.3f，低于阈值 %.3f", 
                        currentMetrics.Precision, oes.config.MinPrecision),
        })
    }
    
    // 检查召回率
    if currentMetrics.Recall < oes.config.MinRecall {
        alerts = append(alerts, &QualityAlert{
            Type:        "recall_degradation", 
            Severity:    "high",
            Current:     currentMetrics.Recall,
            Threshold:   oes.config.MinRecall,
            Description: fmt.Sprintf("召回率降至 %.3f，低于阈值 %.3f",
                        currentMetrics.Recall, oes.config.MinRecall),
        })
    }
    
    // 检查F1分数
    if currentMetrics.F1Score < oes.config.MinF1Score {
        alerts = append(alerts, &QualityAlert{
            Type:        "f1_degradation",
            Severity:    "medium", 
            Current:     currentMetrics.F1Score,
            Threshold:   oes.config.MinF1Score,
            Description: fmt.Sprintf("F1分数降至 %.3f，低于阈值 %.3f",
                        currentMetrics.F1Score, oes.config.MinF1Score),
        })
    }
    
    // 发送告警
    for _, alert := range alerts {
        oes.alertManager.SendAlert(alert)
    }
}

func (oes *OnlineEvaluationSystem) GenerateQualityReport() *QualityReport {
    endTime := time.Now()
    startTime := endTime.Add(-oes.config.EvaluationWindow)
    
    // 收集反馈数据
    feedbacks := oes.feedbackStore.GetFeedbacksInRange(startTime, endTime)
    
    // 计算整体指标
    overallMetrics := oes.calculateOverallMetrics(feedbacks)
    
    // 按时间段分析
    timeSegments := oes.analyzeByTimeSegments(feedbacks)
    
    // 按查询类型分析
    queryTypeAnalysis := oes.analyzeByQueryType(feedbacks)
    
    // 用户满意度分析
    satisfactionAnalysis := oes.analyzeSatisfaction(feedbacks)
    
    return &QualityReport{
        TimeRange:            fmt.Sprintf("%s - %s", startTime.Format("2006-01-02 15:04"), endTime.Format("2006-01-02 15:04")),
        TotalFeedbacks:       len(feedbacks),
        OverallMetrics:       overallMetrics,
        TimeSegmentAnalysis:  timeSegments,
        QueryTypeAnalysis:    queryTypeAnalysis,
        SatisfactionAnalysis: satisfactionAnalysis,
        GeneratedAt:          time.Now(),
    }
}
```

---

## 🛠️ 优化建议

### 1. 相似度算法选择指南

```yaml
# config/similarity_algorithm_guide.yaml
algorithm_selection:
  scenarios:
    high_precision_search:
      recommended: "cosine"
      threshold: 0.85
      use_case: "Schema精确匹配"
      
    balanced_search:
      recommended: "hybrid"
      algorithms: ["cosine", "jaccard"]
      weights: {"cosine": 0.7, "jaccard": 0.3}
      threshold: 0.75
      use_case: "通用查询检索"
      
    high_recall_search:
      recommended: "cosine"
      threshold: 0.65
      use_case: "上下文推荐"
      
    real_time_search:
      recommended: "cosine"
      optimization: "batch_calculation"
      use_case: "高并发场景"
```

### 2. 性能优化配置

```yaml
# config/similarity_performance.yaml
performance_optimization:
  # 批量计算
  batch_processing:
    enabled: true
    batch_size: 100
    max_concurrent: 10
    
  # 向量缓存
  vector_caching:
    enabled: true
    cache_size: 10000
    ttl: "1h"
    
  # 预计算优化
  precomputation:
    enabled: true
    common_queries: 1000
    update_interval: "6h"
    
  # 近似算法
  approximation:
    enabled: false
    error_tolerance: 0.01
    speed_improvement: 5x
```

---

<div align="center">

**🎯 语义相似度匹配成功关键：算法优化 + 阈值调优 + 质量监控**

</div>