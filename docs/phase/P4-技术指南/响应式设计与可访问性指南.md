# 📱 响应式设计与可访问性指南

## 🎯 设计理念

Chat2SQL的前端界面采用移动优先的响应式设计，确保在各种设备和能力的用户都能获得优秀的使用体验。本指南详细介绍P4阶段的响应式设计和可访问性实现策略。

### ✨ 核心设计原则

| 设计原则 | 实现策略 | 目标指标 | 业务价值 |
|---------|---------|---------|---------|
| **移动优先** | Progressive Enhancement | 移动端用户>70% | 扩大用户覆盖面 |
| **无障碍访问** | WCAG 2.1 AA标准 | 可访问性得分>95 | 包容性设计 |
| **性能导向** | 核心Web指标优化 | LCP<2.5s, FID<100ms | 用户体验提升 |
| **内容优先** | 语义化HTML结构 | SEO得分>90 | 搜索引擎友好 |

### 🎁 用户体验目标

- **跨设备一致性**：桌面端、平板端、移动端体验统一
- **快速响应**：所有交互操作响应时间<200ms
- **直观操作**：新用户5分钟内完成首次查询
- **包容性设计**：支持视觉、听觉、运动能力受限用户

---

## 📐 响应式布局架构

### 🎨 断点系统设计

```scss
// 响应式断点定义
$breakpoints: (
  // 移动端优先设计
  xs: 0,          // Extra small devices (>0px)
  sm: 576px,      // Small devices (landscape phones, ≥576px)
  md: 768px,      // Medium devices (tablets, ≥768px)
  lg: 992px,      // Large devices (desktops, ≥992px)
  xl: 1200px,     // Extra large devices (large desktops, ≥1200px)
  xxl: 1400px     // Extra extra large devices (≥1400px)
);

// 媒体查询混入
@mixin media-breakpoint-up($name) {
  $min: map-get($breakpoints, $name);
  @media (min-width: $min) {
    @content;
  }
}

@mixin media-breakpoint-down($name) {
  $max: map-get($breakpoints, $name) - 0.02;
  @media (max-width: $max) {
    @content;
  }
}

@mixin media-breakpoint-between($lower, $upper) {
  $min: map-get($breakpoints, $lower);
  $max: map-get($breakpoints, $upper) - 0.02;
  @media (min-width: $min) and (max-width: $max) {
    @content;
  }
}

// 容器系统
.container {
  width: 100%;
  padding-left: 15px;
  padding-right: 15px;
  margin-left: auto;
  margin-right: auto;
  
  @include media-breakpoint-up(sm) {
    max-width: 540px;
  }
  
  @include media-breakpoint-up(md) {
    max-width: 720px;
  }
  
  @include media-breakpoint-up(lg) {
    max-width: 960px;
  }
  
  @include media-breakpoint-up(xl) {
    max-width: 1140px;
  }
  
  @include media-breakpoint-up(xxl) {
    max-width: 1320px;
  }
}
```

### 🏗️ 网格系统实现

```tsx
// 响应式网格组件
interface GridProps {
  cols?: {
    xs?: number;
    sm?: number;
    md?: number;
    lg?: number;
    xl?: number;
    xxl?: number;
  };
  gap?: number | string;
  children: React.ReactNode;
}

function ResponsiveGrid({ cols = { xs: 1, md: 2, lg: 3 }, gap = 16, children }: GridProps) {
  const gridStyles: React.CSSProperties = {
    display: 'grid',
    gap,
    gridTemplateColumns: `repeat(${cols.xs || 1}, 1fr)`
  };
  
  const mediaQueries = {
    [`@media (min-width: 576px)`]: {
      gridTemplateColumns: `repeat(${cols.sm || cols.xs || 1}, 1fr)`
    },
    [`@media (min-width: 768px)`]: {
      gridTemplateColumns: `repeat(${cols.md || cols.sm || cols.xs || 1}, 1fr)`
    },
    [`@media (min-width: 992px)`]: {
      gridTemplateColumns: `repeat(${cols.lg || cols.md || cols.sm || cols.xs || 1}, 1fr)`
    },
    [`@media (min-width: 1200px)`]: {
      gridTemplateColumns: `repeat(${cols.xl || cols.lg || cols.md || cols.sm || cols.xs || 1}, 1fr)`
    },
    [`@media (min-width: 1400px)`]: {
      gridTemplateColumns: `repeat(${cols.xxl || cols.xl || cols.lg || cols.md || cols.sm || cols.xs || 1}, 1fr)`
    }
  };
  
  return (
    <div 
      className="responsive-grid"
      style={gridStyles}
      css={mediaQueries}
    >
      {children}
    </div>
  );
}
```

### 📱 移动端优化布局

```tsx
// 移动端主界面布局
function MobileLayout() {
  const [activeTab, setActiveTab] = useState('query');
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  if (!isMobile) {
    return <DesktopLayout />;
  }
  
  return (
    <div className="mobile-layout">
      {/* 顶部导航栏 */}
      <header className="mobile-header">
        <div className="header-content">
          <div className="logo">
            <img src="/logo.svg" alt="Chat2SQL" />
          </div>
          
          <div className="header-actions">
            <Button 
              type="text" 
              icon={<Icon name="user" />}
              aria-label="用户菜单"
            />
            <Button 
              type="text" 
              icon={<Icon name="settings" />}
              aria-label="设置"
            />
          </div>
        </div>
      </header>
      
      {/* 主内容区域 */}
      <main className="mobile-main">
        {activeTab === 'query' && <QueryInterface />}
        {activeTab === 'history' && <QueryHistory />}
        {activeTab === 'favorites' && <FavoriteQueries />}
        {activeTab === 'settings' && <SettingsPanel />}
      </main>
      
      {/* 底部导航栏 */}
      <nav className="mobile-navigation" role="navigation">
        <div className="nav-tabs">
          <button
            className={`nav-tab ${activeTab === 'query' ? 'active' : ''}`}
            onClick={() => setActiveTab('query')}
            aria-label="查询"
            aria-current={activeTab === 'query' ? 'page' : undefined}
          >
            <Icon name="search" />
            <span>查询</span>
          </button>
          
          <button
            className={`nav-tab ${activeTab === 'history' ? 'active' : ''}`}
            onClick={() => setActiveTab('history')}
            aria-label="历史"
            aria-current={activeTab === 'history' ? 'page' : undefined}
          >
            <Icon name="history" />
            <span>历史</span>
          </button>
          
          <button
            className={`nav-tab ${activeTab === 'favorites' ? 'active' : ''}`}
            onClick={() => setActiveTab('favorites')}
            aria-label="收藏"
            aria-current={activeTab === 'favorites' ? 'page' : undefined}
          >
            <Icon name="heart" />
            <span>收藏</span>
          </button>
          
          <button
            className={`nav-tab ${activeTab === 'settings' ? 'active' : ''}`}
            onClick={() => setActiveTab('settings')}
            aria-label="设置"
            aria-current={activeTab === 'settings' ? 'page' : undefined}
          >
            <Icon name="settings" />
            <span>设置</span>
          </button>
        </div>
      </nav>
    </div>
  );
}
```

### 🖥️ 桌面端自适应布局

```tsx
// 桌面端三栏布局
function DesktopLayout() {
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [rightPanelVisible, setRightPanelVisible] = useState(true);
  
  return (
    <div className="desktop-layout">
      {/* 左侧边栏 */}
      <aside 
        className={`sidebar ${sidebarCollapsed ? 'collapsed' : ''}`}
        aria-label="侧边栏"
      >
        <div className="sidebar-header">
          <img src="/logo.svg" alt="Chat2SQL" className="logo" />
          
          <Button
            type="text"
            icon={<Icon name={sidebarCollapsed ? 'menu-unfold' : 'menu-fold'} />}
            onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
            aria-label={sidebarCollapsed ? '展开侧边栏' : '收起侧边栏'}
          />
        </div>
        
        <nav className="sidebar-navigation" role="navigation">
          <QueryHistory collapsed={sidebarCollapsed} />
          <FavoriteQueries collapsed={sidebarCollapsed} />
          <RecentConnections collapsed={sidebarCollapsed} />
        </nav>
      </aside>
      
      {/* 主内容区 */}
      <main className="main-content">
        <header className="main-header">
          <div className="header-title">
            <h1>SQL查询工作台</h1>
          </div>
          
          <div className="header-actions">
            <Button
              icon={<Icon name="panel-right" />}
              onClick={() => setRightPanelVisible(!rightPanelVisible)}
              aria-label={rightPanelVisible ? '隐藏右侧面板' : '显示右侧面板'}
            >
              {rightPanelVisible ? '隐藏面板' : '显示面板'}
            </Button>
          </div>
        </header>
        
        <div className="query-workspace">
          <QueryEditor />
          <QueryResults />
        </div>
      </main>
      
      {/* 右侧面板 */}
      {rightPanelVisible && (
        <aside className="right-panel" aria-label="辅助面板">
          <div className="panel-tabs">
            <QueryAssistant />
            <QueryHistory />
            <PerformanceMetrics />
          </div>
        </aside>
      )}
    </div>
  );
}
```

---

## ♿ 可访问性 (WCAG 2.1) 实现

### 🎯 WCAG 2.1 AA标准遵循

```tsx
// 可访问性组件基类
interface AccessibleComponentProps {
  id?: string;
  'aria-label'?: string;
  'aria-labelledby'?: string;
  'aria-describedby'?: string;
  role?: string;
  tabIndex?: number;
}

// 可访问的查询输入组件
function AccessibleQueryInput({
  value,
  onChange,
  onSubmit,
  loading,
  error,
  ...accessibilityProps
}: {
  value: string;
  onChange: (value: string) => void;
  onSubmit: () => void;
  loading?: boolean;
  error?: string;
} & AccessibleComponentProps) {
  const inputId = accessibilityProps.id || `query-input-${Date.now()}`;
  const errorId = `${inputId}-error`;
  const helpId = `${inputId}-help`;
  
  return (
    <div className="accessible-query-input">
      {/* 查询输入标签 */}
      <label htmlFor={inputId} className="query-label">
        输入您的自然语言查询
        <span className="required-indicator" aria-label="必填">*</span>
      </label>
      
      {/* 帮助文本 */}
      <div id={helpId} className="help-text">
        例如：显示最近一周的订单数据
      </div>
      
      {/* 查询输入框 */}
      <textarea
        id={inputId}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className={`query-textarea ${error ? 'error' : ''}`}
        placeholder="请输入您的查询..."
        aria-describedby={`${helpId} ${error ? errorId : ''}`}
        aria-invalid={error ? 'true' : 'false'}
        aria-required="true"
        rows={4}
        disabled={loading}
        {...accessibilityProps}
      />
      
      {/* 错误信息 */}
      {error && (
        <div 
          id={errorId} 
          className="error-message" 
          role="alert"
          aria-live="polite"
        >
          <Icon name="exclamation-circle" aria-hidden="true" />
          {error}
        </div>
      )}
      
      {/* 提交按钮 */}
      <Button
        type="primary"
        onClick={onSubmit}
        loading={loading}
        disabled={!value.trim() || loading}
        aria-describedby={loading ? `${inputId}-status` : undefined}
      >
        {loading ? '正在执行查询...' : '执行查询'}
      </Button>
      
      {/* 加载状态 */}
      {loading && (
        <div 
          id={`${inputId}-status`}
          className="loading-status"
          aria-live="polite"
          aria-atomic="true"
        >
          正在处理您的查询，请稍候...
        </div>
      )}
    </div>
  );
}
```

### 🎨 高对比度主题支持

```scss
// 高对比度主题
@media (prefers-contrast: high) {
  :root {
    --primary-color: #000000;
    --background-color: #ffffff;
    --text-color: #000000;
    --border-color: #000000;
    --error-color: #cc0000;
    --success-color: #006600;
    --warning-color: #996600;
    --info-color: #0066cc;
  }
  
  .query-interface {
    border: 2px solid var(--border-color);
    background: var(--background-color);
    color: var(--text-color);
  }
  
  .button {
    border: 2px solid var(--primary-color);
    background: var(--background-color);
    color: var(--primary-color);
    
    &:hover {
      background: var(--primary-color);
      color: var(--background-color);
    }
    
    &:focus {
      outline: 3px solid var(--primary-color);
      outline-offset: 2px;
    }
  }
}

// 暗色主题可访问性
@media (prefers-color-scheme: dark) {
  :root {
    --background-color: #121212;
    --surface-color: #1e1e1e;
    --text-color: #ffffff;
    --text-secondary: #b3b3b3;
    --border-color: #333333;
  }
  
  // 确保暗色主题下的对比度
  .query-results-table {
    --row-hover-bg: rgba(255, 255, 255, 0.04);
    --row-selected-bg: rgba(64, 169, 255, 0.16);
  }
}

// 动画减少偏好
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}
```

### ⌨️ 键盘导航支持

```tsx
// 键盘导航Hook
function useKeyboardNavigation() {
  const [focusedElement, setFocusedElement] = useState<HTMLElement | null>(null);
  const [navigationMode, setNavigationMode] = useState<'mouse' | 'keyboard'>('mouse');
  
  useEffect(() => {
    // 检测导航模式
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Tab') {
        setNavigationMode('keyboard');
      }
    };
    
    const handleMouseDown = () => {
      setNavigationMode('mouse');
    };
    
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleMouseDown);
    
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleMouseDown);
    };
  }, []);
  
  // 跳过链接功能
  const createSkipLink = useCallback((targetId: string, label: string) => {
    return (
      <a 
        href={`#${targetId}`}
        className="skip-link"
        onFocus={() => setNavigationMode('keyboard')}
      >
        {label}
      </a>
    );
  }, []);
  
  return {
    navigationMode,
    focusedElement,
    createSkipLink
  };
}

// 查询结果表格键盘导航
function AccessibleDataTable({ data, columns }: { data: any[], columns: any[] }) {
  const [focusedCell, setFocusedCell] = useState({ row: 0, col: 0 });
  const tableRef = useRef<HTMLTableElement>(null);
  
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (!tableRef.current) return;
    
    const rowCount = data.length;
    const colCount = columns.length;
    
    switch (e.key) {
      case 'ArrowUp':
        e.preventDefault();
        setFocusedCell(prev => ({
          ...prev,
          row: Math.max(0, prev.row - 1)
        }));
        break;
        
      case 'ArrowDown':
        e.preventDefault();
        setFocusedCell(prev => ({
          ...prev,
          row: Math.min(rowCount - 1, prev.row + 1)
        }));
        break;
        
      case 'ArrowLeft':
        e.preventDefault();
        setFocusedCell(prev => ({
          ...prev,
          col: Math.max(0, prev.col - 1)
        }));
        break;
        
      case 'ArrowRight':
        e.preventDefault();
        setFocusedCell(prev => ({
          ...prev,
          col: Math.min(colCount - 1, prev.col + 1)
        }));
        break;
        
      case 'Home':
        e.preventDefault();
        if (e.ctrlKey) {
          setFocusedCell({ row: 0, col: 0 });
        } else {
          setFocusedCell(prev => ({ ...prev, col: 0 }));
        }
        break;
        
      case 'End':
        e.preventDefault();
        if (e.ctrlKey) {
          setFocusedCell({ row: rowCount - 1, col: colCount - 1 });
        } else {
          setFocusedCell(prev => ({ ...prev, col: colCount - 1 }));
        }
        break;
    }
  }, [data.length, columns.length]);
  
  useEffect(() => {
    const table = tableRef.current;
    if (table) {
      table.addEventListener('keydown', handleKeyDown);
      return () => table.removeEventListener('keydown', handleKeyDown);
    }
  }, [handleKeyDown]);
  
  return (
    <div className="accessible-table-container">
      <div className="table-caption" id="table-description">
        查询结果表格，包含 {data.length} 行数据，{columns.length} 列
      </div>
      
      <table 
        ref={tableRef}
        className="accessible-data-table"
        role="grid"
        aria-labelledby="table-description"
        tabIndex={0}
      >
        <thead>
          <tr role="row">
            {columns.map((column, colIndex) => (
              <th 
                key={column.key}
                role="columnheader"
                aria-sort="none"
                tabIndex={-1}
              >
                {column.title}
              </th>
            ))}
          </tr>
        </thead>
        
        <tbody>
          {data.map((row, rowIndex) => (
            <tr key={rowIndex} role="row">
              {columns.map((column, colIndex) => (
                <td
                  key={`${rowIndex}-${colIndex}`}
                  role="gridcell"
                  tabIndex={
                    focusedCell.row === rowIndex && focusedCell.col === colIndex ? 0 : -1
                  }
                  className={
                    focusedCell.row === rowIndex && focusedCell.col === colIndex 
                      ? 'focused' : ''
                  }
                  aria-describedby={`cell-${rowIndex}-${colIndex}-desc`}
                >
                  {row[column.dataIndex]}
                  <span 
                    id={`cell-${rowIndex}-${colIndex}-desc`}
                    className="sr-only"
                  >
                    第 {rowIndex + 1} 行，{column.title}：{row[column.dataIndex]}
                  </span>
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
      
      <div className="table-instructions sr-only">
        使用方向键导航表格，Home键回到行首，End键到行尾，Ctrl+Home回到表格开头，Ctrl+End到表格结尾
      </div>
    </div>
  );
}
```

### 🔊 屏幕阅读器支持

```tsx
// 屏幕阅读器友好的查询状态组件
function ScreenReaderQueryStatus({ status, progress, error }: {
  status: 'idle' | 'executing' | 'completed' | 'error';
  progress?: number;
  error?: string;
}) {
  const [announcements, setAnnouncements] = useState<string[]>([]);
  
  // 状态变化时的语音提示
  useEffect(() => {
    let announcement = '';
    
    switch (status) {
      case 'executing':
        announcement = `开始执行查询${progress ? `，当前进度 ${progress}%` : ''}`;
        break;
      case 'completed':
        announcement = '查询执行完成，结果已显示';
        break;
      case 'error':
        announcement = `查询执行失败：${error}`;
        break;
    }
    
    if (announcement) {
      setAnnouncements(prev => [...prev, announcement]);
      
      // 清理旧的通知
      setTimeout(() => {
        setAnnouncements(prev => prev.slice(1));
      }, 5000);
    }
  }, [status, progress, error]);
  
  return (
    <>
      {/* 状态区域 - 屏幕阅读器可见 */}
      <div className="sr-only" role="status" aria-live="polite">
        {announcements.map((announcement, index) => (
          <div key={index}>{announcement}</div>
        ))}
      </div>
      
      {/* 进度指示器 */}
      {status === 'executing' && (
        <div 
          role="progressbar"
          aria-valuemin={0}
          aria-valuemax={100}
          aria-valuenow={progress || 0}
          aria-label={`查询执行进度：${progress || 0}%`}
          className="query-progress"
        >
          <div 
            className="progress-bar"
            style={{ width: `${progress || 0}%` }}
          />
        </div>
      )}
    </>
  );
}

// 语音反馈Hook
function useSpeechFeedback() {
  const speak = useCallback((text: string, options?: SpeechSynthesisUtteranceOptions) => {
    if ('speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance(text);
      
      if (options) {
        Object.assign(utterance, options);
      }
      
      // 默认设置
      utterance.rate = 1;
      utterance.pitch = 1;
      utterance.volume = 0.8;
      utterance.lang = 'zh-CN';
      
      speechSynthesis.speak(utterance);
    }
  }, []);
  
  const stop = useCallback(() => {
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
    }
  }, []);
  
  return { speak, stop };
}
```

---

## 📱 PWA (渐进式Web应用) 实现

### 🛠️ Service Worker配置

```typescript
// service-worker.ts
const CACHE_NAME = 'chat2sql-v1';
const OFFLINE_URL = '/offline.html';

// 需要缓存的资源
const CACHE_RESOURCES = [
  '/',
  '/static/js/main.js',
  '/static/css/main.css',
  '/static/images/logo.svg',
  '/offline.html'
];

// 安装事件
self.addEventListener('install', (event: ExtendableEvent) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(CACHE_RESOURCES))
      .then(() => self.skipWaiting())
  );
});

// 激活事件
self.addEventListener('activate', (event: ExtendableEvent) => {
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames
            .filter(cacheName => cacheName !== CACHE_NAME)
            .map(cacheName => caches.delete(cacheName))
        );
      })
      .then(() => self.clients.claim())
  );
});

// 请求拦截
self.addEventListener('fetch', (event: FetchEvent) => {
  // 只处理GET请求
  if (event.request.method !== 'GET') {
    return;
  }
  
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          return response;
        }
        
        return fetch(event.request)
          .then(response => {
            // 检查响应是否有效
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }
            
            // 克隆响应进行缓存
            const responseToCache = response.clone();
            
            caches.open(CACHE_NAME)
              .then(cache => {
                cache.put(event.request, responseToCache);
              });
            
            return response;
          })
          .catch(() => {
            // 网络失败时返回离线页面
            if (event.request.destination === 'document') {
              return caches.match(OFFLINE_URL);
            }
          });
      })
  );
});

// 后台同步
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'query-sync') {
    event.waitUntil(syncPendingQueries());
  }
});

async function syncPendingQueries() {
  // 同步离线期间的查询
  const pendingQueries = await getPendingQueries();
  
  for (const query of pendingQueries) {
    try {
      await submitQuery(query);
      await removePendingQuery(query.id);
    } catch (error) {
      console.error('查询同步失败:', error);
    }
  }
}
```

### 📱 Web App Manifest

```json
{
  "name": "Chat2SQL - 自然语言SQL查询工具",
  "short_name": "Chat2SQL",
  "description": "基于AI的自然语言转SQL查询工具，支持多数据库和智能缓存",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#1890ff",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "categories": ["productivity", "business"],
  "screenshots": [
    {
      "src": "/screenshots/desktop.png",
      "sizes": "1280x720",
      "type": "image/png",
      "platform": "wide",
      "label": "桌面端界面"
    },
    {
      "src": "/screenshots/mobile.png",
      "sizes": "375x667",
      "type": "image/png",
      "platform": "narrow",
      "label": "移动端界面"
    }
  ],
  "shortcuts": [
    {
      "name": "新建查询",
      "short_name": "新查询",
      "description": "快速创建新的SQL查询",
      "url": "/query/new",
      "icons": [
        {
          "src": "/icons/shortcut-new.png",
          "sizes": "96x96"
        }
      ]
    },
    {
      "name": "查询历史",
      "short_name": "历史",
      "description": "查看历史查询记录",
      "url": "/history",
      "icons": [
        {
          "src": "/icons/shortcut-history.png",
          "sizes": "96x96"
        }
      ]
    }
  ]
}
```

### 🔄 离线功能实现

```tsx
// 离线状态管理Hook
function useOfflineCapability() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [pendingQueries, setPendingQueries] = useState<any[]>([]);
  
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      // 同步离线期间的查询
      syncPendingQueries();
    };
    
    const handleOffline = () => {
      setIsOnline(false);
    };
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  const addPendingQuery = useCallback((query: any) => {
    const queryWithId = {
      ...query,
      id: `offline-${Date.now()}`,
      timestamp: Date.now(),
      status: 'pending'
    };
    
    setPendingQueries(prev => [...prev, queryWithId]);
    
    // 保存到本地存储
    localStorage.setItem('pendingQueries', JSON.stringify([...pendingQueries, queryWithId]));
    
    // 注册后台同步
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      navigator.serviceWorker.ready.then(registration => {
        registration.sync.register('query-sync');
      });
    }
    
    return queryWithId;
  }, [pendingQueries]);
  
  const syncPendingQueries = useCallback(async () => {
    if (!isOnline || pendingQueries.length === 0) return;
    
    for (const query of pendingQueries) {
      try {
        // 尝试提交查询
        await submitQuery(query);
        
        // 成功后从待处理列表移除
        setPendingQueries(prev => prev.filter(q => q.id !== query.id));
      } catch (error) {
        console.error('同步查询失败:', error);
      }
    }
    
    // 更新本地存储
    localStorage.setItem('pendingQueries', JSON.stringify(pendingQueries));
  }, [isOnline, pendingQueries]);
  
  return {
    isOnline,
    pendingQueries,
    addPendingQuery,
    syncPendingQueries
  };
}

// 离线提示组件
function OfflineIndicator() {
  const { isOnline, pendingQueries } = useOfflineCapability();
  
  if (isOnline) {
    return null;
  }
  
  return (
    <div className="offline-indicator" role="alert">
      <Icon name="wifi-off" />
      <div className="offline-content">
        <div className="offline-title">当前处于离线状态</div>
        <div className="offline-description">
          您可以继续使用应用，查询将在网络恢复后自动同步
        </div>
        {pendingQueries.length > 0 && (
          <div className="pending-queries">
            {pendingQueries.length} 个查询等待同步
          </div>
        )}
      </div>
    </div>
  );
}
```

---

## 🧪 测试与验证

### 🔍 响应式设计测试

```typescript
// 响应式设计测试工具
class ResponsiveTestSuite {
  private viewports = {
    mobile: { width: 375, height: 667 },
    tablet: { width: 768, height: 1024 },
    desktop: { width: 1920, height: 1080 }
  };
  
  async testResponsiveLayout(url: string) {
    const results = [];
    
    for (const [device, viewport] of Object.entries(this.viewports)) {
      const result = await this.testViewport(url, device, viewport);
      results.push(result);
    }
    
    return results;
  }
  
  private async testViewport(url: string, device: string, viewport: any) {
    // 使用Playwright进行响应式测试
    const browser = await playwright.chromium.launch();
    const page = await browser.newPage();
    
    await page.setViewportSize(viewport);
    await page.goto(url);
    
    // 测试关键元素是否可见
    const tests = [
      {
        name: '导航菜单可见性',
        test: () => page.locator('[data-testid="navigation"]').isVisible()
      },
      {
        name: '查询输入框可用性',
        test: () => page.locator('[data-testid="query-input"]').isEnabled()
      },
      {
        name: '内容区域布局',
        test: async () => {
          const contentArea = page.locator('[data-testid="main-content"]');
          const boundingBox = await contentArea.boundingBox();
          return boundingBox && boundingBox.width > 0 && boundingBox.height > 0;
        }
      }
    ];
    
    const testResults = [];
    for (const test of tests) {
      try {
        const result = await test.test();
        testResults.push({ name: test.name, passed: result });
      } catch (error) {
        testResults.push({ name: test.name, passed: false, error: error.message });
      }
    }
    
    await browser.close();
    
    return {
      device,
      viewport,
      tests: testResults
    };
  }
}
```

### ♿ 可访问性自动化测试

```typescript
// 可访问性测试套件
import { AxePuppeteer } from '@axe-core/puppeteer';

class AccessibilityTestSuite {
  async runAccessibilityAudit(url: string) {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    await page.goto(url);
    
    // 运行axe-core可访问性测试
    const results = await new AxePuppeteer(page)
      .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])
      .analyze();
    
    await browser.close();
    
    return {
      violations: results.violations,
      passes: results.passes,
      incomplete: results.incomplete,
      inapplicable: results.inapplicable,
      score: this.calculateAccessibilityScore(results)
    };
  }
  
  private calculateAccessibilityScore(results: any): number {
    const totalTests = results.passes.length + results.violations.length;
    if (totalTests === 0) return 100;
    
    const passedTests = results.passes.length;
    return Math.round((passedTests / totalTests) * 100);
  }
  
  async testKeyboardNavigation(url: string) {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    await page.goto(url);
    
    // 测试Tab键导航
    const focusableElements = await page.$$eval(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
      elements => elements.map(el => ({
        tagName: el.tagName,
        id: el.id,
        className: el.className,
        hasTabIndex: el.hasAttribute('tabindex')
      }))
    );
    
    // 模拟Tab键导航
    const navigationResults = [];
    for (let i = 0; i < focusableElements.length; i++) {
      await page.keyboard.press('Tab');
      
      const activeElement = await page.evaluate(() => {
        const el = document.activeElement;
        return {
          tagName: el?.tagName,
          id: el?.id,
          className: el?.className,
          isVisible: el ? window.getComputedStyle(el).display !== 'none' : false
        };
      });
      
      navigationResults.push({
        step: i + 1,
        expectedElement: focusableElements[i],
        actualElement: activeElement,
        success: activeElement.isVisible
      });
    }
    
    await browser.close();
    
    return navigationResults;
  }
}
```

### 📱 PWA功能测试

```typescript
// PWA功能测试
class PWATestSuite {
  async testPWAFeatures(url: string) {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    await page.goto(url);
    
    const results = {
      manifest: await this.testManifest(page),
      serviceWorker: await this.testServiceWorker(page),
      installability: await this.testInstallability(page),
      offline: await this.testOfflineCapability(page)
    };
    
    await browser.close();
    return results;
  }
  
  private async testManifest(page: any) {
    const manifest = await page.evaluate(() => {
      const link = document.querySelector('link[rel="manifest"]');
      return link ? link.href : null;
    });
    
    if (!manifest) return { success: false, error: 'No manifest found' };
    
    try {
      const response = await page.goto(manifest);
      const manifestData = await response.json();
      
      return {
        success: true,
        data: manifestData,
        hasRequiredFields: !!(manifestData.name && manifestData.start_url && manifestData.icons)
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  
  private async testServiceWorker(page: any) {
    const swRegistration = await page.evaluate(() => {
      return navigator.serviceWorker.getRegistration();
    });
    
    return {
      success: !!swRegistration,
      active: swRegistration?.active?.state === 'activated',
      scope: swRegistration?.scope
    };
  }
  
  private async testInstallability(page: any) {
    // 检查beforeinstallprompt事件
    const installable = await page.evaluate(() => {
      return new Promise((resolve) => {
        let prompted = false;
        
        window.addEventListener('beforeinstallprompt', () => {
          prompted = true;
          resolve(true);
        });
        
        setTimeout(() => {
          if (!prompted) resolve(false);
        }, 5000);
      });
    });
    
    return { installable };
  }
  
  private async testOfflineCapability(page: any) {
    // 模拟离线状态
    await page.setOfflineMode(true);
    
    try {
      await page.reload();
      const content = await page.content();
      
      return {
        success: content.includes('html'),
        hasOfflinePage: content.includes('offline') || content.includes('离线')
      };
    } catch (error) {
      return { success: false, error: error.message };
    } finally {
      await page.setOfflineMode(false);
    }
  }
}
```

---

## 📚 最佳实践总结

### ✅ 响应式设计最佳实践

1. **移动优先设计**
   - 从最小屏幕尺寸开始设计
   - 使用渐进式增强而非优雅降级
   - 优先考虑核心功能和内容

2. **灵活的网格系统**
   - 使用CSS Grid和Flexbox
   - 避免固定宽度和高度
   - 保持适当的内边距和外边距

3. **触摸友好的界面**
   - 点击目标至少44x44px
   - 提供足够的间距避免误触
   - 支持常见的手势操作

### ✅ 可访问性最佳实践

1. **语义化HTML**
   - 使用正确的HTML标签
   - 提供有意义的标题层次
   - 使用列表、表格等结构化元素

2. **键盘导航**
   - 确保所有交互元素可通过键盘访问
   - 提供清晰的焦点指示器
   - 支持快捷键和跳过链接

3. **屏幕阅读器支持**
   - 提供适当的ARIA标签
   - 使用live regions进行动态内容更新
   - 提供有意义的替代文本

### ❌ 常见误区

1. **过度依赖媒体查询**
   - 避免为每个设备创建特定样式
   - 使用相对单位而非绝对像素

2. **忽略性能影响**
   - 响应式图片优化
   - 避免加载不必要的资源

3. **可访问性后置**
   - 从设计阶段就考虑可访问性
   - 定期进行可访问性测试

---

## 🔗 相关资源

- **WCAG 2.1指南**：https://www.w3.org/WAI/WCAG21/quickref/
- **PWA开发指南**：https://web.dev/progressive-web-apps/
- **响应式设计模式**：https://responsivedesign.is/
- **CSS Grid指南**：https://css-tricks.com/snippets/css/complete-guide-grid/
- **Flexbox指南**：https://css-tricks.com/snippets/css/a-guide-to-flexbox/

---

💡 **实施建议**：按照第4周的开发计划，从移动端开始设计，逐步适配到更大屏幕，同时确保每个功能都通过可访问性测试。