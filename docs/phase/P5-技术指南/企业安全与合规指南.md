# 🔒 企业安全与合规指南

## 🎯 技术概述

企业级安全体系为Chat2SQL提供了全方位的安全防护能力，通过零信任网络架构、密钥管理、合规审计等技术实现企业级安全标准。本指南详细介绍P5阶段第3周的安全与合规实现策略。

### ✨ 核心价值

| 功能特性 | 技术实现 | 业务价值 | 安全提升 |
|---------|---------|---------|---------| 
| **零信任网络** | Istio mTLS + NetworkPolicy | 服务间通信加密 | 安全事件减少95% |
| **身份认证** | OAuth 2.1 + JWT + MFA | 统一身份管理 | 未授权访问减少99% |
| **密钥管理** | HashiCorp Vault | 密钥自动轮换 | 密钥泄漏风险减少90% |
| **合规审计** | SOC2 + GDPR + 审计日志 | 合规性保障 | 合规风险减少85% |

### 🎁 安全场景

- **访问控制**：基于角色的精细权限控制、最小权限原则
- **数据保护**：数据加密存储、传输加密、数据脱敏
- **安全监控**：实时威胁检测、异常行为分析、安全事件响应
- **合规管理**：数据治理、隐私保护、审计追踪

---

## 🛡️ 零信任网络架构

### 📦 Istio mTLS配置

```yaml
# istio-security-policies.yaml
# 全局mTLS策略
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT
---
# Chat2SQL命名空间mTLS策略
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: chat2sql-mtls
  namespace: chat2sql
spec:
  mtls:
    mode: STRICT
  portLevelMtls:
    8080:
      mode: STRICT
    9090:
      mode: STRICT
---
# 目标规则 - 强制客户端mTLS
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: chat2sql-mtls-dr
  namespace: chat2sql
spec:
  host: "*.chat2sql.svc.cluster.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
---
# 外部服务目标规则
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: external-services-tls
  namespace: chat2sql
spec:
  host: "*.amazonaws.com"
  trafficPolicy:
    tls:
      mode: SIMPLE
      minProtocolVersion: TLSV1_2
      maxProtocolVersion: TLSV1_3
```

### 🔐 授权策略配置

```yaml
# 细粒度授权策略
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: chat2sql-backend-authz
  namespace: chat2sql
spec:
  selector:
    matchLabels:
      app: chat2sql-backend
  rules:
  # 允许前端服务访问
  - from:
    - source:
        principals: ["cluster.local/ns/chat2sql/sa/chat2sql-frontend"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/v1/*"]
  # 允许监控访问
  - from:
    - source:
        principals: ["cluster.local/ns/monitoring/sa/prometheus"]
    to:
    - operation:
        methods: ["GET"]
        paths: ["/metrics", "/health"]
  # 拒绝所有其他访问
  - {}
---
# 数据库访问授权
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: postgresql-authz
  namespace: chat2sql
spec:
  selector:
    matchLabels:
      app: postgresql
  rules:
  # 只允许后端服务访问数据库
  - from:
    - source:
        principals: 
        - "cluster.local/ns/chat2sql/sa/chat2sql-backend"
        - "cluster.local/ns/chat2sql/sa/migration-job"
    to:
    - operation:
        ports: ["5432"]
---
# 外部API访问控制
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: external-api-authz
  namespace: chat2sql
spec:
  selector:
    matchLabels:
      app: chat2sql-backend
  rules:
  # OpenAI API访问
  - to:
    - operation:
        hosts: ["api.openai.com"]
        methods: ["POST"]
        paths: ["/v1/chat/completions"]
    when:
    - key: source.service_account
      values: ["chat2sql-backend"]
  # 禁止其他外部访问
  - to:
    - operation:
        hosts: ["*"]
    when:
    - key: source.service_account
      values: ["chat2sql-backend"]
    action: DENY
```

### 🌐 网络策略配置

```yaml
# Kubernetes NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: chat2sql-network-policy
  namespace: chat2sql
spec:
  podSelector:
    matchLabels:
      app: chat2sql-backend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 允许同命名空间内的流量
  - from:
    - namespaceSelector:
        matchLabels:
          name: chat2sql
    ports:
    - protocol: TCP
      port: 8080
  # 允许监控命名空间访问
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 9090
  # 允许Istio网关访问
  - from:
    - namespaceSelector:
        matchLabels:
          name: istio-system
  egress:
  # 允许访问数据库
  - to:
    - podSelector:
        matchLabels:
          app: postgresql
    ports:
    - protocol: TCP
      port: 5432
  # 允许访问Redis
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  # 允许DNS解析
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  # 允许HTTPS出站连接
  - to: []
    ports:
    - protocol: TCP
      port: 443
---
# 数据库网络策略
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: postgresql-network-policy
  namespace: chat2sql
spec:
  podSelector:
    matchLabels:
      app: postgresql
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 只允许后端服务访问
  - from:
    - podSelector:
        matchLabels:
          app: chat2sql-backend
    ports:
    - protocol: TCP
      port: 5432
  # 允许监控访问
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 9187  # postgres_exporter
  egress:
  # 允许DNS解析
  - to: []
    ports:
    - protocol: UDP
      port: 53
```

---

## 🔑 身份认证与授权

### 📦 OAuth 2.1 + JWT配置

```go
// JWT认证服务
package auth

import (
    "context"
    "crypto/rsa"
    "fmt"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
    "github.com/google/uuid"
)

// JWT配置
type JWTConfig struct {
    PrivateKey     *rsa.PrivateKey
    PublicKey      *rsa.PublicKey
    Issuer         string
    Audience       string
    ExpirationTime time.Duration
}

// 用户声明
type UserClaims struct {
    UserID    string   `json:"user_id"`
    Email     string   `json:"email"`
    Roles     []string `json:"roles"`
    Scope     []string `json:"scope"`
    TenantID  string   `json:"tenant_id"`
    SessionID string   `json:"session_id"`
    jwt.RegisteredClaims
}

// JWT服务
type JWTService struct {
    config     *JWTConfig
    blacklist  TokenBlacklist
    mfaService MFAService
}

func NewJWTService(config *JWTConfig) *JWTService {
    return &JWTService{
        config:     config,
        blacklist:  NewRedisTokenBlacklist(),
        mfaService: NewTOTPMFAService(),
    }
}

// 生成访问令牌
func (j *JWTService) GenerateAccessToken(ctx context.Context, user *User) (string, error) {
    now := time.Now()
    sessionID := uuid.New().String()
    
    claims := &UserClaims{
        UserID:    user.ID,
        Email:     user.Email,
        Roles:     user.Roles,
        Scope:     user.Scope,
        TenantID:  user.TenantID,
        SessionID: sessionID,
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    j.config.Issuer,
            Audience:  jwt.ClaimStrings{j.config.Audience},
            Subject:   user.ID,
            ExpiresAt: jwt.NewNumericDate(now.Add(j.config.ExpirationTime)),
            NotBefore: jwt.NewNumericDate(now),
            IssuedAt:  jwt.NewNumericDate(now),
            ID:        uuid.New().String(),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    
    // 添加JWT头部
    token.Header["kid"] = "chat2sql-key-1"
    token.Header["typ"] = "JWT"
    
    return token.SignedString(j.config.PrivateKey)
}

// 验证访问令牌
func (j *JWTService) ValidateAccessToken(ctx context.Context, tokenString string) (*UserClaims, error) {
    // 检查黑名单
    if j.blacklist.IsBlacklisted(ctx, tokenString) {
        return nil, fmt.Errorf("token已被撤销")
    }
    
    token, err := jwt.ParseWithClaims(tokenString, &UserClaims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf("意外的签名方法: %v", token.Header["alg"])
        }
        return j.config.PublicKey, nil
    })
    
    if err != nil {
        return nil, fmt.Errorf("token验证失败: %w", err)
    }
    
    if claims, ok := token.Claims.(*UserClaims); ok && token.Valid {
        // 验证额外的业务规则
        if err := j.validateBusinessRules(ctx, claims); err != nil {
            return nil, err
        }
        
        return claims, nil
    }
    
    return nil, fmt.Errorf("无效token")
}

// 验证业务规则
func (j *JWTService) validateBusinessRules(ctx context.Context, claims *UserClaims) error {
    // 检查用户是否仍然活跃
    user, err := j.getUserByID(ctx, claims.UserID)
    if err != nil {
        return fmt.Errorf("用户验证失败: %w", err)
    }
    
    if !user.IsActive {
        return fmt.Errorf("用户账户已被禁用")
    }
    
    // 检查角色是否仍然有效
    if !j.validateUserRoles(user.Roles, claims.Roles) {
        return fmt.Errorf("用户角色已发生变化")
    }
    
    return nil
}

// 撤销令牌
func (j *JWTService) RevokeToken(ctx context.Context, tokenString string) error {
    return j.blacklist.AddToBlacklist(ctx, tokenString, j.config.ExpirationTime)
}
```

### 🔐 多因子认证(MFA)

```go
// MFA服务实现
package auth

import (
    "crypto/rand"
    "encoding/base32"
    "fmt"
    "time"
    
    "github.com/pquerna/otp/totp"
)

// TOTP MFA服务
type TOTPMFAService struct {
    issuer string
    redis  RedisClient
}

func NewTOTPMFAService(issuer string, redis RedisClient) *TOTPMFAService {
    return &TOTPMFAService{
        issuer: issuer,
        redis:  redis,
    }
}

// 生成MFA密钥
func (m *TOTPMFAService) GenerateSecret(ctx context.Context, userID, email string) (*MFASecret, error) {
    key := make([]byte, 20)
    if _, err := rand.Read(key); err != nil {
        return nil, fmt.Errorf("生成密钥失败: %w", err)
    }
    
    secret := base32.StdEncoding.EncodeToString(key)
    
    // 生成QR码URL
    qrURL, err := totp.GenerateCode(secret, &totp.Options{
        Issuer:      m.issuer,
        AccountName: email,
    })
    if err != nil {
        return nil, fmt.Errorf("生成QR码失败: %w", err)
    }
    
    // 存储密钥(加密)
    if err := m.storeSecret(ctx, userID, secret); err != nil {
        return nil, fmt.Errorf("存储密钥失败: %w", err)
    }
    
    return &MFASecret{
        Secret: secret,
        QRCode: qrURL,
    }, nil
}

// 验证TOTP码
func (m *TOTPMFAService) ValidateTOTP(ctx context.Context, userID, code string) error {
    secret, err := m.getSecret(ctx, userID)
    if err != nil {
        return fmt.Errorf("获取密钥失败: %w", err)
    }
    
    // 检查是否已使用过此代码（防重放攻击）
    cacheKey := fmt.Sprintf("totp_used:%s:%s", userID, code)
    if exists, _ := m.redis.Exists(ctx, cacheKey).Result(); exists > 0 {
        return fmt.Errorf("TOTP代码已使用")
    }
    
    // 验证TOTP代码
    valid := totp.Validate(code, secret, time.Now())
    if !valid {
        // 允许30秒的时间窗口偏差
        valid = totp.Validate(code, secret, time.Now().Add(-30*time.Second)) ||
                totp.Validate(code, secret, time.Now().Add(30*time.Second))
    }
    
    if !valid {
        return fmt.Errorf("无效的TOTP代码")
    }
    
    // 标记代码已使用
    m.redis.SetEX(ctx, cacheKey, "1", 90*time.Second)
    
    return nil
}

// 备用恢复码
func (m *TOTPMFAService) GenerateRecoveryCodes(ctx context.Context, userID string) ([]string, error) {
    codes := make([]string, 10)
    for i := range codes {
        code := make([]byte, 8)
        if _, err := rand.Read(code); err != nil {
            return nil, err
        }
        codes[i] = base32.StdEncoding.EncodeToString(code)[:12]
    }
    
    if err := m.storeRecoveryCodes(ctx, userID, codes); err != nil {
        return nil, err
    }
    
    return codes, nil
}
```

### 🎯 RBAC权限控制

```yaml
# Kubernetes RBAC配置
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chat2sql-backend
  namespace: chat2sql
---
# 角色定义
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: chat2sql
  name: chat2sql-app-role
rules:
# 允许访问ConfigMap和Secret
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
# 允许创建事件
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create"]
# 允许访问Pod信息（用于健康检查）
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
  resourceNames: ["chat2sql-backend-*"]
---
# 角色绑定
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: chat2sql-app-binding
  namespace: chat2sql
subjects:
- kind: ServiceAccount
  name: chat2sql-backend
  namespace: chat2sql
roleRef:
  kind: Role
  name: chat2sql-app-role
  apiGroup: rbac.authorization.k8s.io
---
# 集群角色（用于跨命名空间监控）
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: chat2sql-monitoring-role
rules:
- apiGroups: [""]
  resources: ["nodes", "nodes/proxy", "services", "endpoints", "pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions"]
  resources: ["ingresses"]
  verbs: ["get", "list", "watch"]
- nonResourceURLs: ["/metrics"]
  verbs: ["get"]
---
# 集群角色绑定
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: chat2sql-monitoring-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: chat2sql-monitoring-role
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: monitoring
```

---

## 🗝️ 密钥管理 - HashiCorp Vault

### 📦 Vault集群部署

```yaml
# vault-cluster.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: vault-system
---
# Vault ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-config
  namespace: vault-system
data:
  vault.hcl: |
    # Vault配置
    storage "raft" {
      path = "/vault/data"
      node_id = "vault-0"
      
      retry_join {
        leader_api_addr = "https://vault-0.vault-internal:8200"
      }
      retry_join {
        leader_api_addr = "https://vault-1.vault-internal:8200"
      }
      retry_join {
        leader_api_addr = "https://vault-2.vault-internal:8200"
      }
    }
    
    listener "tcp" {
      address = "0.0.0.0:8200"
      tls_cert_file = "/vault/tls/vault.crt"
      tls_key_file = "/vault/tls/vault.key"
      tls_client_ca_file = "/vault/tls/ca.crt"
    }
    
    api_addr = "https://vault.vault-system.svc.cluster.local:8200"
    cluster_addr = "https://vault.vault-system.svc.cluster.local:8201"
    
    ui = true
    
    # 启用Kubernetes认证
    auth "kubernetes" {
      path = "kubernetes"
    }
    
    # 密钥引擎
    secrets "database" {
      path = "database"
    }
    
    secrets "kv-v2" {
      path = "secret"
    }
---
# Vault StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vault
  namespace: vault-system
spec:
  serviceName: vault-internal
  replicas: 3
  selector:
    matchLabels:
      app: vault
  template:
    metadata:
      labels:
        app: vault
    spec:
      serviceAccountName: vault
      containers:
      - name: vault
        image: vault:1.15.0
        ports:
        - containerPort: 8200
          name: vault-port
        - containerPort: 8201
          name: cluster-port
        env:
        - name: VAULT_ADDR
          value: "https://127.0.0.1:8200"
        - name: VAULT_API_ADDR
          value: "https://vault.vault-system.svc.cluster.local:8200"
        - name: SKIP_CHOWN
          value: "true"
        - name: SKIP_SETCAP
          value: "true"
        volumeMounts:
        - name: vault-data
          mountPath: /vault/data
        - name: vault-config
          mountPath: /vault/config
        - name: vault-tls
          mountPath: /vault/tls
        command:
        - vault
        - server
        - -config=/vault/config/vault.hcl
        resources:
          requests:
            memory: 512Mi
            cpu: 250m
          limits:
            memory: 1Gi
            cpu: 500m
        livenessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: vault-config
        configMap:
          name: vault-config
      - name: vault-tls
        secret:
          secretName: vault-tls
  volumeClaimTemplates:
  - metadata:
      name: vault-data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: chat2sql-ssd
      resources:
        requests:
          storage: 10Gi
```

### 🔐 Vault集成配置

```go
// Vault客户端封装
package vault

import (
    "context"
    "fmt"
    "time"
    
    "github.com/hashicorp/vault/api"
    auth "github.com/hashicorp/vault/api/auth/kubernetes"
)

// Vault客户端
type VaultClient struct {
    client     *api.Client
    authMethod *auth.KubernetesAuth
    config     *VaultConfig
}

type VaultConfig struct {
    Address   string
    Role      string
    TokenPath string
    Namespace string
}

func NewVaultClient(config *VaultConfig) (*VaultClient, error) {
    // 创建Vault客户端
    vaultConfig := api.DefaultConfig()
    vaultConfig.Address = config.Address
    
    client, err := api.NewClient(vaultConfig)
    if err != nil {
        return nil, fmt.Errorf("创建Vault客户端失败: %w", err)
    }
    
    // 配置Kubernetes认证
    k8sAuth, err := auth.NewKubernetesAuth(
        config.Role,
        auth.WithServiceAccountTokenPath(config.TokenPath),
    )
    if err != nil {
        return nil, fmt.Errorf("配置Kubernetes认证失败: %w", err)
    }
    
    return &VaultClient{
        client:     client,
        authMethod: k8sAuth,
        config:     config,
    }, nil
}

// 认证到Vault
func (v *VaultClient) Authenticate(ctx context.Context) error {
    authInfo, err := v.client.Auth().Login(ctx, v.authMethod)
    if err != nil {
        return fmt.Errorf("Vault认证失败: %w", err)
    }
    
    if authInfo == nil {
        return fmt.Errorf("Vault认证失败: 未获得认证信息")
    }
    
    // 设置token续期
    go v.renewToken(ctx, authInfo.Auth.LeaseDuration)
    
    return nil
}

// 获取数据库凭据
func (v *VaultClient) GetDatabaseCredentials(ctx context.Context, role string) (*DatabaseCredentials, error) {
    path := fmt.Sprintf("database/creds/%s", role)
    
    secret, err := v.client.Logical().Read(path)
    if err != nil {
        return nil, fmt.Errorf("获取数据库凭据失败: %w", err)
    }
    
    if secret == nil || secret.Data == nil {
        return nil, fmt.Errorf("数据库凭据不存在")
    }
    
    username, ok := secret.Data["username"].(string)
    if !ok {
        return nil, fmt.Errorf("无效的用户名格式")
    }
    
    password, ok := secret.Data["password"].(string)
    if !ok {
        return nil, fmt.Errorf("无效的密码格式")
    }
    
    return &DatabaseCredentials{
        Username:  username,
        Password:  password,
        LeaseID:   secret.LeaseID,
        LeaseDuration: time.Duration(secret.LeaseDuration) * time.Second,
    }, nil
}

// 获取应用密钥
func (v *VaultClient) GetSecret(ctx context.Context, path string) (map[string]interface{}, error) {
    secret, err := v.client.Logical().Read(path)
    if err != nil {
        return nil, fmt.Errorf("获取密钥失败: %w", err)
    }
    
    if secret == nil || secret.Data == nil {
        return nil, fmt.Errorf("密钥不存在: %s", path)
    }
    
    // KV v2引擎需要访问data字段
    if data, ok := secret.Data["data"].(map[string]interface{}); ok {
        return data, nil
    }
    
    return secret.Data, nil
}

// 存储密钥
func (v *VaultClient) PutSecret(ctx context.Context, path string, data map[string]interface{}) error {
    // KV v2引擎需要包装在data字段中
    secretData := map[string]interface{}{
        "data": data,
    }
    
    _, err := v.client.Logical().Write(path, secretData)
    if err != nil {
        return fmt.Errorf("存储密钥失败: %w", err)
    }
    
    return nil
}

// 密钥轮换
func (v *VaultClient) RotateSecret(ctx context.Context, path string) error {
    _, err := v.client.Logical().Write(fmt.Sprintf("%s/rotate", path), nil)
    if err != nil {
        return fmt.Errorf("密钥轮换失败: %w", err)
    }
    
    return nil
}

// Token续期
func (v *VaultClient) renewToken(ctx context.Context, leaseDuration int) {
    ticker := time.NewTicker(time.Duration(leaseDuration/2) * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            _, err := v.client.Auth().Token().RenewSelf(leaseDuration)
            if err != nil {
                log.Printf("Token续期失败: %v", err)
            }
        }
    }
}
```

### 🎯 Vault策略配置

```hcl
# Chat2SQL应用策略
path "secret/data/chat2sql/*" {
  capabilities = ["read"]
}

path "secret/metadata/chat2sql/*" {
  capabilities = ["list"]
}

# 数据库动态凭据
path "database/creds/chat2sql-app" {
  capabilities = ["read"]
}

path "database/creds/chat2sql-readonly" {
  capabilities = ["read"]
}

# JWT密钥访问
path "secret/data/jwt/signing-key" {
  capabilities = ["read"]
}

# 加密传输密钥
path "transit/encrypt/chat2sql" {
  capabilities = ["update"]
}

path "transit/decrypt/chat2sql" {
  capabilities = ["update"]
}

# 审计日志
path "sys/audit" {
  capabilities = ["read"]
}
```

---

## 🛡️ Pod安全标准

### 📦 Pod Security Standards

```yaml
# Pod安全策略
apiVersion: v1
kind: Namespace
metadata:
  name: chat2sql
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
---
# SecurityContext配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: chat2sql-backend-secure
  namespace: chat2sql
spec:
  template:
    spec:
      # Pod级别安全上下文
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        runAsGroup: 65534
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: chat2sql
        image: chat2sql/backend:v1.0.0
        # 容器级别安全上下文
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 65534
          runAsGroup: 65534
          capabilities:
            drop:
            - ALL
          seccompProfile:
            type: RuntimeDefault
        # 资源限制
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        # 只读文件系统需要临时目录
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: var-cache
          mountPath: /var/cache
      volumes:
      - name: tmp
        emptyDir: {}
      - name: var-cache
        emptyDir: {}
```

### 🔒 OPA Gatekeeper策略

```yaml
# 约束模板 - 禁止特权容器
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecuritycontext
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecurityContext
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecuritycontext
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsNonRoot
          msg := "容器必须以非root用户运行"
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.readOnlyRootFilesystem
          msg := "容器必须使用只读根文件系统"
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.allowPrivilegeEscalation
          msg := "容器不能允许特权提升"
        }
---
# 应用约束
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredSecurityContext
metadata:
  name: must-have-security-context
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet"]
    namespaces: ["chat2sql"]
---
# 镜像安全约束
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredimagesecurity
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredImageSecurity
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowedRegistries:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredimagesecurity
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not startswith(container.image, input.parameters.allowedRegistries[_])
          msg := sprintf("镜像 %v 不来自允许的注册表", [container.image])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          endswith(container.image, ":latest")
          msg := "不允许使用latest标签"
        }
---
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredImageSecurity
metadata:
  name: allowed-registries
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet"]
    namespaces: ["chat2sql"]
  parameters:
    allowedRegistries:
      - "ghcr.io/chat2sql/"
      - "registry.k8s.io/"
      - "docker.io/library/"
```

---

## 📋 合规性管理

### 📦 SOC2 合规配置

```go
// SOC2审计日志
package compliance

import (
    "context"
    "encoding/json"
    "time"
)

// SOC2审计事件
type SOC2AuditEvent struct {
    EventID      string                 `json:"event_id"`
    Timestamp    time.Time              `json:"timestamp"`
    EventType    string                 `json:"event_type"`
    UserID       string                 `json:"user_id"`
    ResourceType string                 `json:"resource_type"`
    ResourceID   string                 `json:"resource_id"`
    Action       string                 `json:"action"`
    Result       string                 `json:"result"`
    IPAddress    string                 `json:"ip_address"`
    UserAgent    string                 `json:"user_agent"`
    Metadata     map[string]interface{} `json:"metadata"`
    
    // SOC2特定字段
    ControlPoint string `json:"control_point"`
    RiskLevel    string `json:"risk_level"`
    Compliance   string `json:"compliance_framework"`
}

// SOC2审计器
type SOC2Auditor struct {
    logger   AuditLogger
    storage  AuditStorage
    notifier AlertNotifier
}

func NewSOC2Auditor() *SOC2Auditor {
    return &SOC2Auditor{
        logger:   NewStructuredLogger(),
        storage:  NewAuditStorage(),
        notifier: NewComplianceAlertNotifier(),
    }
}

// 记录用户访问事件
func (a *SOC2Auditor) LogUserAccess(ctx context.Context, userID, resource, action, result string) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "user_access",
        UserID:       userID,
        ResourceType: "database",
        ResourceID:   resource,
        Action:       action,
        Result:       result,
        IPAddress:    getClientIP(ctx),
        UserAgent:    getUserAgent(ctx),
        ControlPoint: "CC6.1",  // SOC2控制点
        RiskLevel:    determineRiskLevel(action),
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
}

// 记录数据变更事件
func (a *SOC2Auditor) LogDataChange(ctx context.Context, userID, table, operation string, before, after interface{}) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "data_change",
        UserID:       userID,
        ResourceType: "database_table",
        ResourceID:   table,
        Action:       operation,
        Result:       "success",
        IPAddress:    getClientIP(ctx),
        Metadata: map[string]interface{}{
            "before": before,
            "after":  after,
            "change_type": operation,
        },
        ControlPoint: "CC6.3",
        RiskLevel:    "medium",
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
}

// 记录权限变更事件
func (a *SOC2Auditor) LogPermissionChange(ctx context.Context, adminUserID, targetUserID string, oldRoles, newRoles []string) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "permission_change",
        UserID:       adminUserID,
        ResourceType: "user_permissions",
        ResourceID:   targetUserID,
        Action:       "modify_roles",
        Result:       "success",
        IPAddress:    getClientIP(ctx),
        Metadata: map[string]interface{}{
            "target_user": targetUserID,
            "old_roles":   oldRoles,
            "new_roles":   newRoles,
        },
        ControlPoint: "CC6.2",
        RiskLevel:    "high",
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
    
    // 高风险事件立即通知
    a.notifier.SendComplianceAlert(event)
}

// 记录系统配置变更
func (a *SOC2Auditor) LogSystemConfigChange(ctx context.Context, userID, component, setting string, oldValue, newValue interface{}) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "system_config_change",
        UserID:       userID,
        ResourceType: "system_configuration",
        ResourceID:   component,
        Action:       "modify_setting",
        Result:       "success",
        IPAddress:    getClientIP(ctx),
        Metadata: map[string]interface{}{
            "setting":   setting,
            "old_value": oldValue,
            "new_value": newValue,
        },
        ControlPoint: "CC8.1",
        RiskLevel:    "high",
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
}
```

### 🔒 GDPR数据保护

```go
// GDPR数据保护服务
package gdpr

import (
    "context"
    "fmt"
    "time"
)

// GDPR服务
type GDPRService struct {
    dataMapper     DataMapper
    encryptionSvc  EncryptionService
    retentionMgr   RetentionManager
    consentMgr     ConsentManager
    auditLogger    GDPRAuditLogger
}

// 个人数据处理记录
type DataProcessingRecord struct {
    ID                string    `json:"id"`
    UserID            string    `json:"user_id"`
    DataType          string    `json:"data_type"`
    ProcessingPurpose string    `json:"processing_purpose"`
    LegalBasis        string    `json:"legal_basis"`
    ConsentStatus     string    `json:"consent_status"`
    ProcessedAt       time.Time `json:"processed_at"`
    RetentionPeriod   int       `json:"retention_period_days"`
    Location          string    `json:"processing_location"`
}

// 用户数据导出（数据可携带权）
func (g *GDPRService) ExportUserData(ctx context.Context, userID string) (*UserDataExport, error) {
    // 验证用户身份
    if err := g.verifyUserIdentity(ctx, userID); err != nil {
        return nil, fmt.Errorf("身份验证失败: %w", err)
    }
    
    // 记录数据导出请求
    g.auditLogger.LogDataExportRequest(ctx, userID)
    
    // 收集所有个人数据
    personalData, err := g.dataMapper.CollectUserData(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("收集用户数据失败: %w", err)
    }
    
    // 解密敏感数据
    decryptedData, err := g.encryptionSvc.DecryptPersonalData(personalData)
    if err != nil {
        return nil, fmt.Errorf("解密数据失败: %w", err)
    }
    
    export := &UserDataExport{
        UserID:       userID,
        ExportDate:   time.Now(),
        DataSections: decryptedData,
        Format:       "JSON",
        Checksum:     calculateChecksum(decryptedData),
    }
    
    // 记录数据导出完成
    g.auditLogger.LogDataExportCompleted(ctx, userID, len(decryptedData))
    
    return export, nil
}

// 用户数据删除（删除权/被遗忘权）
func (g *GDPRService) DeleteUserData(ctx context.Context, userID string, deleteType string) error {
    // 验证删除请求的合法性
    if err := g.validateDeletionRequest(ctx, userID, deleteType); err != nil {
        return fmt.Errorf("删除请求验证失败: %w", err)
    }
    
    // 记录删除请求
    g.auditLogger.LogDataDeletionRequest(ctx, userID, deleteType)
    
    switch deleteType {
    case "full_deletion":
        return g.performFullDeletion(ctx, userID)
    case "anonymization":
        return g.performAnonymization(ctx, userID)
    case "selective_deletion":
        return g.performSelectiveDeletion(ctx, userID)
    default:
        return fmt.Errorf("不支持的删除类型: %s", deleteType)
    }
}

// 完全删除
func (g *GDPRService) performFullDeletion(ctx context.Context, userID string) error {
    // 1. 标记待删除
    if err := g.markForDeletion(ctx, userID); err != nil {
        return err
    }
    
    // 2. 删除主数据
    tables := []string{"users", "user_profiles", "query_history", "user_sessions"}
    for _, table := range tables {
        if err := g.deleteFromTable(ctx, table, userID); err != nil {
            return fmt.Errorf("删除表 %s 中的数据失败: %w", table, err)
        }
    }
    
    // 3. 删除备份中的数据
    if err := g.deleteFromBackups(ctx, userID); err != nil {
        return fmt.Errorf("删除备份数据失败: %w", err)
    }
    
    // 4. 删除日志中的个人标识信息
    if err := g.anonymizeLogsForUser(ctx, userID); err != nil {
        return fmt.Errorf("匿名化日志失败: %w", err)
    }
    
    // 5. 记录删除完成
    g.auditLogger.LogDataDeletionCompleted(ctx, userID, "full_deletion")
    
    return nil
}

// 同意管理
func (g *GDPRService) UpdateConsent(ctx context.Context, userID string, consentType string, granted bool) error {
    consent := &ConsentRecord{
        UserID:      userID,
        ConsentType: consentType,
        Granted:     granted,
        UpdatedAt:   time.Now(),
        IPAddress:   getClientIP(ctx),
        UserAgent:   getUserAgent(ctx),
    }
    
    if err := g.consentMgr.UpdateConsent(ctx, consent); err != nil {
        return fmt.Errorf("更新同意状态失败: %w", err)
    }
    
    // 记录同意变更
    g.auditLogger.LogConsentChange(ctx, userID, consentType, granted)
    
    // 如果撤回同意，触发相应的数据处理停止
    if !granted {
        if err := g.handleConsentWithdrawal(ctx, userID, consentType); err != nil {
            return fmt.Errorf("处理同意撤回失败: %w", err)
        }
    }
    
    return nil
}

// 数据保留管理
func (g *GDPRService) ManageDataRetention(ctx context.Context) error {
    // 查找过期数据
    expiredData, err := g.retentionMgr.FindExpiredData(ctx)
    if err != nil {
        return fmt.Errorf("查找过期数据失败: %w", err)
    }
    
    for _, data := range expiredData {
        // 评估是否可以删除
        if g.canDeleteData(data) {
            if err := g.deleteExpiredData(ctx, data); err != nil {
                log.Printf("删除过期数据失败: %v", err)
                continue
            }
            
            g.auditLogger.LogDataRetentionDeletion(ctx, data.UserID, data.DataType)
        }
    }
    
    return nil
}
```

---

## 📚 最佳实践总结

### ✅ 推荐做法

1. **零信任架构**
   - 默认拒绝所有通信
   - 服务间通信强制mTLS
   - 实施最小权限原则

2. **身份认证**
   - 强制多因子认证
   - 短期JWT令牌
   - 定期密钥轮换

3. **密钥管理**
   - 集中化密钥管理
   - 自动化密钥轮换
   - 审计密钥访问

4. **合规管理**
   - 完整审计追踪
   - 自动化合规检查
   - 定期合规审计

### ❌ 避免的陷阱

1. **过度宽松的权限**
   - 避免使用cluster-admin权限
   - 不要忽视网络策略配置

2. **密钥安全**
   - 不要在代码中硬编码密钥
   - 避免长期有效的访问令牌

3. **合规疏漏**
   - 不要忽视审计日志保留
   - 避免处理数据缺乏法律依据

---

## 🔗 相关资源

- **Istio安全文档**：https://istio.io/latest/docs/concepts/security/
- **Vault官方文档**：https://www.vaultproject.io/docs
- **Kubernetes安全最佳实践**：https://kubernetes.io/docs/concepts/security/
- **GDPR合规指南**：https://gdpr.eu/

---

💡 **实施建议**：按照第3周的开发计划，先配置基础安全策略，然后逐步实施密钥管理、合规审计，确保安全合规100%达标。