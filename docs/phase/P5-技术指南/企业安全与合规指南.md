# ğŸ”’ ä¼ä¸šå®‰å…¨ä¸åˆè§„æŒ‡å—

## ğŸ¯ æŠ€æœ¯æ¦‚è¿°

ä¼ä¸šçº§å®‰å…¨ä½“ç³»ä¸ºChat2SQLæä¾›äº†å…¨æ–¹ä½çš„å®‰å…¨é˜²æŠ¤èƒ½åŠ›ï¼Œé€šè¿‡é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„ã€å¯†é’¥ç®¡ç†ã€åˆè§„å®¡è®¡ç­‰æŠ€æœ¯å®ç°ä¼ä¸šçº§å®‰å…¨æ ‡å‡†ã€‚æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»P5é˜¶æ®µç¬¬3å‘¨çš„å®‰å…¨ä¸åˆè§„å®ç°ç­–ç•¥ã€‚

### âœ¨ æ ¸å¿ƒä»·å€¼

| åŠŸèƒ½ç‰¹æ€§ | æŠ€æœ¯å®ç° | ä¸šåŠ¡ä»·å€¼ | å®‰å…¨æå‡ |
|---------|---------|---------|---------| 
| **é›¶ä¿¡ä»»ç½‘ç»œ** | Istio mTLS + NetworkPolicy | æœåŠ¡é—´é€šä¿¡åŠ å¯† | å®‰å…¨äº‹ä»¶å‡å°‘95% |
| **èº«ä»½è®¤è¯** | OAuth 2.1 + JWT + MFA | ç»Ÿä¸€èº«ä»½ç®¡ç† | æœªæˆæƒè®¿é—®å‡å°‘99% |
| **å¯†é’¥ç®¡ç†** | HashiCorp Vault | å¯†é’¥è‡ªåŠ¨è½®æ¢ | å¯†é’¥æ³„æ¼é£é™©å‡å°‘90% |
| **åˆè§„å®¡è®¡** | SOC2 + GDPR + å®¡è®¡æ—¥å¿— | åˆè§„æ€§ä¿éšœ | åˆè§„é£é™©å‡å°‘85% |

### ğŸ å®‰å…¨åœºæ™¯

- **è®¿é—®æ§åˆ¶**ï¼šåŸºäºè§’è‰²çš„ç²¾ç»†æƒé™æ§åˆ¶ã€æœ€å°æƒé™åŸåˆ™
- **æ•°æ®ä¿æŠ¤**ï¼šæ•°æ®åŠ å¯†å­˜å‚¨ã€ä¼ è¾“åŠ å¯†ã€æ•°æ®è„±æ•
- **å®‰å…¨ç›‘æ§**ï¼šå®æ—¶å¨èƒæ£€æµ‹ã€å¼‚å¸¸è¡Œä¸ºåˆ†æã€å®‰å…¨äº‹ä»¶å“åº”
- **åˆè§„ç®¡ç†**ï¼šæ•°æ®æ²»ç†ã€éšç§ä¿æŠ¤ã€å®¡è®¡è¿½è¸ª

---

## ğŸ›¡ï¸ é›¶ä¿¡ä»»ç½‘ç»œæ¶æ„

### ğŸ“¦ Istio mTLSé…ç½®

```yaml
# istio-security-policies.yaml
# å…¨å±€mTLSç­–ç•¥
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT
---
# Chat2SQLå‘½åç©ºé—´mTLSç­–ç•¥
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: chat2sql-mtls
  namespace: chat2sql
spec:
  mtls:
    mode: STRICT
  portLevelMtls:
    8080:
      mode: STRICT
    9090:
      mode: STRICT
---
# ç›®æ ‡è§„åˆ™ - å¼ºåˆ¶å®¢æˆ·ç«¯mTLS
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: chat2sql-mtls-dr
  namespace: chat2sql
spec:
  host: "*.chat2sql.svc.cluster.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
---
# å¤–éƒ¨æœåŠ¡ç›®æ ‡è§„åˆ™
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: external-services-tls
  namespace: chat2sql
spec:
  host: "*.amazonaws.com"
  trafficPolicy:
    tls:
      mode: SIMPLE
      minProtocolVersion: TLSV1_2
      maxProtocolVersion: TLSV1_3
```

### ğŸ” æˆæƒç­–ç•¥é…ç½®

```yaml
# ç»†ç²’åº¦æˆæƒç­–ç•¥
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: chat2sql-backend-authz
  namespace: chat2sql
spec:
  selector:
    matchLabels:
      app: chat2sql-backend
  rules:
  # å…è®¸å‰ç«¯æœåŠ¡è®¿é—®
  - from:
    - source:
        principals: ["cluster.local/ns/chat2sql/sa/chat2sql-frontend"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/v1/*"]
  # å…è®¸ç›‘æ§è®¿é—®
  - from:
    - source:
        principals: ["cluster.local/ns/monitoring/sa/prometheus"]
    to:
    - operation:
        methods: ["GET"]
        paths: ["/metrics", "/health"]
  # æ‹’ç»æ‰€æœ‰å…¶ä»–è®¿é—®
  - {}
---
# æ•°æ®åº“è®¿é—®æˆæƒ
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: postgresql-authz
  namespace: chat2sql
spec:
  selector:
    matchLabels:
      app: postgresql
  rules:
  # åªå…è®¸åç«¯æœåŠ¡è®¿é—®æ•°æ®åº“
  - from:
    - source:
        principals: 
        - "cluster.local/ns/chat2sql/sa/chat2sql-backend"
        - "cluster.local/ns/chat2sql/sa/migration-job"
    to:
    - operation:
        ports: ["5432"]
---
# å¤–éƒ¨APIè®¿é—®æ§åˆ¶
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: external-api-authz
  namespace: chat2sql
spec:
  selector:
    matchLabels:
      app: chat2sql-backend
  rules:
  # OpenAI APIè®¿é—®
  - to:
    - operation:
        hosts: ["api.openai.com"]
        methods: ["POST"]
        paths: ["/v1/chat/completions"]
    when:
    - key: source.service_account
      values: ["chat2sql-backend"]
  # ç¦æ­¢å…¶ä»–å¤–éƒ¨è®¿é—®
  - to:
    - operation:
        hosts: ["*"]
    when:
    - key: source.service_account
      values: ["chat2sql-backend"]
    action: DENY
```

### ğŸŒ ç½‘ç»œç­–ç•¥é…ç½®

```yaml
# Kubernetes NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: chat2sql-network-policy
  namespace: chat2sql
spec:
  podSelector:
    matchLabels:
      app: chat2sql-backend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # å…è®¸åŒå‘½åç©ºé—´å†…çš„æµé‡
  - from:
    - namespaceSelector:
        matchLabels:
          name: chat2sql
    ports:
    - protocol: TCP
      port: 8080
  # å…è®¸ç›‘æ§å‘½åç©ºé—´è®¿é—®
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 9090
  # å…è®¸Istioç½‘å…³è®¿é—®
  - from:
    - namespaceSelector:
        matchLabels:
          name: istio-system
  egress:
  # å…è®¸è®¿é—®æ•°æ®åº“
  - to:
    - podSelector:
        matchLabels:
          app: postgresql
    ports:
    - protocol: TCP
      port: 5432
  # å…è®¸è®¿é—®Redis
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  # å…è®¸DNSè§£æ
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  # å…è®¸HTTPSå‡ºç«™è¿æ¥
  - to: []
    ports:
    - protocol: TCP
      port: 443
---
# æ•°æ®åº“ç½‘ç»œç­–ç•¥
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: postgresql-network-policy
  namespace: chat2sql
spec:
  podSelector:
    matchLabels:
      app: postgresql
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # åªå…è®¸åç«¯æœåŠ¡è®¿é—®
  - from:
    - podSelector:
        matchLabels:
          app: chat2sql-backend
    ports:
    - protocol: TCP
      port: 5432
  # å…è®¸ç›‘æ§è®¿é—®
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 9187  # postgres_exporter
  egress:
  # å…è®¸DNSè§£æ
  - to: []
    ports:
    - protocol: UDP
      port: 53
```

---

## ğŸ”‘ èº«ä»½è®¤è¯ä¸æˆæƒ

### ğŸ“¦ OAuth 2.1 + JWTé…ç½®

```go
// JWTè®¤è¯æœåŠ¡
package auth

import (
    "context"
    "crypto/rsa"
    "fmt"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
    "github.com/google/uuid"
)

// JWTé…ç½®
type JWTConfig struct {
    PrivateKey     *rsa.PrivateKey
    PublicKey      *rsa.PublicKey
    Issuer         string
    Audience       string
    ExpirationTime time.Duration
}

// ç”¨æˆ·å£°æ˜
type UserClaims struct {
    UserID    string   `json:"user_id"`
    Email     string   `json:"email"`
    Roles     []string `json:"roles"`
    Scope     []string `json:"scope"`
    TenantID  string   `json:"tenant_id"`
    SessionID string   `json:"session_id"`
    jwt.RegisteredClaims
}

// JWTæœåŠ¡
type JWTService struct {
    config     *JWTConfig
    blacklist  TokenBlacklist
    mfaService MFAService
}

func NewJWTService(config *JWTConfig) *JWTService {
    return &JWTService{
        config:     config,
        blacklist:  NewRedisTokenBlacklist(),
        mfaService: NewTOTPMFAService(),
    }
}

// ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
func (j *JWTService) GenerateAccessToken(ctx context.Context, user *User) (string, error) {
    now := time.Now()
    sessionID := uuid.New().String()
    
    claims := &UserClaims{
        UserID:    user.ID,
        Email:     user.Email,
        Roles:     user.Roles,
        Scope:     user.Scope,
        TenantID:  user.TenantID,
        SessionID: sessionID,
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    j.config.Issuer,
            Audience:  jwt.ClaimStrings{j.config.Audience},
            Subject:   user.ID,
            ExpiresAt: jwt.NewNumericDate(now.Add(j.config.ExpirationTime)),
            NotBefore: jwt.NewNumericDate(now),
            IssuedAt:  jwt.NewNumericDate(now),
            ID:        uuid.New().String(),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    
    // æ·»åŠ JWTå¤´éƒ¨
    token.Header["kid"] = "chat2sql-key-1"
    token.Header["typ"] = "JWT"
    
    return token.SignedString(j.config.PrivateKey)
}

// éªŒè¯è®¿é—®ä»¤ç‰Œ
func (j *JWTService) ValidateAccessToken(ctx context.Context, tokenString string) (*UserClaims, error) {
    // æ£€æŸ¥é»‘åå•
    if j.blacklist.IsBlacklisted(ctx, tokenString) {
        return nil, fmt.Errorf("tokenå·²è¢«æ’¤é”€")
    }
    
    token, err := jwt.ParseWithClaims(tokenString, &UserClaims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf("æ„å¤–çš„ç­¾åæ–¹æ³•: %v", token.Header["alg"])
        }
        return j.config.PublicKey, nil
    })
    
    if err != nil {
        return nil, fmt.Errorf("tokenéªŒè¯å¤±è´¥: %w", err)
    }
    
    if claims, ok := token.Claims.(*UserClaims); ok && token.Valid {
        // éªŒè¯é¢å¤–çš„ä¸šåŠ¡è§„åˆ™
        if err := j.validateBusinessRules(ctx, claims); err != nil {
            return nil, err
        }
        
        return claims, nil
    }
    
    return nil, fmt.Errorf("æ— æ•ˆtoken")
}

// éªŒè¯ä¸šåŠ¡è§„åˆ™
func (j *JWTService) validateBusinessRules(ctx context.Context, claims *UserClaims) error {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä»ç„¶æ´»è·ƒ
    user, err := j.getUserByID(ctx, claims.UserID)
    if err != nil {
        return fmt.Errorf("ç”¨æˆ·éªŒè¯å¤±è´¥: %w", err)
    }
    
    if !user.IsActive {
        return fmt.Errorf("ç”¨æˆ·è´¦æˆ·å·²è¢«ç¦ç”¨")
    }
    
    // æ£€æŸ¥è§’è‰²æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
    if !j.validateUserRoles(user.Roles, claims.Roles) {
        return fmt.Errorf("ç”¨æˆ·è§’è‰²å·²å‘ç”Ÿå˜åŒ–")
    }
    
    return nil
}

// æ’¤é”€ä»¤ç‰Œ
func (j *JWTService) RevokeToken(ctx context.Context, tokenString string) error {
    return j.blacklist.AddToBlacklist(ctx, tokenString, j.config.ExpirationTime)
}
```

### ğŸ” å¤šå› å­è®¤è¯(MFA)

```go
// MFAæœåŠ¡å®ç°
package auth

import (
    "crypto/rand"
    "encoding/base32"
    "fmt"
    "time"
    
    "github.com/pquerna/otp/totp"
)

// TOTP MFAæœåŠ¡
type TOTPMFAService struct {
    issuer string
    redis  RedisClient
}

func NewTOTPMFAService(issuer string, redis RedisClient) *TOTPMFAService {
    return &TOTPMFAService{
        issuer: issuer,
        redis:  redis,
    }
}

// ç”ŸæˆMFAå¯†é’¥
func (m *TOTPMFAService) GenerateSecret(ctx context.Context, userID, email string) (*MFASecret, error) {
    key := make([]byte, 20)
    if _, err := rand.Read(key); err != nil {
        return nil, fmt.Errorf("ç”Ÿæˆå¯†é’¥å¤±è´¥: %w", err)
    }
    
    secret := base32.StdEncoding.EncodeToString(key)
    
    // ç”ŸæˆQRç URL
    qrURL, err := totp.GenerateCode(secret, &totp.Options{
        Issuer:      m.issuer,
        AccountName: email,
    })
    if err != nil {
        return nil, fmt.Errorf("ç”ŸæˆQRç å¤±è´¥: %w", err)
    }
    
    // å­˜å‚¨å¯†é’¥(åŠ å¯†)
    if err := m.storeSecret(ctx, userID, secret); err != nil {
        return nil, fmt.Errorf("å­˜å‚¨å¯†é’¥å¤±è´¥: %w", err)
    }
    
    return &MFASecret{
        Secret: secret,
        QRCode: qrURL,
    }, nil
}

// éªŒè¯TOTPç 
func (m *TOTPMFAService) ValidateTOTP(ctx context.Context, userID, code string) error {
    secret, err := m.getSecret(ctx, userID)
    if err != nil {
        return fmt.Errorf("è·å–å¯†é’¥å¤±è´¥: %w", err)
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²ä½¿ç”¨è¿‡æ­¤ä»£ç ï¼ˆé˜²é‡æ”¾æ”»å‡»ï¼‰
    cacheKey := fmt.Sprintf("totp_used:%s:%s", userID, code)
    if exists, _ := m.redis.Exists(ctx, cacheKey).Result(); exists > 0 {
        return fmt.Errorf("TOTPä»£ç å·²ä½¿ç”¨")
    }
    
    // éªŒè¯TOTPä»£ç 
    valid := totp.Validate(code, secret, time.Now())
    if !valid {
        // å…è®¸30ç§’çš„æ—¶é—´çª—å£åå·®
        valid = totp.Validate(code, secret, time.Now().Add(-30*time.Second)) ||
                totp.Validate(code, secret, time.Now().Add(30*time.Second))
    }
    
    if !valid {
        return fmt.Errorf("æ— æ•ˆçš„TOTPä»£ç ")
    }
    
    // æ ‡è®°ä»£ç å·²ä½¿ç”¨
    m.redis.SetEX(ctx, cacheKey, "1", 90*time.Second)
    
    return nil
}

// å¤‡ç”¨æ¢å¤ç 
func (m *TOTPMFAService) GenerateRecoveryCodes(ctx context.Context, userID string) ([]string, error) {
    codes := make([]string, 10)
    for i := range codes {
        code := make([]byte, 8)
        if _, err := rand.Read(code); err != nil {
            return nil, err
        }
        codes[i] = base32.StdEncoding.EncodeToString(code)[:12]
    }
    
    if err := m.storeRecoveryCodes(ctx, userID, codes); err != nil {
        return nil, err
    }
    
    return codes, nil
}
```

### ğŸ¯ RBACæƒé™æ§åˆ¶

```yaml
# Kubernetes RBACé…ç½®
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chat2sql-backend
  namespace: chat2sql
---
# è§’è‰²å®šä¹‰
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: chat2sql
  name: chat2sql-app-role
rules:
# å…è®¸è®¿é—®ConfigMapå’ŒSecret
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
# å…è®¸åˆ›å»ºäº‹ä»¶
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create"]
# å…è®¸è®¿é—®Podä¿¡æ¯ï¼ˆç”¨äºå¥åº·æ£€æŸ¥ï¼‰
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
  resourceNames: ["chat2sql-backend-*"]
---
# è§’è‰²ç»‘å®š
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: chat2sql-app-binding
  namespace: chat2sql
subjects:
- kind: ServiceAccount
  name: chat2sql-backend
  namespace: chat2sql
roleRef:
  kind: Role
  name: chat2sql-app-role
  apiGroup: rbac.authorization.k8s.io
---
# é›†ç¾¤è§’è‰²ï¼ˆç”¨äºè·¨å‘½åç©ºé—´ç›‘æ§ï¼‰
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: chat2sql-monitoring-role
rules:
- apiGroups: [""]
  resources: ["nodes", "nodes/proxy", "services", "endpoints", "pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions"]
  resources: ["ingresses"]
  verbs: ["get", "list", "watch"]
- nonResourceURLs: ["/metrics"]
  verbs: ["get"]
---
# é›†ç¾¤è§’è‰²ç»‘å®š
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: chat2sql-monitoring-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: chat2sql-monitoring-role
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: monitoring
```

---

## ğŸ—ï¸ å¯†é’¥ç®¡ç† - HashiCorp Vault

### ğŸ“¦ Vaulté›†ç¾¤éƒ¨ç½²

```yaml
# vault-cluster.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: vault-system
---
# Vault ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-config
  namespace: vault-system
data:
  vault.hcl: |
    # Vaulté…ç½®
    storage "raft" {
      path = "/vault/data"
      node_id = "vault-0"
      
      retry_join {
        leader_api_addr = "https://vault-0.vault-internal:8200"
      }
      retry_join {
        leader_api_addr = "https://vault-1.vault-internal:8200"
      }
      retry_join {
        leader_api_addr = "https://vault-2.vault-internal:8200"
      }
    }
    
    listener "tcp" {
      address = "0.0.0.0:8200"
      tls_cert_file = "/vault/tls/vault.crt"
      tls_key_file = "/vault/tls/vault.key"
      tls_client_ca_file = "/vault/tls/ca.crt"
    }
    
    api_addr = "https://vault.vault-system.svc.cluster.local:8200"
    cluster_addr = "https://vault.vault-system.svc.cluster.local:8201"
    
    ui = true
    
    # å¯ç”¨Kubernetesè®¤è¯
    auth "kubernetes" {
      path = "kubernetes"
    }
    
    # å¯†é’¥å¼•æ“
    secrets "database" {
      path = "database"
    }
    
    secrets "kv-v2" {
      path = "secret"
    }
---
# Vault StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vault
  namespace: vault-system
spec:
  serviceName: vault-internal
  replicas: 3
  selector:
    matchLabels:
      app: vault
  template:
    metadata:
      labels:
        app: vault
    spec:
      serviceAccountName: vault
      containers:
      - name: vault
        image: vault:1.15.0
        ports:
        - containerPort: 8200
          name: vault-port
        - containerPort: 8201
          name: cluster-port
        env:
        - name: VAULT_ADDR
          value: "https://127.0.0.1:8200"
        - name: VAULT_API_ADDR
          value: "https://vault.vault-system.svc.cluster.local:8200"
        - name: SKIP_CHOWN
          value: "true"
        - name: SKIP_SETCAP
          value: "true"
        volumeMounts:
        - name: vault-data
          mountPath: /vault/data
        - name: vault-config
          mountPath: /vault/config
        - name: vault-tls
          mountPath: /vault/tls
        command:
        - vault
        - server
        - -config=/vault/config/vault.hcl
        resources:
          requests:
            memory: 512Mi
            cpu: 250m
          limits:
            memory: 1Gi
            cpu: 500m
        livenessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: vault-config
        configMap:
          name: vault-config
      - name: vault-tls
        secret:
          secretName: vault-tls
  volumeClaimTemplates:
  - metadata:
      name: vault-data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: chat2sql-ssd
      resources:
        requests:
          storage: 10Gi
```

### ğŸ” Vaulté›†æˆé…ç½®

```go
// Vaultå®¢æˆ·ç«¯å°è£…
package vault

import (
    "context"
    "fmt"
    "time"
    
    "github.com/hashicorp/vault/api"
    auth "github.com/hashicorp/vault/api/auth/kubernetes"
)

// Vaultå®¢æˆ·ç«¯
type VaultClient struct {
    client     *api.Client
    authMethod *auth.KubernetesAuth
    config     *VaultConfig
}

type VaultConfig struct {
    Address   string
    Role      string
    TokenPath string
    Namespace string
}

func NewVaultClient(config *VaultConfig) (*VaultClient, error) {
    // åˆ›å»ºVaultå®¢æˆ·ç«¯
    vaultConfig := api.DefaultConfig()
    vaultConfig.Address = config.Address
    
    client, err := api.NewClient(vaultConfig)
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºVaultå®¢æˆ·ç«¯å¤±è´¥: %w", err)
    }
    
    // é…ç½®Kubernetesè®¤è¯
    k8sAuth, err := auth.NewKubernetesAuth(
        config.Role,
        auth.WithServiceAccountTokenPath(config.TokenPath),
    )
    if err != nil {
        return nil, fmt.Errorf("é…ç½®Kubernetesè®¤è¯å¤±è´¥: %w", err)
    }
    
    return &VaultClient{
        client:     client,
        authMethod: k8sAuth,
        config:     config,
    }, nil
}

// è®¤è¯åˆ°Vault
func (v *VaultClient) Authenticate(ctx context.Context) error {
    authInfo, err := v.client.Auth().Login(ctx, v.authMethod)
    if err != nil {
        return fmt.Errorf("Vaultè®¤è¯å¤±è´¥: %w", err)
    }
    
    if authInfo == nil {
        return fmt.Errorf("Vaultè®¤è¯å¤±è´¥: æœªè·å¾—è®¤è¯ä¿¡æ¯")
    }
    
    // è®¾ç½®tokenç»­æœŸ
    go v.renewToken(ctx, authInfo.Auth.LeaseDuration)
    
    return nil
}

// è·å–æ•°æ®åº“å‡­æ®
func (v *VaultClient) GetDatabaseCredentials(ctx context.Context, role string) (*DatabaseCredentials, error) {
    path := fmt.Sprintf("database/creds/%s", role)
    
    secret, err := v.client.Logical().Read(path)
    if err != nil {
        return nil, fmt.Errorf("è·å–æ•°æ®åº“å‡­æ®å¤±è´¥: %w", err)
    }
    
    if secret == nil || secret.Data == nil {
        return nil, fmt.Errorf("æ•°æ®åº“å‡­æ®ä¸å­˜åœ¨")
    }
    
    username, ok := secret.Data["username"].(string)
    if !ok {
        return nil, fmt.Errorf("æ— æ•ˆçš„ç”¨æˆ·åæ ¼å¼")
    }
    
    password, ok := secret.Data["password"].(string)
    if !ok {
        return nil, fmt.Errorf("æ— æ•ˆçš„å¯†ç æ ¼å¼")
    }
    
    return &DatabaseCredentials{
        Username:  username,
        Password:  password,
        LeaseID:   secret.LeaseID,
        LeaseDuration: time.Duration(secret.LeaseDuration) * time.Second,
    }, nil
}

// è·å–åº”ç”¨å¯†é’¥
func (v *VaultClient) GetSecret(ctx context.Context, path string) (map[string]interface{}, error) {
    secret, err := v.client.Logical().Read(path)
    if err != nil {
        return nil, fmt.Errorf("è·å–å¯†é’¥å¤±è´¥: %w", err)
    }
    
    if secret == nil || secret.Data == nil {
        return nil, fmt.Errorf("å¯†é’¥ä¸å­˜åœ¨: %s", path)
    }
    
    // KV v2å¼•æ“éœ€è¦è®¿é—®dataå­—æ®µ
    if data, ok := secret.Data["data"].(map[string]interface{}); ok {
        return data, nil
    }
    
    return secret.Data, nil
}

// å­˜å‚¨å¯†é’¥
func (v *VaultClient) PutSecret(ctx context.Context, path string, data map[string]interface{}) error {
    // KV v2å¼•æ“éœ€è¦åŒ…è£…åœ¨dataå­—æ®µä¸­
    secretData := map[string]interface{}{
        "data": data,
    }
    
    _, err := v.client.Logical().Write(path, secretData)
    if err != nil {
        return fmt.Errorf("å­˜å‚¨å¯†é’¥å¤±è´¥: %w", err)
    }
    
    return nil
}

// å¯†é’¥è½®æ¢
func (v *VaultClient) RotateSecret(ctx context.Context, path string) error {
    _, err := v.client.Logical().Write(fmt.Sprintf("%s/rotate", path), nil)
    if err != nil {
        return fmt.Errorf("å¯†é’¥è½®æ¢å¤±è´¥: %w", err)
    }
    
    return nil
}

// Tokenç»­æœŸ
func (v *VaultClient) renewToken(ctx context.Context, leaseDuration int) {
    ticker := time.NewTicker(time.Duration(leaseDuration/2) * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            _, err := v.client.Auth().Token().RenewSelf(leaseDuration)
            if err != nil {
                log.Printf("Tokenç»­æœŸå¤±è´¥: %v", err)
            }
        }
    }
}
```

### ğŸ¯ Vaultç­–ç•¥é…ç½®

```hcl
# Chat2SQLåº”ç”¨ç­–ç•¥
path "secret/data/chat2sql/*" {
  capabilities = ["read"]
}

path "secret/metadata/chat2sql/*" {
  capabilities = ["list"]
}

# æ•°æ®åº“åŠ¨æ€å‡­æ®
path "database/creds/chat2sql-app" {
  capabilities = ["read"]
}

path "database/creds/chat2sql-readonly" {
  capabilities = ["read"]
}

# JWTå¯†é’¥è®¿é—®
path "secret/data/jwt/signing-key" {
  capabilities = ["read"]
}

# åŠ å¯†ä¼ è¾“å¯†é’¥
path "transit/encrypt/chat2sql" {
  capabilities = ["update"]
}

path "transit/decrypt/chat2sql" {
  capabilities = ["update"]
}

# å®¡è®¡æ—¥å¿—
path "sys/audit" {
  capabilities = ["read"]
}
```

---

## ğŸ›¡ï¸ Podå®‰å…¨æ ‡å‡†

### ğŸ“¦ Pod Security Standards

```yaml
# Podå®‰å…¨ç­–ç•¥
apiVersion: v1
kind: Namespace
metadata:
  name: chat2sql
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
---
# SecurityContexté…ç½®
apiVersion: apps/v1
kind: Deployment
metadata:
  name: chat2sql-backend-secure
  namespace: chat2sql
spec:
  template:
    spec:
      # Podçº§åˆ«å®‰å…¨ä¸Šä¸‹æ–‡
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        runAsGroup: 65534
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: chat2sql
        image: chat2sql/backend:v1.0.0
        # å®¹å™¨çº§åˆ«å®‰å…¨ä¸Šä¸‹æ–‡
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 65534
          runAsGroup: 65534
          capabilities:
            drop:
            - ALL
          seccompProfile:
            type: RuntimeDefault
        # èµ„æºé™åˆ¶
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        # åªè¯»æ–‡ä»¶ç³»ç»Ÿéœ€è¦ä¸´æ—¶ç›®å½•
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: var-cache
          mountPath: /var/cache
      volumes:
      - name: tmp
        emptyDir: {}
      - name: var-cache
        emptyDir: {}
```

### ğŸ”’ OPA Gatekeeperç­–ç•¥

```yaml
# çº¦æŸæ¨¡æ¿ - ç¦æ­¢ç‰¹æƒå®¹å™¨
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecuritycontext
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecurityContext
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecuritycontext
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsNonRoot
          msg := "å®¹å™¨å¿…é¡»ä»¥érootç”¨æˆ·è¿è¡Œ"
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.readOnlyRootFilesystem
          msg := "å®¹å™¨å¿…é¡»ä½¿ç”¨åªè¯»æ ¹æ–‡ä»¶ç³»ç»Ÿ"
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.allowPrivilegeEscalation
          msg := "å®¹å™¨ä¸èƒ½å…è®¸ç‰¹æƒæå‡"
        }
---
# åº”ç”¨çº¦æŸ
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredSecurityContext
metadata:
  name: must-have-security-context
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet"]
    namespaces: ["chat2sql"]
---
# é•œåƒå®‰å…¨çº¦æŸ
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredimagesecurity
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredImageSecurity
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowedRegistries:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredimagesecurity
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not startswith(container.image, input.parameters.allowedRegistries[_])
          msg := sprintf("é•œåƒ %v ä¸æ¥è‡ªå…è®¸çš„æ³¨å†Œè¡¨", [container.image])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          endswith(container.image, ":latest")
          msg := "ä¸å…è®¸ä½¿ç”¨latestæ ‡ç­¾"
        }
---
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredImageSecurity
metadata:
  name: allowed-registries
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet"]
    namespaces: ["chat2sql"]
  parameters:
    allowedRegistries:
      - "ghcr.io/chat2sql/"
      - "registry.k8s.io/"
      - "docker.io/library/"
```

---

## ğŸ“‹ åˆè§„æ€§ç®¡ç†

### ğŸ“¦ SOC2 åˆè§„é…ç½®

```go
// SOC2å®¡è®¡æ—¥å¿—
package compliance

import (
    "context"
    "encoding/json"
    "time"
)

// SOC2å®¡è®¡äº‹ä»¶
type SOC2AuditEvent struct {
    EventID      string                 `json:"event_id"`
    Timestamp    time.Time              `json:"timestamp"`
    EventType    string                 `json:"event_type"`
    UserID       string                 `json:"user_id"`
    ResourceType string                 `json:"resource_type"`
    ResourceID   string                 `json:"resource_id"`
    Action       string                 `json:"action"`
    Result       string                 `json:"result"`
    IPAddress    string                 `json:"ip_address"`
    UserAgent    string                 `json:"user_agent"`
    Metadata     map[string]interface{} `json:"metadata"`
    
    // SOC2ç‰¹å®šå­—æ®µ
    ControlPoint string `json:"control_point"`
    RiskLevel    string `json:"risk_level"`
    Compliance   string `json:"compliance_framework"`
}

// SOC2å®¡è®¡å™¨
type SOC2Auditor struct {
    logger   AuditLogger
    storage  AuditStorage
    notifier AlertNotifier
}

func NewSOC2Auditor() *SOC2Auditor {
    return &SOC2Auditor{
        logger:   NewStructuredLogger(),
        storage:  NewAuditStorage(),
        notifier: NewComplianceAlertNotifier(),
    }
}

// è®°å½•ç”¨æˆ·è®¿é—®äº‹ä»¶
func (a *SOC2Auditor) LogUserAccess(ctx context.Context, userID, resource, action, result string) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "user_access",
        UserID:       userID,
        ResourceType: "database",
        ResourceID:   resource,
        Action:       action,
        Result:       result,
        IPAddress:    getClientIP(ctx),
        UserAgent:    getUserAgent(ctx),
        ControlPoint: "CC6.1",  // SOC2æ§åˆ¶ç‚¹
        RiskLevel:    determineRiskLevel(action),
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
}

// è®°å½•æ•°æ®å˜æ›´äº‹ä»¶
func (a *SOC2Auditor) LogDataChange(ctx context.Context, userID, table, operation string, before, after interface{}) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "data_change",
        UserID:       userID,
        ResourceType: "database_table",
        ResourceID:   table,
        Action:       operation,
        Result:       "success",
        IPAddress:    getClientIP(ctx),
        Metadata: map[string]interface{}{
            "before": before,
            "after":  after,
            "change_type": operation,
        },
        ControlPoint: "CC6.3",
        RiskLevel:    "medium",
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
}

// è®°å½•æƒé™å˜æ›´äº‹ä»¶
func (a *SOC2Auditor) LogPermissionChange(ctx context.Context, adminUserID, targetUserID string, oldRoles, newRoles []string) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "permission_change",
        UserID:       adminUserID,
        ResourceType: "user_permissions",
        ResourceID:   targetUserID,
        Action:       "modify_roles",
        Result:       "success",
        IPAddress:    getClientIP(ctx),
        Metadata: map[string]interface{}{
            "target_user": targetUserID,
            "old_roles":   oldRoles,
            "new_roles":   newRoles,
        },
        ControlPoint: "CC6.2",
        RiskLevel:    "high",
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
    
    // é«˜é£é™©äº‹ä»¶ç«‹å³é€šçŸ¥
    a.notifier.SendComplianceAlert(event)
}

// è®°å½•ç³»ç»Ÿé…ç½®å˜æ›´
func (a *SOC2Auditor) LogSystemConfigChange(ctx context.Context, userID, component, setting string, oldValue, newValue interface{}) {
    event := &SOC2AuditEvent{
        EventID:      generateEventID(),
        Timestamp:    time.Now(),
        EventType:    "system_config_change",
        UserID:       userID,
        ResourceType: "system_configuration",
        ResourceID:   component,
        Action:       "modify_setting",
        Result:       "success",
        IPAddress:    getClientIP(ctx),
        Metadata: map[string]interface{}{
            "setting":   setting,
            "old_value": oldValue,
            "new_value": newValue,
        },
        ControlPoint: "CC8.1",
        RiskLevel:    "high",
        Compliance:   "SOC2_TYPE2",
    }
    
    a.logEvent(ctx, event)
}
```

### ğŸ”’ GDPRæ•°æ®ä¿æŠ¤

```go
// GDPRæ•°æ®ä¿æŠ¤æœåŠ¡
package gdpr

import (
    "context"
    "fmt"
    "time"
)

// GDPRæœåŠ¡
type GDPRService struct {
    dataMapper     DataMapper
    encryptionSvc  EncryptionService
    retentionMgr   RetentionManager
    consentMgr     ConsentManager
    auditLogger    GDPRAuditLogger
}

// ä¸ªäººæ•°æ®å¤„ç†è®°å½•
type DataProcessingRecord struct {
    ID                string    `json:"id"`
    UserID            string    `json:"user_id"`
    DataType          string    `json:"data_type"`
    ProcessingPurpose string    `json:"processing_purpose"`
    LegalBasis        string    `json:"legal_basis"`
    ConsentStatus     string    `json:"consent_status"`
    ProcessedAt       time.Time `json:"processed_at"`
    RetentionPeriod   int       `json:"retention_period_days"`
    Location          string    `json:"processing_location"`
}

// ç”¨æˆ·æ•°æ®å¯¼å‡ºï¼ˆæ•°æ®å¯æºå¸¦æƒï¼‰
func (g *GDPRService) ExportUserData(ctx context.Context, userID string) (*UserDataExport, error) {
    // éªŒè¯ç”¨æˆ·èº«ä»½
    if err := g.verifyUserIdentity(ctx, userID); err != nil {
        return nil, fmt.Errorf("èº«ä»½éªŒè¯å¤±è´¥: %w", err)
    }
    
    // è®°å½•æ•°æ®å¯¼å‡ºè¯·æ±‚
    g.auditLogger.LogDataExportRequest(ctx, userID)
    
    // æ”¶é›†æ‰€æœ‰ä¸ªäººæ•°æ®
    personalData, err := g.dataMapper.CollectUserData(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("æ”¶é›†ç”¨æˆ·æ•°æ®å¤±è´¥: %w", err)
    }
    
    // è§£å¯†æ•æ„Ÿæ•°æ®
    decryptedData, err := g.encryptionSvc.DecryptPersonalData(personalData)
    if err != nil {
        return nil, fmt.Errorf("è§£å¯†æ•°æ®å¤±è´¥: %w", err)
    }
    
    export := &UserDataExport{
        UserID:       userID,
        ExportDate:   time.Now(),
        DataSections: decryptedData,
        Format:       "JSON",
        Checksum:     calculateChecksum(decryptedData),
    }
    
    // è®°å½•æ•°æ®å¯¼å‡ºå®Œæˆ
    g.auditLogger.LogDataExportCompleted(ctx, userID, len(decryptedData))
    
    return export, nil
}

// ç”¨æˆ·æ•°æ®åˆ é™¤ï¼ˆåˆ é™¤æƒ/è¢«é—å¿˜æƒï¼‰
func (g *GDPRService) DeleteUserData(ctx context.Context, userID string, deleteType string) error {
    // éªŒè¯åˆ é™¤è¯·æ±‚çš„åˆæ³•æ€§
    if err := g.validateDeletionRequest(ctx, userID, deleteType); err != nil {
        return fmt.Errorf("åˆ é™¤è¯·æ±‚éªŒè¯å¤±è´¥: %w", err)
    }
    
    // è®°å½•åˆ é™¤è¯·æ±‚
    g.auditLogger.LogDataDeletionRequest(ctx, userID, deleteType)
    
    switch deleteType {
    case "full_deletion":
        return g.performFullDeletion(ctx, userID)
    case "anonymization":
        return g.performAnonymization(ctx, userID)
    case "selective_deletion":
        return g.performSelectiveDeletion(ctx, userID)
    default:
        return fmt.Errorf("ä¸æ”¯æŒçš„åˆ é™¤ç±»å‹: %s", deleteType)
    }
}

// å®Œå…¨åˆ é™¤
func (g *GDPRService) performFullDeletion(ctx context.Context, userID string) error {
    // 1. æ ‡è®°å¾…åˆ é™¤
    if err := g.markForDeletion(ctx, userID); err != nil {
        return err
    }
    
    // 2. åˆ é™¤ä¸»æ•°æ®
    tables := []string{"users", "user_profiles", "query_history", "user_sessions"}
    for _, table := range tables {
        if err := g.deleteFromTable(ctx, table, userID); err != nil {
            return fmt.Errorf("åˆ é™¤è¡¨ %s ä¸­çš„æ•°æ®å¤±è´¥: %w", table, err)
        }
    }
    
    // 3. åˆ é™¤å¤‡ä»½ä¸­çš„æ•°æ®
    if err := g.deleteFromBackups(ctx, userID); err != nil {
        return fmt.Errorf("åˆ é™¤å¤‡ä»½æ•°æ®å¤±è´¥: %w", err)
    }
    
    // 4. åˆ é™¤æ—¥å¿—ä¸­çš„ä¸ªäººæ ‡è¯†ä¿¡æ¯
    if err := g.anonymizeLogsForUser(ctx, userID); err != nil {
        return fmt.Errorf("åŒ¿ååŒ–æ—¥å¿—å¤±è´¥: %w", err)
    }
    
    // 5. è®°å½•åˆ é™¤å®Œæˆ
    g.auditLogger.LogDataDeletionCompleted(ctx, userID, "full_deletion")
    
    return nil
}

// åŒæ„ç®¡ç†
func (g *GDPRService) UpdateConsent(ctx context.Context, userID string, consentType string, granted bool) error {
    consent := &ConsentRecord{
        UserID:      userID,
        ConsentType: consentType,
        Granted:     granted,
        UpdatedAt:   time.Now(),
        IPAddress:   getClientIP(ctx),
        UserAgent:   getUserAgent(ctx),
    }
    
    if err := g.consentMgr.UpdateConsent(ctx, consent); err != nil {
        return fmt.Errorf("æ›´æ–°åŒæ„çŠ¶æ€å¤±è´¥: %w", err)
    }
    
    // è®°å½•åŒæ„å˜æ›´
    g.auditLogger.LogConsentChange(ctx, userID, consentType, granted)
    
    // å¦‚æœæ’¤å›åŒæ„ï¼Œè§¦å‘ç›¸åº”çš„æ•°æ®å¤„ç†åœæ­¢
    if !granted {
        if err := g.handleConsentWithdrawal(ctx, userID, consentType); err != nil {
            return fmt.Errorf("å¤„ç†åŒæ„æ’¤å›å¤±è´¥: %w", err)
        }
    }
    
    return nil
}

// æ•°æ®ä¿ç•™ç®¡ç†
func (g *GDPRService) ManageDataRetention(ctx context.Context) error {
    // æŸ¥æ‰¾è¿‡æœŸæ•°æ®
    expiredData, err := g.retentionMgr.FindExpiredData(ctx)
    if err != nil {
        return fmt.Errorf("æŸ¥æ‰¾è¿‡æœŸæ•°æ®å¤±è´¥: %w", err)
    }
    
    for _, data := range expiredData {
        // è¯„ä¼°æ˜¯å¦å¯ä»¥åˆ é™¤
        if g.canDeleteData(data) {
            if err := g.deleteExpiredData(ctx, data); err != nil {
                log.Printf("åˆ é™¤è¿‡æœŸæ•°æ®å¤±è´¥: %v", err)
                continue
            }
            
            g.auditLogger.LogDataRetentionDeletion(ctx, data.UserID, data.DataType)
        }
    }
    
    return nil
}
```

---

## ğŸ“š æœ€ä½³å®è·µæ€»ç»“

### âœ… æ¨èåšæ³•

1. **é›¶ä¿¡ä»»æ¶æ„**
   - é»˜è®¤æ‹’ç»æ‰€æœ‰é€šä¿¡
   - æœåŠ¡é—´é€šä¿¡å¼ºåˆ¶mTLS
   - å®æ–½æœ€å°æƒé™åŸåˆ™

2. **èº«ä»½è®¤è¯**
   - å¼ºåˆ¶å¤šå› å­è®¤è¯
   - çŸ­æœŸJWTä»¤ç‰Œ
   - å®šæœŸå¯†é’¥è½®æ¢

3. **å¯†é’¥ç®¡ç†**
   - é›†ä¸­åŒ–å¯†é’¥ç®¡ç†
   - è‡ªåŠ¨åŒ–å¯†é’¥è½®æ¢
   - å®¡è®¡å¯†é’¥è®¿é—®

4. **åˆè§„ç®¡ç†**
   - å®Œæ•´å®¡è®¡è¿½è¸ª
   - è‡ªåŠ¨åŒ–åˆè§„æ£€æŸ¥
   - å®šæœŸåˆè§„å®¡è®¡

### âŒ é¿å…çš„é™·é˜±

1. **è¿‡åº¦å®½æ¾çš„æƒé™**
   - é¿å…ä½¿ç”¨cluster-adminæƒé™
   - ä¸è¦å¿½è§†ç½‘ç»œç­–ç•¥é…ç½®

2. **å¯†é’¥å®‰å…¨**
   - ä¸è¦åœ¨ä»£ç ä¸­ç¡¬ç¼–ç å¯†é’¥
   - é¿å…é•¿æœŸæœ‰æ•ˆçš„è®¿é—®ä»¤ç‰Œ

3. **åˆè§„ç–æ¼**
   - ä¸è¦å¿½è§†å®¡è®¡æ—¥å¿—ä¿ç•™
   - é¿å…å¤„ç†æ•°æ®ç¼ºä¹æ³•å¾‹ä¾æ®

---

## ğŸ”— ç›¸å…³èµ„æº

- **Istioå®‰å…¨æ–‡æ¡£**ï¼šhttps://istio.io/latest/docs/concepts/security/
- **Vaultå®˜æ–¹æ–‡æ¡£**ï¼šhttps://www.vaultproject.io/docs
- **Kuberneteså®‰å…¨æœ€ä½³å®è·µ**ï¼šhttps://kubernetes.io/docs/concepts/security/
- **GDPRåˆè§„æŒ‡å—**ï¼šhttps://gdpr.eu/

---

ğŸ’¡ **å®æ–½å»ºè®®**ï¼šæŒ‰ç…§ç¬¬3å‘¨çš„å¼€å‘è®¡åˆ’ï¼Œå…ˆé…ç½®åŸºç¡€å®‰å…¨ç­–ç•¥ï¼Œç„¶åé€æ­¥å®æ–½å¯†é’¥ç®¡ç†ã€åˆè§„å®¡è®¡ï¼Œç¡®ä¿å®‰å…¨åˆè§„100%è¾¾æ ‡ã€‚