# ğŸ‘ï¸ ç›‘æ§ä¸å¯è§‚æµ‹æ€§æŒ‡å—

## ğŸ¯ æŠ€æœ¯æ¦‚è¿°

å®Œæ•´çš„å¯è§‚æµ‹æ€§ä½“ç³»ä¸ºChat2SQLæä¾›äº†å…¨é“¾è·¯ç›‘æ§èƒ½åŠ›ï¼Œé€šè¿‡æŒ‡æ ‡ã€æ—¥å¿—ã€è¿½è¸ªä¸‰å¤§æ”¯æŸ±å®ç°ç³»ç»Ÿé€æ˜åŒ–ç®¡ç†ã€‚æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»P5é˜¶æ®µç¬¬2å‘¨çš„ç›‘æ§ä¸å¯è§‚æµ‹æ€§å®ç°ç­–ç•¥ã€‚

### âœ¨ æ ¸å¿ƒä»·å€¼

| åŠŸèƒ½ç‰¹æ€§ | æŠ€æœ¯å®ç° | ä¸šåŠ¡ä»·å€¼ | æ€§èƒ½æå‡ |
|---------|---------|---------|---------| 
| **æŒ‡æ ‡ç›‘æ§** | Prometheus + Grafana | å®æ—¶æ€§èƒ½ç›‘æ§ | é—®é¢˜å‘ç°æ—¶é—´å‡å°‘90% |
| **é“¾è·¯è¿½è¸ª** | Jaeger + OpenTelemetry | åˆ†å¸ƒå¼è°ƒç”¨åˆ†æ | é—®é¢˜å®šä½æ•ˆç‡æå‡80% |
| **æ—¥å¿—èšåˆ** | Loki + Promtail | é›†ä¸­åŒ–æ—¥å¿—ç®¡ç† | æ•…éšœæ’æŸ¥é€Ÿåº¦æå‡70% |
| **æ™ºèƒ½å‘Šè­¦** | AlertManager + PagerDuty | é¢„è­¦å’Œè‡ªåŠ¨åŒ–å“åº” | æ•…éšœå“åº”æ—¶é—´å‡å°‘85% |

### ğŸ ç›‘æ§åœºæ™¯

- **æ€§èƒ½ç›‘æ§**ï¼šAPIå“åº”æ—¶é—´ã€æ•°æ®åº“è¿æ¥ã€èµ„æºä½¿ç”¨ç‡
- **ä¸šåŠ¡ç›‘æ§**ï¼šSQLæŸ¥è¯¢å‡†ç¡®ç‡ã€AIæ¨¡å‹æ€§èƒ½ã€ç”¨æˆ·è¡Œä¸ºåˆ†æ
- **å®‰å…¨ç›‘æ§**ï¼šè®¿é—®å¼‚å¸¸ã€æƒé™å˜æ›´ã€å®‰å…¨äº‹ä»¶è¿½è¸ª
- **åŸºç¡€è®¾æ–½ç›‘æ§**ï¼šK8sé›†ç¾¤ã€èŠ‚ç‚¹çŠ¶æ€ã€ç½‘ç»œæµé‡

---

## ğŸ“Š Prometheusç›‘æ§ä½“ç³»

### ğŸ“¦ Prometheus Operatoréƒ¨ç½²

```yaml
# prometheus-operator.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
---
# Prometheus CRDé…ç½®
apiVersion: monitoring.coreos.com/v1
kind: Prometheus
metadata:
  name: chat2sql-prometheus
  namespace: monitoring
spec:
  replicas: 2
  retention: 30d
  storage:
    volumeClaimTemplate:
      spec:
        storageClassName: chat2sql-ssd
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 100Gi
  serviceMonitorSelector:
    matchLabels:
      team: chat2sql
  ruleSelector:
    matchLabels:
      team: chat2sql
  alerting:
    alertmanagers:
    - namespace: monitoring
      name: alertmanager-main
      port: web
  resources:
    requests:
      memory: 2Gi
      cpu: 1000m
    limits:
      memory: 4Gi
      cpu: 2000m
  securityContext:
    runAsNonRoot: true
    runAsUser: 65534
    fsGroup: 65534
---
# Grafanaé…ç½®
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:10.2.0
        ports:
        - containerPort: 3000
        env:
        - name: GF_SECURITY_ADMIN_PASSWORD
          valueFrom:
            secretKeyRef:
              name: grafana-secret
              key: admin-password
        - name: GF_AUTH_ANONYMOUS_ENABLED
          value: "false"
        - name: GF_AUTH_BASIC_ENABLED
          value: "true"
        volumeMounts:
        - name: grafana-storage
          mountPath: /var/lib/grafana
        - name: grafana-config
          mountPath: /etc/grafana/provisioning
        resources:
          requests:
            memory: 512Mi
            cpu: 250m
          limits:
            memory: 1Gi
            cpu: 500m
      volumes:
      - name: grafana-storage
        persistentVolumeClaim:
          claimName: grafana-pvc
      - name: grafana-config
        configMap:
          name: grafana-config
```

### ğŸ¯ ServiceMonitoré…ç½®

```yaml
# chat2sql-servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: chat2sql-backend
  namespace: monitoring
  labels:
    team: chat2sql
spec:
  selector:
    matchLabels:
      app: chat2sql-backend
  namespaceSelector:
    matchNames:
    - chat2sql
  endpoints:
  - port: metrics
    interval: 15s
    path: /metrics
    honorLabels: true
---
# PostgreSQL ServiceMonitor
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: postgresql-exporter
  namespace: monitoring
  labels:
    team: chat2sql
spec:
  selector:
    matchLabels:
      app: postgresql-exporter
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
---
# Redis ServiceMonitor
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: redis-exporter
  namespace: monitoring
  labels:
    team: chat2sql
spec:
  selector:
    matchLabels:
      app: redis-exporter
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
```

### ğŸ“ˆ è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†

```go
// Goåº”ç”¨æŒ‡æ ‡æ”¶é›†
package monitoring

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "time"
)

// Chat2SQLä¸šåŠ¡æŒ‡æ ‡
var (
    // SQLæŸ¥è¯¢ç›¸å…³æŒ‡æ ‡
    sqlQueryDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "chat2sql_query_duration_seconds",
            Help: "SQLæŸ¥è¯¢æ‰§è¡Œæ—¶é—´åˆ†å¸ƒ",
            Buckets: []float64{0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 30.0},
        },
        []string{"query_type", "status"},
    )
    
    sqlQueryTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "chat2sql_query_total",
            Help: "SQLæŸ¥è¯¢æ€»æ•°",
        },
        []string{"query_type", "status"},
    )
    
    // AIæ¨¡å‹ç›¸å…³æŒ‡æ ‡
    aiModelInference = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "chat2sql_ai_inference_duration_seconds",
            Help: "AIæ¨¡å‹æ¨ç†æ—¶é—´åˆ†å¸ƒ",
            Buckets: []float64{0.1, 0.5, 1.0, 3.0, 10.0, 30.0},
        },
        []string{"model_name", "model_provider"},
    )
    
    aiModelAccuracy = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "chat2sql_ai_accuracy_rate",
            Help: "AIæ¨¡å‹å‡†ç¡®ç‡",
        },
        []string{"model_name", "time_window"},
    )
    
    // ç³»ç»Ÿèµ„æºæŒ‡æ ‡
    activeDatabaseConnections = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "chat2sql_db_connections_active",
            Help: "æ´»è·ƒæ•°æ®åº“è¿æ¥æ•°",
        },
        []string{"database", "pool"},
    )
    
    cacheHitRate = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "chat2sql_cache_hit_rate",
            Help: "ç¼“å­˜å‘½ä¸­ç‡",
        },
        []string{"cache_type", "cache_name"},
    )
)

// æŒ‡æ ‡æ”¶é›†å™¨
type MetricsCollector struct {
    registry prometheus.Registerer
}

func NewMetricsCollector() *MetricsCollector {
    return &MetricsCollector{
        registry: prometheus.DefaultRegisterer,
    }
}

// è®°å½•SQLæŸ¥è¯¢æŒ‡æ ‡
func (mc *MetricsCollector) RecordSQLQuery(queryType, status string, duration time.Duration) {
    sqlQueryDuration.WithLabelValues(queryType, status).Observe(duration.Seconds())
    sqlQueryTotal.WithLabelValues(queryType, status).Inc()
}

// è®°å½•AIæ¨ç†æŒ‡æ ‡
func (mc *MetricsCollector) RecordAIInference(modelName, provider string, duration time.Duration) {
    aiModelInference.WithLabelValues(modelName, provider).Observe(duration.Seconds())
}

// æ›´æ–°AIå‡†ç¡®ç‡
func (mc *MetricsCollector) UpdateAIAccuracy(modelName, timeWindow string, accuracy float64) {
    aiModelAccuracy.WithLabelValues(modelName, timeWindow).Set(accuracy)
}

// æ›´æ–°æ•°æ®åº“è¿æ¥æ•°
func (mc *MetricsCollector) UpdateDatabaseConnections(database, pool string, count int) {
    activeDatabaseConnections.WithLabelValues(database, pool).Set(float64(count))
}

// æ›´æ–°ç¼“å­˜å‘½ä¸­ç‡
func (mc *MetricsCollector) UpdateCacheHitRate(cacheType, cacheName string, hitRate float64) {
    cacheHitRate.WithLabelValues(cacheType, cacheName).Set(hitRate)
}
```

### ğŸ”§ PrometheusRuleå‘Šè­¦è§„åˆ™

```yaml
# chat2sql-prometheus-rules.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: chat2sql-rules
  namespace: monitoring
  labels:
    team: chat2sql
spec:
  groups:
  - name: chat2sql.business
    interval: 30s
    rules:
    # SQLæŸ¥è¯¢æ€§èƒ½å‘Šè­¦
    - alert: HighSQLQueryLatency
      expr: |
        histogram_quantile(0.95, 
          rate(chat2sql_query_duration_seconds_bucket[5m])
        ) > 10
      for: 2m
      labels:
        severity: warning
        component: backend
      annotations:
        summary: "SQLæŸ¥è¯¢å»¶è¿Ÿè¿‡é«˜"
        description: "95%çš„SQLæŸ¥è¯¢å»¶è¿Ÿè¶…è¿‡10ç§’ï¼Œå½“å‰å€¼: {{ $value }}s"
        
    # AIæ¨¡å‹å‡†ç¡®ç‡å‘Šè­¦
    - alert: LowAIAccuracy
      expr: |
        chat2sql_ai_accuracy_rate < 0.85
      for: 5m
      labels:
        severity: critical
        component: ai-model
      annotations:
        summary: "AIæ¨¡å‹å‡†ç¡®ç‡ä¸‹é™"
        description: "AIæ¨¡å‹å‡†ç¡®ç‡ä½äº85%ï¼Œå½“å‰å€¼: {{ $value }}"
        
    # æ•°æ®åº“è¿æ¥æ± å‘Šè­¦
    - alert: DatabaseConnectionPoolExhaustion
      expr: |
        chat2sql_db_connections_active / 100 > 0.9
      for: 1m
      labels:
        severity: warning
        component: database
      annotations:
        summary: "æ•°æ®åº“è¿æ¥æ± å³å°†è€—å°½"
        description: "æ•°æ®åº“è¿æ¥æ± ä½¿ç”¨ç‡è¶…è¿‡90%ï¼Œå½“å‰: {{ $value }}%"
        
  - name: chat2sql.infrastructure
    interval: 30s
    rules:
    # Podé‡å¯å‘Šè­¦
    - alert: PodCrashLooping
      expr: |
        rate(kube_pod_container_status_restarts_total[15m]) > 0
      for: 5m
      labels:
        severity: critical
        component: kubernetes
      annotations:
        summary: "Podé¢‘ç¹é‡å¯"
        description: "Pod {{ $labels.pod }} åœ¨å‘½åç©ºé—´ {{ $labels.namespace }} ä¸­é¢‘ç¹é‡å¯"
        
    # å†…å­˜ä½¿ç”¨å‘Šè­¦
    - alert: HighMemoryUsage
      expr: |
        (container_memory_working_set_bytes / container_spec_memory_limit_bytes) > 0.9
      for: 5m
      labels:
        severity: warning
        component: resources
      annotations:
        summary: "å®¹å™¨å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜"
        description: "å®¹å™¨ {{ $labels.container }} å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡90%"
        
    # CPUä½¿ç”¨å‘Šè­¦
    - alert: HighCPUUsage
      expr: |
        rate(container_cpu_usage_seconds_total[5m]) > 0.8
      for: 10m
      labels:
        severity: warning
        component: resources
      annotations:
        summary: "å®¹å™¨CPUä½¿ç”¨ç‡è¿‡é«˜"
        description: "å®¹å™¨ {{ $labels.container }} CPUä½¿ç”¨ç‡è¶…è¿‡80%"
```

---

## ğŸ” Jaegeråˆ†å¸ƒå¼é“¾è·¯è¿½è¸ª

### ğŸ“¦ Jaeger Operatoréƒ¨ç½²

```yaml
# jaeger-operator.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: observability
---
apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: chat2sql-jaeger
  namespace: observability
spec:
  strategy: production
  storage:
    type: elasticsearch
    elasticsearch:
      nodeCount: 3
      storage:
        storageClassName: chat2sql-ssd
        size: 50Gi
      resources:
        requests:
          memory: 2Gi
          cpu: 1000m
        limits:
          memory: 4Gi
          cpu: 2000m
  collector:
    replicas: 3
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 500m
  query:
    replicas: 2
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 500m
  agent:
    strategy: DaemonSet
    resources:
      requests:
        memory: 128Mi
        cpu: 100m
      limits:
        memory: 256Mi
        cpu: 200m
---
# Jaeger Serviceé…ç½®
apiVersion: v1
kind: Service
metadata:
  name: jaeger-query
  namespace: observability
spec:
  selector:
    app: jaeger
    app.kubernetes.io/component: query
  ports:
  - port: 16686
    targetPort: 16686
    name: query-http
  type: ClusterIP
```

### ğŸ¯ OpenTelemetryé…ç½®

```go
// Goåº”ç”¨OpenTelemetryé›†æˆ
package tracing

import (
    "context"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.12.0"
    oteltrace "go.opentelemetry.io/otel/trace"
)

// åˆå§‹åŒ–è¿½è¸ª
func InitTracing(serviceName string) func() {
    // åˆ›å»ºJaeger exporter
    exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint("http://jaeger-collector:14268/api/traces")))
    if err != nil {
        panic(err)
    }

    // åˆ›å»ºèµ„æº
    res, err := resource.Merge(
        resource.Default(),
        resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceNameKey.String(serviceName),
            semconv.ServiceVersionKey.String("1.0.0"),
            attribute.String("environment", "production"),
        ),
    )
    if err != nil {
        panic(err)
    }

    // åˆ›å»ºè¿½è¸ªæä¾›è€…
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exp),
        trace.WithResource(res),
        trace.WithSampler(trace.AlwaysSample()),
    )

    // è®¾ç½®å…¨å±€è¿½è¸ªæä¾›è€…
    otel.SetTracerProvider(tp)
    
    // è®¾ç½®å…¨å±€ä¼ æ’­å™¨
    otel.SetTextMapPropagator(propagation.TraceContext{})

    return func() {
        if err := tp.Shutdown(context.Background()); err != nil {
            panic(err)
        }
    }
}

// Chat2SQLè¿½è¸ªå™¨
type Chat2SQLTracer struct {
    tracer oteltrace.Tracer
}

func NewChat2SQLTracer() *Chat2SQLTracer {
    return &Chat2SQLTracer{
        tracer: otel.Tracer("chat2sql"),
    }
}

// è¿½è¸ªSQLæŸ¥è¯¢
func (t *Chat2SQLTracer) TraceSQLQuery(ctx context.Context, query string) (context.Context, oteltrace.Span) {
    ctx, span := t.tracer.Start(ctx, "sql.query",
        oteltrace.WithAttributes(
            attribute.String("db.statement", query),
            attribute.String("db.system", "postgresql"),
            attribute.String("component", "database"),
        ),
    )
    return ctx, span
}

// è¿½è¸ªAIæ¨ç†
func (t *Chat2SQLTracer) TraceAIInference(ctx context.Context, model, prompt string) (context.Context, oteltrace.Span) {
    ctx, span := t.tracer.Start(ctx, "ai.inference",
        oteltrace.WithAttributes(
            attribute.String("ai.model", model),
            attribute.String("ai.prompt.length", fmt.Sprintf("%d", len(prompt))),
            attribute.String("component", "ai"),
        ),
    )
    return ctx, span
}

// è¿½è¸ªHTTPè¯·æ±‚
func (t *Chat2SQLTracer) TraceHTTPRequest(ctx context.Context, method, url string) (context.Context, oteltrace.Span) {
    ctx, span := t.tracer.Start(ctx, fmt.Sprintf("http.%s", strings.ToLower(method)),
        oteltrace.WithAttributes(
            attribute.String("http.method", method),
            attribute.String("http.url", url),
            attribute.String("component", "http"),
        ),
    )
    return ctx, span
}

// è®°å½•é”™è¯¯
func (t *Chat2SQLTracer) RecordError(span oteltrace.Span, err error) {
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
}
```

### ğŸ“Š åˆ†å¸ƒå¼è¿½è¸ªä¸­é—´ä»¶

```go
// HTTPè¿½è¸ªä¸­é—´ä»¶
func TracingMiddleware(tracer *Chat2SQLTracer) gin.HandlerFunc {
    return func(c *gin.Context) {
        ctx, span := tracer.TraceHTTPRequest(
            c.Request.Context(),
            c.Request.Method,
            c.Request.URL.String(),
        )
        defer span.End()

        // è®¾ç½®è¿½è¸ªä¸Šä¸‹æ–‡
        c.Request = c.Request.WithContext(ctx)
        
        // æ·»åŠ è¿½è¸ªIDåˆ°å“åº”å¤´
        if spanCtx := span.SpanContext(); spanCtx.IsValid() {
            c.Header("X-Trace-ID", spanCtx.TraceID().String())
        }

        c.Next()

        // è®°å½•å“åº”çŠ¶æ€
        span.SetAttributes(
            attribute.Int("http.status_code", c.Writer.Status()),
            attribute.String("http.route", c.FullPath()),
        )

        if c.Writer.Status() >= 400 {
            span.SetStatus(codes.Error, fmt.Sprintf("HTTP %d", c.Writer.Status()))
        }
    }
}

// æ•°æ®åº“è¿½è¸ªä¸­é—´ä»¶
func (db *Database) TracedQuery(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    tracer := NewChat2SQLTracer()
    ctx, span := tracer.TraceSQLQuery(ctx, query)
    defer span.End()

    start := time.Now()
    rows, err := db.QueryContext(ctx, query, args...)
    duration := time.Since(start)

    span.SetAttributes(
        attribute.String("db.operation", "query"),
        attribute.Float64("db.duration_ms", float64(duration.Nanoseconds())/1e6),
        attribute.Int("db.rows_affected", getRowCount(rows)),
    )

    if err != nil {
        tracer.RecordError(span, err)
    }

    return rows, err
}
```

---

## ğŸ“ Lokiæ—¥å¿—èšåˆç³»ç»Ÿ

### ğŸ“¦ Lokiéƒ¨ç½²é…ç½®

```yaml
# loki-stack.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: loki-config
  namespace: observability
data:
  loki.yaml: |
    auth_enabled: false
    server:
      http_listen_port: 3100
      grpc_listen_port: 9096
    
    common:
      path_prefix: /loki
      storage:
        filesystem:
          chunks_directory: /loki/chunks
          rules_directory: /loki/rules
      replication_factor: 1
      ring:
        instance_addr: 127.0.0.1
        kvstore:
          store: inmemory
    
    schema_config:
      configs:
        - from: 2020-10-24
          store: boltdb-shipper
          object_store: filesystem
          schema: v11
          index:
            prefix: index_
            period: 24h
    
    storage_config:
      boltdb_shipper:
        active_index_directory: /loki/boltdb-shipper-active
        cache_location: /loki/boltdb-shipper-cache
        cache_ttl: 24h
        shared_store: filesystem
      filesystem:
        directory: /loki/chunks
    
    compactor:
      working_directory: /loki/boltdb-shipper-compactor
      shared_store: filesystem
    
    limits_config:
      retention_period: 720h  # 30å¤©
      ingestion_rate_mb: 16
      ingestion_burst_size_mb: 32
    
    chunk_store_config:
      max_look_back_period: 0s
    
    table_manager:
      retention_deletes_enabled: true
      retention_period: 720h
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: loki
  namespace: observability
spec:
  serviceName: loki-headless
  replicas: 3
  selector:
    matchLabels:
      app: loki
  template:
    metadata:
      labels:
        app: loki
    spec:
      containers:
      - name: loki
        image: grafana/loki:2.9.0
        ports:
        - containerPort: 3100
          name: http
        - containerPort: 9096
          name: grpc
        volumeMounts:
        - name: config
          mountPath: /etc/loki
        - name: storage
          mountPath: /loki
        args:
        - -config.file=/etc/loki/loki.yaml
        resources:
          requests:
            memory: 1Gi
            cpu: 500m
          limits:
            memory: 2Gi
            cpu: 1000m
      volumes:
      - name: config
        configMap:
          name: loki-config
  volumeClaimTemplates:
  - metadata:
      name: storage
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: chat2sql-ssd
      resources:
        requests:
          storage: 50Gi
```

### ğŸ¯ Promtailæ—¥å¿—æ”¶é›†

```yaml
# promtail-daemonset.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: promtail
  namespace: observability
spec:
  selector:
    matchLabels:
      app: promtail
  template:
    metadata:
      labels:
        app: promtail
    spec:
      serviceAccountName: promtail
      containers:
      - name: promtail
        image: grafana/promtail:2.9.0
        args:
        - -config.file=/etc/promtail/config.yml
        volumeMounts:
        - name: config
          mountPath: /etc/promtail
        - name: varlog
          mountPath: /var/log
          readOnly: true
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        ports:
        - containerPort: 3101
          name: http-metrics
        resources:
          requests:
            memory: 128Mi
            cpu: 100m
          limits:
            memory: 256Mi
            cpu: 200m
      volumes:
      - name: config
        configMap:
          name: promtail-config
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      tolerations:
      - effect: NoSchedule
        operator: Exists
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: promtail-config
  namespace: observability
data:
  config.yml: |
    server:
      http_listen_port: 3101
      grpc_listen_port: 0
    
    positions:
      filename: /tmp/positions.yaml
    
    clients:
      - url: http://loki:3100/loki/api/v1/push
    
    scrape_configs:
    # Kubernetes Podæ—¥å¿—
    - job_name: kubernetes-pods
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - source_labels:
        - __meta_kubernetes_pod_annotation_prometheus_io_scrape
        action: keep
        regex: true
      - source_labels:
        - __meta_kubernetes_pod_annotation_prometheus_io_path
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels:
        - __address__
        - __meta_kubernetes_pod_annotation_prometheus_io_port
        action: replace
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
        target_label: __address__
      - action: labelmap
        regex: __meta_kubernetes_pod_label_(.+)
      - source_labels:
        - __meta_kubernetes_namespace
        action: replace
        target_label: kubernetes_namespace
      - source_labels:
        - __meta_kubernetes_pod_name
        action: replace
        target_label: kubernetes_pod_name
    
    # Chat2SQLåº”ç”¨æ—¥å¿—
    - job_name: chat2sql-logs
      static_configs:
      - targets:
        - localhost
        labels:
          job: chat2sql
          __path__: /var/log/containers/*chat2sql*.log
      pipeline_stages:
      - json:
          expressions:
            timestamp: time
            level: level
            message: msg
            service: service
      - timestamp:
          source: timestamp
          format: RFC3339
      - labels:
          level:
          service:
```

### ğŸ“Š ç»“æ„åŒ–æ—¥å¿—é…ç½®

```go
// Goåº”ç”¨ç»“æ„åŒ–æ—¥å¿—
package logging

import (
    "context"
    "github.com/sirupsen/logrus"
    "go.opentelemetry.io/otel/trace"
)

// ç»“æ„åŒ–æ—¥å¿—å™¨
type StructuredLogger struct {
    logger *logrus.Logger
}

func NewStructuredLogger() *StructuredLogger {
    logger := logrus.New()
    logger.SetFormatter(&logrus.JSONFormatter{
        TimestampFormat: "2006-01-02T15:04:05.000Z07:00",
        FieldMap: logrus.FieldMap{
            logrus.FieldKeyTime:  "timestamp",
            logrus.FieldKeyLevel: "level",
            logrus.FieldKeyMsg:   "message",
        },
    })
    
    return &StructuredLogger{logger: logger}
}

// è®°å½•SQLæŸ¥è¯¢æ—¥å¿—
func (l *StructuredLogger) LogSQLQuery(ctx context.Context, query string, duration time.Duration, err error) {
    fields := logrus.Fields{
        "component":     "database",
        "operation":     "sql_query",
        "query_hash":    hashQuery(query),
        "duration_ms":   duration.Milliseconds(),
        "query_length":  len(query),
    }
    
    // æ·»åŠ è¿½è¸ªä¿¡æ¯
    if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
        fields["trace_id"] = span.SpanContext().TraceID().String()
        fields["span_id"] = span.SpanContext().SpanID().String()
    }
    
    if err != nil {
        fields["error"] = err.Error()
        l.logger.WithFields(fields).Error("SQLæŸ¥è¯¢å¤±è´¥")
    } else {
        l.logger.WithFields(fields).Info("SQLæŸ¥è¯¢å®Œæˆ")
    }
}

// è®°å½•AIæ¨ç†æ—¥å¿—
func (l *StructuredLogger) LogAIInference(ctx context.Context, model, prompt string, tokens int, duration time.Duration) {
    fields := logrus.Fields{
        "component":      "ai",
        "operation":      "inference",
        "model":          model,
        "prompt_length":  len(prompt),
        "tokens_used":    tokens,
        "duration_ms":    duration.Milliseconds(),
    }
    
    // æ·»åŠ è¿½è¸ªä¿¡æ¯
    if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
        fields["trace_id"] = span.SpanContext().TraceID().String()
        fields["span_id"] = span.SpanContext().SpanID().String()
    }
    
    l.logger.WithFields(fields).Info("AIæ¨ç†å®Œæˆ")
}

// è®°å½•ç”¨æˆ·æ“ä½œæ—¥å¿—
func (l *StructuredLogger) LogUserAction(ctx context.Context, userID, action string, metadata map[string]interface{}) {
    fields := logrus.Fields{
        "component": "user_action",
        "user_id":   userID,
        "action":    action,
        "metadata":  metadata,
    }
    
    l.logger.WithFields(fields).Info("ç”¨æˆ·æ“ä½œè®°å½•")
}

// è®°å½•å®‰å…¨äº‹ä»¶
func (l *StructuredLogger) LogSecurityEvent(ctx context.Context, eventType, userID, ipAddress string, details map[string]interface{}) {
    fields := logrus.Fields{
        "component":   "security",
        "event_type":  eventType,
        "user_id":     userID,
        "ip_address":  ipAddress,
        "details":     details,
        "severity":    "warning",
    }
    
    l.logger.WithFields(fields).Warn("å®‰å…¨äº‹ä»¶æ£€æµ‹")
}

// æŸ¥è¯¢å“ˆå¸Œç”Ÿæˆ
func hashQuery(query string) string {
    // ç®€å•çš„æŸ¥è¯¢å“ˆå¸Œï¼Œç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ›´å®‰å…¨çš„å“ˆå¸Œ
    h := sha256.Sum256([]byte(query))
    return hex.EncodeToString(h[:8]) // åªå–å‰8å­—èŠ‚
}
```

---

## ğŸš¨ AlertManageræ™ºèƒ½å‘Šè­¦

### ğŸ“¦ AlertManageré…ç½®

```yaml
# alertmanager.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: alertmanager-config
  namespace: monitoring
data:
  alertmanager.yml: |
    global:
      smtp_smarthost: 'smtp.gmail.com:587'
      smtp_from: 'alerts@chat2sql.com'
      smtp_auth_username: 'alerts@chat2sql.com'
      smtp_auth_password: 'smtp-password'
    
    # è·¯ç”±é…ç½®
    route:
      group_by: ['alertname', 'cluster', 'service']
      group_wait: 10s
      group_interval: 10s
      repeat_interval: 1h
      receiver: 'web.hook'
      routes:
      # å…³é”®ä¸šåŠ¡å‘Šè­¦
      - match:
          severity: critical
        receiver: 'critical-alerts'
        group_wait: 0s
        repeat_interval: 15m
      # å®‰å…¨å‘Šè­¦
      - match:
          component: security
        receiver: 'security-team'
        group_wait: 0s
        repeat_interval: 5m
      # åŸºç¡€è®¾æ–½å‘Šè­¦
      - match:
          component: kubernetes
        receiver: 'infrastructure-team'
        repeat_interval: 30m
    
    # æŠ‘åˆ¶è§„åˆ™
    inhibit_rules:
    - source_match:
        severity: 'critical'
      target_match:
        severity: 'warning'
      equal: ['alertname', 'cluster', 'service']
    
    receivers:
    # é»˜è®¤æ¥æ”¶å™¨
    - name: 'web.hook'
      webhook_configs:
      - url: 'http://webhook-service:8080/alerts'
        send_resolved: true
    
    # å…³é”®å‘Šè­¦æ¥æ”¶å™¨
    - name: 'critical-alerts'
      email_configs:
      - to: 'oncall@chat2sql.com'
        subject: 'ğŸš¨ Chat2SQLå…³é”®å‘Šè­¦: {{ .GroupLabels.alertname }}'
        body: |
          {{ range .Alerts }}
          å‘Šè­¦: {{ .Annotations.summary }}
          æè¿°: {{ .Annotations.description }}
          æ ‡ç­¾: {{ range .Labels.SortedPairs }}{{ .Name }}={{ .Value }} {{ end }}
          æ—¶é—´: {{ .StartsAt }}
          {{ end }}
      slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK'
        channel: '#critical-alerts'
        title: 'ğŸš¨ Chat2SQLå…³é”®å‘Šè­¦'
        text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
      pagerduty_configs:
      - service_key: 'your-pagerduty-service-key'
        description: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
    
    # å®‰å…¨å›¢é˜Ÿæ¥æ”¶å™¨
    - name: 'security-team'
      email_configs:
      - to: 'security@chat2sql.com'
        subject: 'ğŸ”’ Chat2SQLå®‰å…¨å‘Šè­¦: {{ .GroupLabels.alertname }}'
      slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/SECURITY/WEBHOOK'
        channel: '#security-alerts'
        title: 'ğŸ”’ å®‰å…¨äº‹ä»¶æ£€æµ‹'
    
    # åŸºç¡€è®¾æ–½å›¢é˜Ÿæ¥æ”¶å™¨
    - name: 'infrastructure-team'
      email_configs:
      - to: 'infra@chat2sql.com'
        subject: 'âš ï¸ Chat2SQLåŸºç¡€è®¾æ–½å‘Šè­¦: {{ .GroupLabels.alertname }}'
      slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/INFRA/WEBHOOK'
        channel: '#infrastructure-alerts'
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: alertmanager
  namespace: monitoring
spec:
  replicas: 3
  selector:
    matchLabels:
      app: alertmanager
  template:
    metadata:
      labels:
        app: alertmanager
    spec:
      containers:
      - name: alertmanager
        image: prom/alertmanager:v0.26.0
        ports:
        - containerPort: 9093
        volumeMounts:
        - name: config
          mountPath: /etc/alertmanager
        - name: storage
          mountPath: /alertmanager
        args:
        - --config.file=/etc/alertmanager/alertmanager.yml
        - --storage.path=/alertmanager
        - --web.external-url=https://alertmanager.chat2sql.com
        - --cluster.listen-address=0.0.0.0:9094
        - --cluster.peer=alertmanager-0.alertmanager:9094
        - --cluster.peer=alertmanager-1.alertmanager:9094
        - --cluster.peer=alertmanager-2.alertmanager:9094
        resources:
          requests:
            memory: 256Mi
            cpu: 100m
          limits:
            memory: 512Mi
            cpu: 200m
      volumes:
      - name: config
        configMap:
          name: alertmanager-config
      - name: storage
        persistentVolumeClaim:
          claimName: alertmanager-storage
```

### ğŸ¯ æ™ºèƒ½å‘Šè­¦è„šæœ¬

```go
// æ™ºèƒ½å‘Šè­¦å¤„ç†å™¨
package alerting

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

// å‘Šè­¦æ¶ˆæ¯ç»“æ„
type Alert struct {
    Status       string            `json:"status"`
    Labels       map[string]string `json:"labels"`
    Annotations  map[string]string `json:"annotations"`
    StartsAt     time.Time         `json:"startsAt"`
    EndsAt       time.Time         `json:"endsAt"`
    GeneratorURL string            `json:"generatorURL"`
}

type AlertMessage struct {
    Receiver          string  `json:"receiver"`
    Status            string  `json:"status"`
    Alerts            []Alert `json:"alerts"`
    GroupLabels       map[string]string `json:"groupLabels"`
    CommonLabels      map[string]string `json:"commonLabels"`
    CommonAnnotations map[string]string `json:"commonAnnotations"`
    ExternalURL       string  `json:"externalURL"`
}

// æ™ºèƒ½å‘Šè­¦å¤„ç†å™¨
type IntelligentAlertHandler struct {
    slackClient  *SlackClient
    emailClient  *EmailClient
    ticketClient *TicketingClient
}

func NewIntelligentAlertHandler() *IntelligentAlertHandler {
    return &IntelligentAlertHandler{
        slackClient:  NewSlackClient(),
        emailClient:  NewEmailClient(),
        ticketClient: NewTicketingClient(),
    }
}

// å¤„ç†å‘Šè­¦Webhook
func (h *IntelligentAlertHandler) HandleWebhook(w http.ResponseWriter, r *http.Request) {
    var alertMsg AlertMessage
    if err := json.NewDecoder(r.Body).Decode(&alertMsg); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }

    ctx := r.Context()
    
    for _, alert := range alertMsg.Alerts {
        if err := h.processAlert(ctx, alert); err != nil {
            log.Printf("å¤„ç†å‘Šè­¦å¤±è´¥: %v", err)
        }
    }

    w.WriteHeader(http.StatusOK)
}

// å¤„ç†å•ä¸ªå‘Šè­¦
func (h *IntelligentAlertHandler) processAlert(ctx context.Context, alert Alert) error {
    severity := alert.Labels["severity"]
    component := alert.Labels["component"]
    
    // åŸºäºä¸¥é‡æ€§å’Œç»„ä»¶è¿›è¡Œæ™ºèƒ½è·¯ç”±
    switch severity {
    case "critical":
        return h.handleCriticalAlert(ctx, alert)
    case "warning":
        return h.handleWarningAlert(ctx, alert)
    default:
        return h.handleInfoAlert(ctx, alert)
    }
}

// å¤„ç†å…³é”®å‘Šè­¦
func (h *IntelligentAlertHandler) handleCriticalAlert(ctx context.Context, alert Alert) error {
    // ç«‹å³é€šçŸ¥
    if err := h.slackClient.SendUrgentAlert(alert); err != nil {
        return fmt.Errorf("å‘é€Slackç´§æ€¥å‘Šè­¦å¤±è´¥: %w", err)
    }
    
    // åˆ›å»ºæ•…éšœå•
    ticketID, err := h.ticketClient.CreateIncident(alert)
    if err != nil {
        return fmt.Errorf("åˆ›å»ºæ•…éšœå•å¤±è´¥: %w", err)
    }
    
    // è§¦å‘è‡ªåŠ¨åŒ–ä¿®å¤
    if err := h.triggerAutoRemediation(ctx, alert); err != nil {
        log.Printf("è‡ªåŠ¨åŒ–ä¿®å¤å¤±è´¥: %v", err)
    }
    
    log.Printf("å…³é”®å‘Šè­¦å¤„ç†å®Œæˆï¼Œæ•…éšœå•ID: %s", ticketID)
    return nil
}

// è§¦å‘è‡ªåŠ¨åŒ–ä¿®å¤
func (h *IntelligentAlertHandler) triggerAutoRemediation(ctx context.Context, alert Alert) error {
    alertName := alert.Labels["alertname"]
    
    switch alertName {
    case "PodCrashLooping":
        return h.restartPod(ctx, alert.Labels["pod"], alert.Labels["namespace"])
    case "HighMemoryUsage":
        return h.scaleUpDeployment(ctx, alert.Labels["deployment"], alert.Labels["namespace"])
    case "DatabaseConnectionPoolExhaustion":
        return h.restartDatabaseConnection(ctx)
    default:
        log.Printf("æ²¡æœ‰ä¸ºå‘Šè­¦ %s é…ç½®è‡ªåŠ¨ä¿®å¤", alertName)
        return nil
    }
}

// é‡å¯Pod
func (h *IntelligentAlertHandler) restartPod(ctx context.Context, podName, namespace string) error {
    log.Printf("è‡ªåŠ¨é‡å¯Pod: %s/%s", namespace, podName)
    // å®ç°Podé‡å¯é€»è¾‘
    return nil
}

// æ‰©å®¹Deployment
func (h *IntelligentAlertHandler) scaleUpDeployment(ctx context.Context, deployment, namespace string) error {
    log.Printf("è‡ªåŠ¨æ‰©å®¹Deployment: %s/%s", namespace, deployment)
    // å®ç°Deploymentæ‰©å®¹é€»è¾‘
    return nil
}
```

---

## ğŸ“š æœ€ä½³å®è·µæ€»ç»“

### âœ… æ¨èåšæ³•

1. **ç›‘æ§æŒ‡æ ‡è®¾è®¡**
   - ä¸šåŠ¡æŒ‡æ ‡ä¼˜å…ˆäºæŠ€æœ¯æŒ‡æ ‡
   - ä½¿ç”¨SLI/SLOé©±åŠ¨å‘Šè­¦é˜ˆå€¼
   - å®ç°å¤šç»´åº¦æ ‡ç­¾åŒ–

2. **æ—¥å¿—ç®¡ç†**
   - ç»“æ„åŒ–æ—¥å¿—ç»Ÿä¸€æ ¼å¼
   - æ•æ„Ÿä¿¡æ¯è„±æ•å¤„ç†
   - åˆç†è®¾ç½®æ—¥å¿—ä¿ç•™æœŸ

3. **å‘Šè­¦ä¼˜åŒ–**
   - é¿å…å‘Šè­¦é£æš´
   - å®ç°å‘Šè­¦åˆ†çº§å’Œè·¯ç”±
   - å»ºç«‹å‘Šè­¦é—­ç¯æµç¨‹

4. **é“¾è·¯è¿½è¸ª**
   - åˆç†è®¾ç½®é‡‡æ ·ç‡
   - å…³é”®è·¯å¾„100%è¿½è¸ª
   - é¿å…è¿½è¸ªå¼€é”€è¿‡å¤§

### âŒ é¿å…çš„é™·é˜±

1. **æŒ‡æ ‡è¿‡è½½**
   - é¿å…æ”¶é›†æ— ç”¨æŒ‡æ ‡
   - æ§åˆ¶æŒ‡æ ‡åŸºæ•°å¢é•¿

2. **å‘Šè­¦ç–²åŠ³**
   - é¿å…è®¾ç½®è¿‡ä½é˜ˆå€¼
   - å‡å°‘æ— æ•ˆå‘Šè­¦

3. **å­˜å‚¨æˆæœ¬**
   - åˆç†è®¾ç½®æ•°æ®ä¿ç•™æœŸ
   - ä½¿ç”¨åˆ†å±‚å­˜å‚¨ç­–ç•¥

---

## ğŸ”— ç›¸å…³èµ„æº

- **Prometheuså®˜æ–¹æ–‡æ¡£**ï¼šhttps://prometheus.io/docs/
- **Jaegerå®˜æ–¹æ–‡æ¡£**ï¼šhttps://www.jaegertracing.io/docs/
- **Lokiå®˜æ–¹æ–‡æ¡£**ï¼šhttps://grafana.com/docs/loki/
- **OpenTelemetryå®˜æ–¹æ–‡æ¡£**ï¼šhttps://opentelemetry.io/docs/

---

ğŸ’¡ **å®æ–½å»ºè®®**ï¼šæŒ‰ç…§ç¬¬2å‘¨çš„å¼€å‘è®¡åˆ’ï¼Œå…ˆéƒ¨ç½²åŸºç¡€ç›‘æ§ç³»ç»Ÿï¼Œç„¶åé€æ­¥æ·»åŠ ä¸šåŠ¡æŒ‡æ ‡ã€é“¾è·¯è¿½è¸ªå’Œæ™ºèƒ½å‘Šè­¦ï¼Œç¡®ä¿ç›‘æ§è¦†ç›–ç‡è¾¾åˆ°100%ã€‚